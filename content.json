{"meta":{"title":"张利源","subtitle":"","description":"但愿日子平静，抬头遇见的都是柔情","author":"张利源","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-17T08:00:27.682Z","updated":"2020-05-17T08:00:27.682Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-05-21T03:07:01.804Z","updated":"2020-05-21T03:07:01.804Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"欢迎添加我的QQ！！！ java小白一枚"},{"title":"我的朋友们","date":"2020-05-17T07:58:54.752Z","updated":"2020-05-17T07:58:54.752Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2020-05-17T07:56:17.193Z","updated":"2020-05-17T07:56:17.193Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Java JavaWeb 软件"},{"title":"所有分类","date":"2020-05-17T07:54:19.336Z","updated":"2020-05-17T07:54:19.336Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java位运算符","slug":"Java位运算符","date":"2020-07-16T09:56:31.000Z","updated":"2020-07-16T10:52:05.088Z","comments":true,"path":"2020/07/16/Java位运算符/","link":"","permalink":"http://yoursite.com/2020/07/16/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"位运算符","text":"位运算符 位运算符关于位运算符无非也就 与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;) 位运算其实就是二进制的运算，加减乘除适用于十进制，而位运算就是二进制的运算,但是由于我们的运算都是基于十进制来说的，所以会有点绕，略微有点难懂，接下来言归正传 与运算符(&amp;)4&amp;7 我们需要把两个二进制转换成十进制 4：0000 0100 7：0000 0111 这里提到一点：1表示true，0表示false 而与运算的时候相同位之间其实就是两个Boolean的运算 ​ 全true(1),即为true(1) ​ 全false(0),即为false(0) ​ 一false(0)一true(1),还是false(0) 或运算符(|) 以 5|9 为例 5 ： 0000 0101 9 ： 0000 1001 在做与运算的时候 ​ 遇true(1)就是true(1), ​ 无true(1)就是false(0) 异或运算符(^) 以 7^15 为例 7： 0000 0111 15： 0000 1111 在异或的时候 ​ 只要相同都是false(0) ​ 只有不同才是true(1) 取反运算符(~)例： ~15 同样的先变成二进制：15：0000 1111 这个其实挺简单的，就是把1变0，0变1 注意：二进制中，最高位是符号位 1表示负数，0表示正数 左移运算(&lt;&lt;) 左移就是把所有位向左移动几位 如： 12 &lt;&lt; 2 意思就是12向左移动两位 ​ 12的二进制是： 0000 1100 通过这个图我们可以看出来，所有的位全都向左移动两位，然后把右边空的两个位用0补上，最左边多出的两个位去掉，最后得到的结果就是00110000 结果就是48 我们用同样的办法算 12&lt;&lt;3 结果是 96 ​ 8&lt;&lt;4 结果是 128 由此我们得出一个快速的算法 M &lt;&lt; n 其实可以这么算 M &lt;&lt; n = M * 2n 右移运算符(&gt;&gt;)这个跟左移运算大体是一样的 例： 12 &gt;&gt; 2 我们可以看出来右移和左移其实是一样的，但是还是有点不同的，不同点在于对于正数和负数补位的时候补的不一样，负数补1，正数补0 如我们再做一个 –8 的 -8&gt;&gt;2 这里总结一下，关于负数或者正数来说，移位的时候是一样的，但是在补位的时候，如果最高位是0就补0，如果最高位是1就补1 由此我们得出一个快速的算法 M &gt;&gt; n 其实可以这么算 M &gt;&gt; n = M / 2^**n** 无符号右移(&gt;&gt;&gt;)无符号右移(&gt;&gt;&gt;)只对32位和64位有意义 在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"SpringMVC笔记(五)","slug":"SpringMVC笔记-五","date":"2020-07-03T12:24:42.000Z","updated":"2020-07-03T12:30:41.135Z","comments":true,"path":"2020/07/03/SpringMVC笔记-五/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%94/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 重点@ResponseBody阻止视图解析器的效果，会直接返回一个字符串 Json交互处理 什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 123&#123;\"name\": \"QinJiang\"&#125;&#123;\"age\": \"3\"&#125;&#123;\"sex\": \"男\"&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: 'Hello', b: 'World'&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse('&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;');//结果是 &#123;a: 'Hello', b: 'World'&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;);//结果是 '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;' Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617@Controllerpublic class UserController &#123; @RequestMapping(\"/json1\") @ResponseBody//阻止视图解析器的效果，会直接返回一个字符串 public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 1234567891011121314151617@RestControllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 1234567891011121314151617181920@RequestMapping(\"/json2\")public String json2() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;&#125; 运行结果 : 十分完美，没有任何问题！","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(四)","slug":"SpringMVC笔记-四","date":"2020-07-03T12:04:50.000Z","updated":"2020-07-03T12:15:01.862Z","comments":true,"path":"2020/07/03/SpringMVC笔记-四/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E5%9B%9B/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 结果跳转方式ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; ServletAPI通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 123456789101112131415161718192021@Controllerpublic class ResultGo &#123; @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.getWriter().println(\"Hello,Spring BY servlet API\"); &#125; @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(\"/index.jsp\"); &#125; @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); &#125;&#125; SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 1234567891011121314151617181920@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(\"/rsm/t1\") public String test1()&#123; //转发 return \"/index.jsp\"; &#125; @RequestMapping(\"/rsm/t2\") public String test2()&#123; //转发二 return \"forward:/index.jsp\"; &#125; @RequestMapping(\"/rsm/t3\") public String test3()&#123; //重定向 return \"redirect:/index.jsp\"; &#125;&#125; 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 12345678910111213141516@Controllerpublic class ResultSpringMVC2 &#123; @RequestMapping(\"/rsm2/t1\") public String test1()&#123; //转发 return \"test\"; &#125; @RequestMapping(\"/rsm2/t2\") public String test2()&#123; //重定向 return \"redirect:/index.jsp\"; //return \"redirect:hello.do\"; //hello.do为另一个请求/ &#125;&#125; 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=zhangsan 处理方法 : 12345@RequestMapping(\"/hello\")public String hello(String name)&#123; System.out.println(name); return \"hello\";&#125; 后台输出 : zhangsan 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=zhangsan 处理方法 : 123456//@RequestParam(\"username\") : username提交的域的名称 .@RequestMapping(\"/hello\")public String hello(@RequestParam(\"username\") String name)&#123; System.out.println(name); return \"hello\";&#125; 后台输出 : zhangsan 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 12345678public class User &#123; private int id; private String name; private int age; //构造 //get/set //tostring()&#125; 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 3、处理方法 : 12345@RequestMapping(&quot;&#x2F;user&quot;)public String user(User user)&#123; System.out.println(user); return &quot;hello&quot;;&#125; 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 第二种 : 通过ModelMap ModelMap 12345678@RequestMapping(\"/hello\")public String hello(@RequestParam(\"username\") String name, ModelMap model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\";&#125; 第三种 : 通过Model Model 12345678@RequestMapping(\"/ct2/hello\")public String hello(@RequestParam(\"username\") String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\";&#125; 对比就对于新手而言简单来说使用区别就是： 12345Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题测试步骤： 1、我们可以在首页编写一个提交的表单 1234&lt;form action=\"/e/t\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 2、后台编写对应的处理类 12345678@Controllerpublic class Encoding &#123; @RequestMapping(\"/e/t\") public String test(Model model,String name)&#123; model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 &#125;&#125; 3、输入中文测试，发现乱码 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(三)","slug":"SpringMVC笔记-三","date":"2020-07-03T11:50:18.000Z","updated":"2020-07-03T12:04:29.119Z","comments":true,"path":"2020/07/03/SpringMVC笔记-三/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 RestFul和控制器控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 123456789101112//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; 增加一个ControllerTest2类，使用注解实现； 1234567891011121314//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2&#123; //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; &#125;&#125; 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping@RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(\"/admin\")public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController 123@Controllerpublic class RestFulController &#123;&#125; 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 12345678910111213141516@Controllerpublic class RestFulController &#123; //映射访问路径 @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\") public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; &#125; &#125; 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 123456//映射访问路径,必须是POST请求@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.POST&#125;)public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\";&#125; 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； 123456//映射访问路径,必须是Get请求@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.GET&#125;)public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\";&#125; 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(二)","slug":"SpringMVC笔记-二","date":"2020-07-03T08:06:21.000Z","updated":"2020-07-03T11:49:00.095Z","comments":true,"path":"2020/07/03/SpringMVC笔记-二/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%8C/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 第一个SpringMVC程序配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， 注册DispatcherServlet 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 5、添加 处理映射器 1&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 6、添加 处理器适配器 1&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 7、添加 视图解析器 1234567&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 123456789101112131415161718import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author zhang * @date 2020/7/2 19:46 */public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"HelloSpringMVC!!!\"); //视图跳转 mv.setViewName(\"test\"); return mv; &#125;&#125; 9、将自己的类交给SpringIOC容器，注册bean 12&lt;!--Handler--&gt;&lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 注意点： / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 123456789101112131415161718192021222324252627282930314. 1. 在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 2. - 让IOC的注解生效 - 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ..... - MVC的注解驱动 - 配置视图解析器1. **6、创建Controller**2. 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范3. &#96;&#96;&#96;java import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; &#x2F;** * @author zhang * @date 2020&#x2F;7&#x2F;2 20:20 *&#x2F; @Controller @RequestMapping(&quot;&#x2F;hello&quot;) public class HelloController &#123; @RequestMapping(&quot;&#x2F;h1&quot;) public String hello(Model model)&#123; &#x2F;&#x2F;封装数据 model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVCAnnotation!&quot;); return &quot;hello&quot;; &#125; &#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(一)","slug":"SpringMVC笔记-一","date":"2020-06-23T11:12:16.000Z","updated":"2020-06-23T11:14:33.387Z","comments":true,"path":"2020/06/23/SpringMVC笔记-一/","link":"","permalink":"http://yoursite.com/2020/06/23/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 SpringMVCssm:mybats+Spring+SpringMVC MVC三层架构 回顾MVC1.1什么是MVC? MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.2Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.3Model2时代Model2把一个项目分成三部分，包括视图、控制、模型 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 什么是SpringMVC2.1概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 2.2、中心控制器​ Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 2.3、SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"注解和反射","slug":"注解和反射","date":"2020-06-12T10:43:27.000Z","updated":"2020-06-12T10:45:22.336Z","comments":true,"path":"2020/06/12/注解和反射/","link":"","permalink":"http://yoursite.com/2020/06/12/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"注解和反射笔记","text":"注解和反射笔记 注解什么是注解java.Annotation包 Annotation是从JDK5.0开始引入的新技术 Annotation的作用： 不是程序本事，可以对程序做出解释（这一点和注释comment没什么区别） 可以被其他程序（比如编译器）读取 Annotation的格式 注解是以”@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=”unchecked”) Annotation在哪里使用? 可以附加在package，class，method，filed等上面， 相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解@Override：定义在java.lang.Override中，此注解只适合用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明@Deprecated：定义在java.lang.Deprecated中，此注解可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为他们很危险或者存在更好的选择 @SuppressWarnings:定义在java.lang.SuppressWarning中，用来抑制编译时的警告信息。 元注解 元注解的作用就是负责注解其他注解，java定义了4个标准的meta-annotation类型，他们被用来提供给对其他annotation类型做说明 @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 （SOURCE&lt;CLASS&lt;RUNTIME） @Document：说明该注解将被包含在javadoc中 Inherited：说明子类可以继承父类中的该注解 自定义注解使用@interface自定义注解时，自动继承了java.lang.anntation.Anntation接口 分析： @interface用来声明一个注解，格式：public @interface 注解名 {定义内容} 其中每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值的类型就是参数的类型（返回值只能是基本类型，Class，String，enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须有值，我们定义注解元素时，经常使用空字符串，0作为默认值 12345678910111213141516171819/** * @author zhang * @date 2020/6/10 19:05 */public class Demo3 &#123; @MyAnnotation2(name = \"张三\",schools = &#123;\"黑龙江八一农垦大学\"&#125;) public void test()&#123;&#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2&#123; //注解的参数 String name() default \"\"; int age() default 0; int id() default 1; String[] schools() default &#123;\"清华大学\"&#125;;&#125; 反射反射概述 Reflection(反射)时Java被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法 Class c = Class.forName(&quot;java.lang.String&quot;) 加载完类之后，在堆内存的方法去中就产生了一个class类型的对象(一个类只有一个class对象)，这个对象就包含了完整的类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射 Java反射的优缺点 优点：可以实现动态创建对象和编译，体现出很大的灵活性 缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么兵器它满足我们的需求。这类操作总是慢于直接执行相同的操作。 获得反射对象Class类 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定的某个结构(class/interface/enum/annotation/primitive type/void[])的有关信息。 Class本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，支队任何你想动态加载、运行的类，唯有先获得相应的Class对象 Class的常用方法 方法名 功能说明 static ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回一个Class对象的实例 getName() 返回此Class对象表示的实体(类、接口、数组类或void)的名称 Class getSuperClass 返回当前Class对象的父类Class对象 Class[] getinterfaces 返回当前Class对象的接口 ClassLoader getClassLoader 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Method getMethod(String name,Class.. T) 返回一个Method对象，此对象的参数类型为paramType Field[] getDeclaredFields() 返回Field对象的一个数组 Java内存分析 类的加载过程 当程序主动使用某个类时，如果该类未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时的数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将java类的二进制文件合并到JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用(常量名)替换为直接引用（地址）的过程 初始化： 执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法由编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器时构造类信息的，不是构造该类对象的构造器） 当初始化一个类的时候，如果发现器父类没有进行初始化，则需要先触发器父类的初始化 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。 什么时候会发生类的初始化？ 类的主动引用（一定会发生类的初始化） 当虚拟机启动时，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就已经存入调用类的常量池了） 类加载器类加载器的作用：将class文件的字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口， 类缓存：标准的javaSE类可以按照要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 获取运行时类的完整结构通过反射获取运行时类的完整结构 Field、Method、Constructor、Superclass、Interface、Annotation 实现类的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * @author zhang * @date 2020/6/12 15:59 */public class Demo6 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class&lt;?&gt; c1 = Class.forName(\"reflect.User\"); //获得类的名字 System.out.println(c1.getName()); System.out.println(c1.getSimpleName()); //获得类的属性 Field[] fields = c1.getFields();//只能获得public修饰的 for (Field field : fields) &#123; System.out.println(field); &#125; Field[] fields1 = c1.getDeclaredFields(); for (Field field : fields1) &#123; System.out.println(field); &#125; //获得类的方法 Method[] methods = c1.getMethods();//获得本类机器父类的全部public方法 for (Method method : methods) &#123; System.out.println(method); &#125; //获得构造器 Constructor&lt;?&gt;[] constructors = c1.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) &#123; System.out.println(constructor); &#125; //获得指定的构造器 Constructor&lt;?&gt; constructor = c1.getConstructor(String.class,int.class,int.class); System.out.println(constructor); &#125;&#125; 有了class对象，能做什么？创建类的对象：调用Class对象的newInstance()方法 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 调用指定的方法 通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod(String name,Class..parameterTypes)方法取得一个Method对象，并设置此方法操作是锁需要的参数类型 之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。 Object invoke(Object obj,Object...args) Object对应原方法的返回值，若方法无返回值，此时返回null 若原方法为静态方法，此时形参Object obj可为null 若原方法参数列表为空，则Object[] args为null 若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(四)","slug":"Spring学习笔记-四","date":"2020-06-10T03:45:44.000Z","updated":"2020-06-10T03:48:29.516Z","comments":true,"path":"2020/06/10/Spring学习笔记-四/","link":"","permalink":"http://yoursite.com/2020/06/10/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/","excerpt":"Spring学习笔记","text":"Spring学习笔记 整合MyBatis步骤： 导入相关jar包 junit mybatis mysql数据库 spring相关的 aop植入 mybatis-spring【new】 编写配置文件 测试 回忆MyBatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 Mybatis-SpringMyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。 要使用 MyBatis-Spring 模块，只需要在类路径下包含 mybatis-spring-2.0.5.jar 文件和相关依赖即可。如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt;&lt;/dependency&gt; 步骤： 编写数据源 sqlSessionfactory sqlSessionTemplate 需要接口加实现类 将自己写的实现类注入到spring中测试使用 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--DataSource:使用Spring的数据源替换Mybatis的配置--&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\"/&gt; &lt;!--绑定MyBatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/demo/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionTemplate就是我们使用的sqlSession--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--只能使用构造器注入 没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"teacherMapper\" class=\"com.demo.mapper.TeacherMapperImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt;&lt;/beans&gt; TeacherMapperImpl.java 123456789101112131415161718/** * @author zhang * @date 2020/6/7 18:42 */public class TeacherMapperImpl implements TeacherMapper&#123; //我们的所有操作都需要SqlSession来执行，现在使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;Teacher&gt; selectTeacher() &#123; TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); return mapper.selectTeacher(); &#125;&#125; SqlSessionDaoSupportSqlSessionDaoSupport 是一个抽象的支持类，用来为你提供 SqlSession。调用 getSqlSession() 方法你会得到一个 SqlSessionTemplate，之后可以用于执行 SQL 方法，就像下面这样: 12345public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; public User getUser(String userId) &#123; return getSqlSession().selectOne(\"org.mybatis.spring.sample.mapper.UserMapper.getUser\", userId); &#125;&#125; 在这个类里面，通常更倾向于使用 MapperFactoryBean，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。 SqlSessionDaoSupport 需要通过属性设置一个 sqlSessionFactory 或 SqlSessionTemplate。如果两个属性都被设置了，那么 SqlSessionFactory 将被忽略。 假设类 UserMapperImpl 是 SqlSessionDaoSupport 的子类，可以编写如下的 Spring 配置来执行设置： 123&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;&lt;&#x2F;bean&gt; 声明式事务回顾事务 把一组业务当成一个业务来做，要么都成功，要么都失败 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎 确保完整性和一致性 事务的ACID原则： 原子性 一致性 隔离性 持久性 Spring中事务管理 声明式事务：AOP 编程式事务：需要在代码中，进行事务的管理 一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。 一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。 事务配置好了以后，MyBatis-Spring 将会透明地管理事务。这样在你的 DAO 类中就不需要额外的代码了。 标准配置要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象： 1234567&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"dataSource\" /&gt;&lt;/bean&gt;@Beanpublic DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource());&#125; 传入的 DataSource 可以是任何能够与 Spring 兼容的 JDBC DataSource。包括连接池和通过 JNDI 查找获得的 DataSource。 注意：为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的是同一个数据源，否则事务管理器就无法工作了。 1234567891011121314151617181920&lt;!--配置声明式事务--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"datasource\"/&gt; &lt;/bean&gt; &lt;!--结合AOP实现事务的织入--&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\"/&gt; &lt;tx:method name=\"update\"/&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.demospring.Mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt; &lt;/aop:config&gt; 为什么需要事务？ 如果不配置事务，可能存在数据提交不一致情况 如果我们不在Spring中去配置声明事务，我们就需要在代码中手动配置事务 事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不能马虎","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(三)","slug":"Spring学习笔记-三","date":"2020-06-06T10:40:01.000Z","updated":"2020-06-06T10:41:47.579Z","comments":true,"path":"2020/06/06/Spring学习笔记-三/","link":"","permalink":"http://yoursite.com/2020/06/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"Spring学习笔记","text":"Spring学习笔记 AOP什么是AOP？AOP(Aspect Oriented Programming)意为：面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发的一个热点，也是Spring框架的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP在Spring中的作用提供声明式事务；允许用户自定义切面 连接点(Joinpoint)： 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点，也可以理解连接点为：目标类上哪些有可能被增强的方法。 切点（Pointcut）：可以理解为查询条件。一个target（目标类）的所有方法都是连接点，切点可以通过查询条件定位特定的连接点。 增强（Advice）：织入目标类连接点上的一段程序代码。既包含连接点上的执行逻辑（横切逻辑、增强逻辑）又包含定位连接点的方位信息，before、after、around等。增强默认织入目标类的所有方法中。 目标对象（Target）：增强逻辑织入的目标类。 代理（Proxy）：一个类被AOP植入增强后，被产生一个结果代理类。 织入(Weaving)：将通知（增强）应用到连接点上，生成代理的过程。 切面（Aspect)：由切点和增强组成。 引介（Introduction):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice： 前置增强 BeforeAdvice 代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。后置增强 AfterAdvice 代表后增强，表示目标方法在执行后实施增强环绕增强 MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强异常抛出增强 ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强引介增强 IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性 及AOP在不改变原来代码的情况下，去增加新的功能。 使用Spring实现AOP使用AOP，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt; 方式一：使用Spring的API接口 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 注册bean--&gt; &lt;bean id=\"userService\" class=\"com.demo.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.demo.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.demo.log.AfterLog\"/&gt; &lt;!-- 配置aop--&gt; &lt;aop:config&gt; &lt;!-- 切入点 expression:表达式，execution（要执行的位置）--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/&gt; &lt;!-- 执行软绕增强--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567891011121314/** * @author zhang * @date 2020/6/6 16:15 */public class Log implements MethodBeforeAdvice &#123; //method:要执行的目标对象的方法 //args:参数 //o:目标对象 public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(o.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); &#125;&#125; 测试方法 123456789101112/** * @author zhang * @date 2020/6/6 16:36 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //动态代理的式接口 UserService userService = (UserService) context.getBean(\"userService\"); userService.delete(); &#125;&#125; 方式二：自定义来实现AOP【主要是切面定义】 DiyPointCut.java 12345678910111213/** * @author zhang * @date 2020/6/6 17:48 */public class DiyPointCut &#123; public void before()&#123; System.out.println(\"==========方法执行前\"); &#125; public void after()&#123; System.out.println(\"==========方法执行后\"); &#125;&#125; xml 12345678910&lt;bean id=\"diy\" class=\"com.demo.diy.DiyPointCut\"/&gt; &lt;aop:config&gt; &lt;!-- 自定义切面 ref引用类--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方式三：使用注解实现 12345678910111213141516/** * @author zhang * @date 2020/6/6 18:04 */@Aspect//标注这个类是一个切面public class AnnotationPointCut &#123; @Before(\"execution(* com.demo.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"----------方法执行前\"); &#125; @After(\"execution(* com.demo.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"---------方法执行后\"); &#125;&#125; 需要开启注解支持 12&lt;!--开启注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt;","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(二)","slug":"Spring学习笔记-二","date":"2020-06-03T12:01:23.000Z","updated":"2020-06-06T10:39:17.475Z","comments":true,"path":"2020/06/03/Spring学习笔记-二/","link":"","permalink":"http://yoursite.com/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/","excerpt":"Spring学习笔记","text":"Spring学习笔记 Spring配置别名12&lt;!-- 别名，如果添加了别名，我们也可以使用别名获取到对象--&gt;&lt;alias name=\"user\" alias=\"USER\"/&gt; Bean的配置12345678&lt;!-- id：Bean的唯一标识符，也就是相当于我们的对象名 class:对象对应的全限定名 name：也是别名 --&gt; &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt; &lt;property name=\"name\" value=\"Java\"/&gt; &lt;/bean&gt; import这个import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。 DI依赖注入构造器注入Set方式注入【重点】实体类属性 12345678private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private Properties info; private String wife; xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=\"student\" class=\"com.demospring.pojo.Student\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;property name=\"address\" ref=\"address\"&gt;&lt;/property&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;打篮球&lt;/value&gt; &lt;value&gt;敲代码&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"身份证\" value=\"123456789\"/&gt; &lt;entry key=\"银行卡\" value=\"987654321\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;CS&lt;/value&gt; &lt;value&gt;PUBG&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;2019052531&lt;/prop&gt; &lt;prop key=\"性别\"&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 拓展方式注入P命名空间注入需要添加xml约束 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 12&lt;!-- p命名空间注入，可以直接注入属性的值:property--&gt;&lt;bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\"/&gt; C命名空间注入需要添加xml约束 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 12&lt;!-- c命名空间注入，通过构造器注入：construct-args--&gt;&lt;bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\"/&gt; Bean的作用域 Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 1.单例模式(Spring默认机制) 1&lt;bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\" scope=\"singleton\"/&gt; 2.原型模式：每次从容器get的时候，都会产生一个新对象！ 1&lt;bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\" scope=\"prototype\"/&gt; 3.其余的request，session，application这些只能在web开发中用到 Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显式的配置 在java中显式的配置 隐式的自动装配bean【重要】 ByName自动装配123&lt;bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;/bean&gt; autowire=&quot;byName&quot; ByName：会自动在容器上下文中查找，和自己对象set方法后面的值对象的beanid！ Bytype自动装配123&lt;bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt;&lt;/bean&gt; autowire=&quot;byType&quot; ByType：会自动在容器上下文中查找，和自己对象属性类型相同的bean 小结： byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！ bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一样 使用注解实现自动装配1.导入约束：context约束 2.配置注解的支持：context:annotation-config/ 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！也可以在set方法上使用 12345@Autowired private Dog dog; @Autowired private Cat cat; private String name; 使用Autowird我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC容器存在 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value=”xxxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！ 使用注解开发在Spring4之后，需要使用注解开发，必须要保证aop的包导入了 使用注解需要导入context约束，增加注解的支持 12&lt;!-- 指定要扫描的包，这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=\"com.demospring\"/&gt; @Component:组件，放在类上，说明这个类被Spring管理了，就是Bean！ 注入属性 123456789101112/** * @author zhang * @date 2020/6/4 16:00 *///等价于 &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt;&lt;/bean&gt;@Componentpublic class User &#123; //相当于&lt;property name=\"name\" value=\"张三\"/&gt; @Value(\"张三\") public String name ;&#125; 衍生的注解 @Component有几个衍生注解，我们在web开发中，会按照MVC三成架构分层 dao【@Repository】 service【@Service】 controller【@Controller】 这四个注解的功能都是一样的，都是代表将某个类注册到Spring容器中装配 作用域 1@Scope(\"prototype\") 使用Java的方式配置Spring12345678910111213141516171819202122package com.demospring.config;import com.demospring.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author zhang * @date 2020/6/4 17:42 *///这个也会被Spring容器托管，注册到容器中，因为它本来就是一个@Component//@Configuration代表这是一个配置类，就和我们之前看的bean.xml@Configurationpublic class MyConfig &#123; //注册一个Bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bena标签的class属性 @Bean public User getUser()&#123; return new User();//就是返回要注入到bean的对象！ &#125;&#125;","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(一)","slug":"Spring学习笔记-一","date":"2020-06-03T11:57:29.000Z","updated":"2020-06-03T12:00:30.325Z","comments":true,"path":"2020/06/03/Spring学习笔记-一/","link":"","permalink":"http://yoursite.com/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"Spring学习笔记","text":"Spring学习笔记 简介 简介：Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从 Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合现有的技术框架！ SSM：SpringMvc + Spring + Mybatis！ 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 优点： Spring是一个开源的免费的框架(容器)！ Spring一个轻量级的、非入侵式的框架 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理,对框架整合的支持 总结：Spring就是一个轻量级的控制反转(IOC)和切面编程的框架！ 组成 核心容器（Spring Core） 核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。 应用上下文（Spring Context） Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring面向切面编程（Spring AOP） 通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 JDBC和DAO模块（Spring DAO） JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。 对象实体映射（Spring ORM） Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。 Web模块（Spring Web） Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 MVC模块（Spring Web MVC） MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。 IOC理论控制反转Ioc(Inversion of Control)，是一种设计思想，DI(依赖注入)式实现IoC的一种方法，也有人认为Di只是Ioc的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象创建转移给第三方，个人认为所谓的控制反转就是：获得依赖对象的方式反转了 采用XML配置Bean的时候，Bean的定义信息是和实现分离的，而采用注入的方式可以把二者和为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到零配置的目的 控制反转是一种通过描述(XML或注解)并通过第三方去生产或者获取特定对象的方式。在Spring中实现控制反转的是Ioc容器，其实现方法是依赖注入(Dependency Injection,DI) 由容器动态地将某种依赖关系注入到组件之间。控制反转也称为”依赖注入“（Dependency Injection DI) IoC/DI示例：依赖注入是Java编程思想中”面向接口编程“的体现，因此在设计程序是，对于程序所依赖的组件往往以忌口的形式出现，而不直接使用具体的实现类 第一个Spring程序 besns.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt; &lt;property name=\"name\" value=\"Java\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码 123456789101112131415import com.demospring.pojo.User;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author zhang * @date 2020/6/2 17:05 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); user.show(); &#125;&#125; 实体类 12345678910111213141516171819202122232425262728package com.demospring.pojo;/** * @author zhang * @date 2020/6/2 17:03 */public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"name---&gt;\"+name); &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 总结：在配置文件加载的时候，容器中的管理对象就已经初始化了！","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2020-05-31T08:08:51.000Z","updated":"2020-05-31T08:20:14.776Z","comments":true,"path":"2020/05/31/Java多线程/","link":"","permalink":"http://yoursite.com/2020/05/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"Java多线程笔记","text":"Java多线程笔记 多线程 说起进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念 而进程则是执行程序的一次执行过程，它是一个动态概念。是系统资源分配的单位 通常一个进程可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。 本章核心概念 线程就是独立的执行路径 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程mian，gc线程 main()称为主线程，为系统入口，用于执行整个程序 在一个线程中，如果开辟了多个线程，线程的运行有调度器安排调度，调度器是与操作系统机密相关的，先后顺序是不能认为的干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制 线程会带来额外的开销，如cpu调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 线程创建三种创建方式： 继承Thread类(重点) 实现Runnable接口(重点) 实现Callable(了解) Thread类1.自定义线程类继承Thread类 2.重写run()方法，编写线程执行体 3.创建线程对象，调用start()方法启动线程 1234567891011121314151617181920212223package thread;public class TestThread extends Thread&#123; @Override public void run() &#123; super.run(); for (int i=0;i&lt;20;i++)&#123; System.out.println(\"run方法\"+i); &#125; &#125; public static void main(String[] args) &#123; //main线程，主线程 //创建一个线程对象，调用start方法开启线程 TestThread testThread = new TestThread(); testThread.start(); for (int i = 0; i &lt; 200; i++) &#123; System.out.println(\"主线程\"+i); &#125; &#125;&#125; 多线程实现网图下载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package thread;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;//联系Thread，实现多线程同步下载public class TestThread2 extends Thread&#123; private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name)&#123; this.url = url; this.name = name; &#125; //下载图片的线程执行体 @Override public void run() &#123; WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载了文件名为：\"+name); &#125; public static void main(String[] args) &#123; TestThread2 testThread1 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%911.png\",\"D:/a_test/1.jpg\"); TestThread2 testThread2 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%912.png\",\"D:/a_test/2.jpg\"); TestThread2 testThread3 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%913.png\",\"D:/a_test/3.jpg\"); testThread1.start(); testThread2.start(); testThread3.start(); &#125;&#125;//下载器class WebDownloader&#123; //下载方法 public void downloader(String url,String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url),new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Runnable接口1.实现MyRunnable类实现Runnable接口 2.实现run()方法，编写线程执行体 3.创建线程对象，调用start()方法启动线程 123456789101112131415161718192021222324package thread;public class TestThread3 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"run方法\"+i); &#125; &#125; public static void main(String[] args) &#123; //创建runnable接口的实现类 TestThread3 testThread3 = new TestThread3(); //创建线程对象，通过线程对象开启线程，代理 Thread thread = new Thread(testThread3); thread.start(); //new Thread(new TestThread3()).start(); for (int i = 0; i &lt; 200; i++) &#123; System.out.println(\"主线程\"+i); &#125; &#125;&#125; 小结 继承Thread类 子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 实现Runnable接口 实现Runnable具有多线程能力 线程启动：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 初识并发问题123456789101112131415161718192021222324252627282930313233package thread;/** * 多个线程操作一个对象 * 买火车票 */public class TestThread4 implements Runnable&#123; //票数 private int ticketNums = 10; @Override public void run() &#123; while (true)&#123; if (ticketNums&lt;=0)&#123; break; &#125; //模拟延迟 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"----&gt;拿到了第\"+ticketNums--+\"张票\"); &#125; &#125; public static void main(String[] args) &#123; TestThread4 t4 = new TestThread4(); new Thread(t4,\"小明\").start(); new Thread(t4,\"老师\").start(); new Thread(t4,\"黄牛\").start(); &#125;&#125; 发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 线程状态 Thread.State NEW ​ 尚未启动的线程处于此状态 RUNNABLE ​ 在Java虚拟机中执行的线程处于此状态 BLOCKED ​ 阻塞等待监视器锁定的线程处于此状态 WAITTING ​ 正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WATTING ​ 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED ​ 已退出的线程处于此状态 线程优先级Java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级来决定应该调度哪个线程先执行 线程的优先级用数字表示,范围1~10 Thread.MIN_PRIORITY = 1; Thread.MAX_PRIORITY = 10; Thread.NORM_PRIORITY = 5; 使用以下方式改变和获取优先级 getPriority() setPriority(int xxx) 注意：优先级低只是意味这获得调度的概率低，并不是优先级低就不会被调用了，这都看cpu的调度 线程方法 方法 说明 setPriority(int newPriority) 更改线程的优先级 static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠 void join() 等待该线程终止 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 void interrupt() 中断线程，别用这个方式 boolean isAlive() 测试线程是否处于活动状态 停止线程 不推荐使用JDK提供的stop()、destory()方法。【已废弃】 推荐线程自己停下来 建议用一个标志位进行终止变量，放flag = false，则终止线程运行 12345678910111213141516171819202122232425262728293031323334353637383940package thread;/** * 测试stop * 建议线程正常停止--&gt;利用次数，不建议死循环 * 建议使用标志位--&gt;设置一个标志位 * 不用使用stop或者destory等过时或者JDK不建议使用的方法 */public class TestThread5 implements Runnable&#123; //设置一个标志位 private boolean flag = true; @Override public void run() &#123; int i = 0; while (flag)&#123; System.out.println(\"run....Thread\"+i++); &#125; &#125; //设置一个公开的方法停止线程，转换标志位 public void stop()&#123; this.flag = false; &#125; public static void main(String[] args) &#123; TestThread5 thread5 = new TestThread5(); new Thread(thread5).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"main\"+i); if (i == 900)&#123; //调用stop方法切换标志位，让线程停止 thread5.stop(); System.out.println(\"线程该停止了\"); &#125; &#125; &#125;&#125; 线程休眠 sleep(时间)指定当前路线阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 线程礼让 线程礼让，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功！看CPU心情 1234567891011121314151617181920package thread;public class TestYield &#123; public static void main(String[] args) &#123; MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"线程开始执行\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行\"); &#125;&#125; join Join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞 可以想象成插队 守护线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕，如后台记录操作日志，监控内存，垃圾回收等等。 线程同步(重点)并发：多个线程操作同一个资源 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程池使用完毕，下一个线程再使用 由于同一进程的多个线程共享同一块存储空间，在带了方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入了锁机制synchronized,当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可，存在一下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题 由于我们可以通private关键字来保证数据对象只能被方法访问，所有我们只需要对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块 同步方法：public synchronized void method(int args){} synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。 缺陷：若将一个大的方法申明为synchronized将会影响效率 同步块synchronized(obj){ } Obj称为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。 同步监视器的执行过程 1.第一个线程访问，锁定同步监视器，执行其中代码 2.第二个线程访问，发现同步监视器被锁定，无法访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问 死锁多个线程各自占有一些资源，并且相互等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情况。某一个同步块同时拥有“两个以上对象的锁”时就可能会发生“死锁问题”。 死锁避免的方法产生死锁的四个必要条件 1.互斥条件：一个资源每次只能被一个进程使用 2.请求与保持条件：一个进程因请求资源时而被阻塞，对己获得的资源保持不放 3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 4.循环等待条件：若干进程之间实现了一种头尾相接的循环等待资源关系 上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或者多个条件就可以避免死锁发生 Lock(锁) 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口时控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比价常用的是ReentrantLock，可以显式加锁，释放锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package thread;import java.util.concurrent.locks.ReentrantLock;/** * @author zhang * @date 2020/5/31 10:24 */public class TestLock &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,\"小明\").start(); new Thread(buyTicket,\"小红\").start(); new Thread(buyTicket,\"黄牛\").start(); &#125;&#125;class BuyTicket implements Runnable&#123; int ticketNum = 10; //定义Lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try &#123; lock.lock();//加锁 if (ticketNum&gt;0)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"买到了\"+ticketNum--); &#125;else &#123; break; &#125; &#125;finally &#123; //解锁 lock.unlock(); &#125; &#125; &#125;&#125; synchronized与Lock的对比 Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了作用域会自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类) 优先使用顺序 Lock&gt;同步代码块(已经进入了方法体，分配相应资源)&gt;同步方法(在方法体之外) 线程通信Java提供了几个方法解决线程之间的通信问题 方法名 作用 wait() 表示线程一直等待，知道线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个正处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常lllegalMonitorStateException 线程池背景：经常创建和销毁使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁的创建和销毁、实现重复利用。类似生活中的交通工具 好处： 提高相应速度(减少了创建新线程的时间) 降低资源消耗(重复利用线程池中的线程，不需要每次创建) 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后终止 使用线程池JDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExector void execute(Runnnable command):执行任务/命令，没有返回值，一般用于执行Runnable Future submit(Callable task):执行任务，有返回值，一般用于执行Callable void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 123456789101112131415161718192021222324252627282930313233package thread;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author zhang * @date 2020/5/31 14:58 * 测试线程池 */public class TestPool &#123; public static void main(String[] args) &#123; //创建线程池 ExecutorService service = Executors.newFixedThreadPool(10); //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //关闭连接 service.shutdown(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"mybatis框架(四)","slug":"mybatis框架-四","date":"2020-05-27T07:10:29.000Z","updated":"2020-05-31T08:32:57.008Z","comments":true,"path":"2020/05/27/mybatis框架-四/","link":"","permalink":"http://yoursite.com/2020/05/27/mybatis%E6%A1%86%E6%9E%B6-%E5%9B%9B/","excerpt":"mybatis笔记(四)","text":"mybatis笔记(四) 动态SQL什么是动态SQL：根据不同的条件生成不同的SQL 所谓的动态SQl，本质还是SQL语句，只是我么可以在SQl层面，去执行一个逻辑代码 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach ifBlogMapper.xml代码 123456789&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog where 1 = 1 &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/select&gt; choose、when、otherwise有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。 12345678910111213141516&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title!=null\"&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author!=null\"&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 只会选择其中一个条件实现，前面的实现后面的就不看了 trim、where、setwhere 如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样： 12SELECT * FROM BLOGWHERE 这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样: 123SELECT * FROM BLOGWHEREAND title like ‘someTitle’ 这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。 MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动： where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 set 用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。 set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 123456789101112&lt;update id=\"updateBlogSet\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"titlt != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; SQL片段有的时候，我们可能将一些功能的部分抽取出来，方便复用 1.使用sql标签抽取公共部分 2.在需要使用的的地方使用include标签引用即可 注意事项： 1.最好基于单表来定义SQL！ 2.不要存在where foreachforeach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ 提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 123456789&lt;select id=\"queryForeach\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;foreach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 缓存简介1.什么是缓存？ 存在内存的临时数据 将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 2.为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 3.什么样的数据能使用缓存 经常查询并且不经常改变的数据 MyBatis缓存 MyBatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率 MyBatis系统中定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称本地缓存) 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中哪，没必要在去查询数据库 缓存失效的情况： 1.查询不同的东西 2.增删改操作，可能会改变原来的数据，所有必定会刷新缓存！ 3.查询不同Mapper.xml 4.手动清理缓存 小结 一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个去加段！ 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名门空间对应一个二级缓存 工作机制： 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据会放在自己对应的缓存中 步骤： 1.开启全局缓存 12&lt;!-- 开启全局缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 2.在要使用二级缓存的Mapper中开启","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mybatis框架(三)","slug":"mybatis框架-三","date":"2020-05-24T11:41:01.000Z","updated":"2020-05-27T00:25:40.396Z","comments":true,"path":"2020/05/24/mybatis框架-三/","link":"","permalink":"http://yoursite.com/2020/05/24/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%89/","excerpt":"mybatis笔记(三)","text":"mybatis笔记(三) 注解开发1.注解在接口上使用 12@Select(\"select * from student\") List&lt;Student&gt; getStudents(); 2.需要在核心配置文件中绑定接口 12345&lt;mappers&gt;&lt;!-- &lt;mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/&gt;--&gt;&lt;!-- &lt;mapper class=\"cn.demomybatis.dao.StudentDao\"/&gt;--&gt; &lt;package name=\"cn.demomybatis.dao\"/&gt; &lt;/mappers&gt; 本质：反射机制实现 底层：动态代理！ MyBatis详细执行流程 CRUD我们可以在创建工具类的时候实现自动提交事务！ 123public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 编写接口，增加注释 12345678910//方法存在多个参数，所有参数前面必须加上@Param注解 @Select(\"select * from student where id = #&#123;id&#125;\") Student getStudentById1(@Param(\"id\") int id); @Insert(\"insert into student(id,name,age,phone) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;phone&#125;)\") int addStudent1(Student student); @Update(\"update student set name=#&#123;name&#125;,age=#&#123;age&#125;,phone=#&#123;phone&#125; where id = #&#123;id&#125;\") int updateStudent1(Student student); 关于@Param注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名！ Lombok使用步骤： 1.在IDEA中安装Lombok插件 2.在项目导入Lombok的jar包 3. 123@Data：生成无参构造，get，set，toString，hashcode，equals@AllArgsConstructor 有参构造方法@NoArgsConstructor 无参构造方法 多对一处理按照插叙嵌套处理1234567891011121314151617181920&lt;!-- 思路： 1.查询所有的学生信息 2.根据查询出来的tid，寻找对应的老师！ 子查询--&gt; &lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student &lt;/select&gt; &lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt; 按照结果嵌套处理12345678910&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id; &lt;/select&gt; &lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多处理同理 小结1.关联 - association 【多对一】 2.集合 - collection 【一对多】 3.javaTape：用来指定实体类中属性的类型 4.ofType：用来指定映射到List或者集合中的实体类类型，泛型中的约束类型","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"mybatis框架(二)","slug":"mybatis框架-二","date":"2020-05-22T11:08:13.000Z","updated":"2020-05-23T10:34:51.915Z","comments":true,"path":"2020/05/22/mybatis框架-二/","link":"","permalink":"http://yoursite.com/2020/05/22/mybatis%E6%A1%86%E6%9E%B6-%E4%BA%8C/","excerpt":"mybatis笔记(二)","text":"mybatis笔记(二) 配置解析核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 环境配置MyBatis可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例智能选择一种环境。 Mybatis默认的事务管理器就是JDBC，连接池POOLED 属性(properties)我们可以通过properties属性实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 编写一个配置文件:db.properties 1234driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?serverTimezone=UTCusername=rootpassword=root 在核心配置文件中引入 12&lt;!-- 引入外部配置文件--&gt; &lt;properties resource=\"db.properties\"/&gt; 类型别名类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。 1234&lt;!-- 可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"cn.demomybatis.domain.Student\" alias=\"Student\"/&gt; &lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，他的默认别名就为这个类的类名首字母小写 设置 设置名 描述 有效值 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true|False false 映射器MapperRegistry:注册绑定我们的Mapper文件 方式一： 1234&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/&gt;&lt;/mappers&gt; 方式二： 1234&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=\"cn.demomybatis.dao.StudentDao\"/&gt;&lt;/mappers&gt; 方式三： 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"cn.demomybatis.dao\"/&gt;&lt;/mappers&gt; 生命周期和作用域生命周期和作用域是只管重要的，因为错误的使用会导致非常严重的并发问题 解决属性名和字段名不一致问题resultMap结果集映射 12345&lt;!-- 结果集映射--&gt; &lt;resultMap id=\"StudentMap\" type=\"Student\"&gt; &lt;!-- column是数据库中的字段，property是实体类中的字段--&gt; &lt;result column=\"u_id\" property=\"id\"&gt;&lt;/result&gt; &lt;/resultMap&gt; resultMap元素是MyBatis中最重要最强大的元素 ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，对于复杂一点的语句只需要猫叔他们的关系就行了 ResultMap最优秀的地方在于，虽然你已经对他相当了解了，但根本不需要显式的用到他们。 日志日志工厂如果一个数据库操作出现了异常，我们需要排错。日志就是最好的帮手！ 设置名 描述 有效值 默认值 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J，LOG4J，LOG4J2，JDK_LOGGING，COMMONS_LOGGING，STDOUT_LOGGING，NO_LOGGING 未设置 1234&lt;settings&gt; &lt;!-- 标准的日志实现--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; LOG4J什么式log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 1.先导入LOG4J的jar包 2.log4j.properties配置文件 12345678910111213141516171819202122232425262728293031############################################### Log4J 配置文件############################################### 定义缺省的日志级别和输出对象log4j.rootLogger=DEBUG,INFO, logfile,console# 设定控制台输出模式log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%d&#123;MM/dd HH:mm:ss&#125;] [%-3p] %c&#123;1&#125;: %m%n# 针对package定义日志级别log4j.logger.org.apache=WARNlog4j.logger.com.paic.pafademo=DEBUG# 设定日志文件的输出模式log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.logfile.DatePattern=yyyyMMdd# $&#123;pafa.log.home&#125;通过参数-D指定，比如启动WebLogic时加入参数-Dpafa.log.home=c:/log4j.appender.logfile.File=$&#123;log.home&#125;/appdemo/pafa.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d&#123;MM/dd HH:mm:ss&#125; [%-3p] %c&#123;1&#125;: %m%n# 如果要查看iBATIS的SQL日志信息，确保有下面配置log4j.logger.com.ibatis=DEBUGlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 3.配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; 简单使用1.在要使用的Log4j的类中，导入import org.apache.log4j.Logger; 2.日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(mybatistest.class); 分页使用limit分类使用MyBatis实现分页，核心SQL 1.接口 12//分页 List&lt;Student&gt; getStudentByLimit(Map&lt;String,Integer&gt; map); 2.StudentDao.xml 123&lt;select id=\"getStudentByLimit\" resultType=\"Student\" parameterType=\"map\"&gt; select * from student limit #&#123;startIndex&#125;,#&#123;pageSize&#125; &lt;/select&gt; 3.测试 12345678910111213@Test public void getStudentByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); StudentDao studentDao = sqlSession.getMapper(StudentDao.class); Map&lt;String,Integer&gt; map = new HashMap(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List&lt;Student&gt; studentList = studentDao.getStudentByLimit(map); for (Student student : studentList) &#123; System.out.println(student); &#125; sqlSession.close(); &#125; RowBounds分页","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"ngork内网穿透","slug":"ngork内网穿透","date":"2020-05-22T01:11:58.000Z","updated":"2020-05-22T01:30:42.390Z","comments":true,"path":"2020/05/22/ngork内网穿透/","link":"","permalink":"http://yoursite.com/2020/05/22/ngork%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"将本地的项目运行在公网上","text":"将本地的项目运行在公网上 1.进入ngrok官网（http://www.ngrok.cc/），注册ngrok账号2.登录–&gt;隧道管理–&gt;开通隧道找到免费的 隧道名称和前置域名随便填就行了 端口填自己tomcat的端口 点击客户端下载 下载完成之后点击启动工具 输入隧道id 显示这个就已经成功了 可以通过上边哪个域名访问自己本地的项目了","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"PicGo+GitHub图床，让Markdown飞","slug":"PicGo-GitHub图床，让Markdown飞","date":"2020-05-21T11:19:47.000Z","updated":"2020-05-23T10:56:51.923Z","comments":true,"path":"2020/05/21/PicGo-GitHub图床，让Markdown飞/","link":"","permalink":"http://yoursite.com/2020/05/21/PicGo-GitHub%E5%9B%BE%E5%BA%8A%EF%BC%8C%E8%AE%A9Markdown%E9%A3%9E/","excerpt":"PicGo+GitHub图床","text":"PicGo+GitHub图床 一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种“轻量级标记语言”。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：Typora和马克飞象。 目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都近乎完美但是却又不能达到完美。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是将截图存放在本机电脑上，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。 这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：PicGo+GitHub图床 注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户） PicGo介绍这是一款图片上传的工具，目前支持微博图床，七牛图床，腾讯云，又拍云，GitHub等图床，未来将支持更多图床。 所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。 Pic Go支持的图床 在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。 创建自己的GitHub图床1. 创建GitHub图床之前，需要注册/登陆GitHub账号 申请GitHub账号很简单，我就不演示了 2. 创建Repository 点击”New repository”按钮 我已经建立过一个同名的repository的，所以第一步会显示红色 第三步，为repository初始化一个README.md文件可以根据需求选择，非必选 3.生成一个Token用于操作GitHub repository 回到主页，点击”Settings”按钮 进入页面后，点击”Developer settings”按钮 点击”Personal access tokens”按钮 创建新的Token 填写描述，选择”repo”,然后点击”Generate token”按钮 注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存 配置PicGo1. 下载运行PicGo 推荐下载exe可执行文件 2. 配置图床 如图配置 设定仓库名的时候，是按照“账户名/仓库名的格式填写” 分支名统一填写“master” 将之前的Token黏贴在这里 存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹 自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/用户名/RepositoryName/分支名，，自定义域名需要按照这样去填写 总结将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下ctrl+shift+c，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！。 自己在本地用确实没有什么问题，但是提交到博客上发现图片加载失败，或者加载异常慢，于是我发现了一种加速的方法 CDN 简介 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。—— Wikipedia 简而言之就是让服务器距离大陆较远的 GitHub ，将托管在那里的静态资源缓存到一个近一点的服务器，从而加快访问。 看了这样的解释你应该能够理解，CDN 虽然能缓解互联压力，可也是要耗费一定的资源的，从而市面上的 CDN 大多是收费的。Cloudflare 虽然有免费 CDN ，可是国内节点致开放给专业版用户使用，价格偏高，而海外的节点又类似负优化，可能还会降低速度。 jsDelivrjsDelivr是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。 有搜索引擎，支持一键复制文件 URL 和标签，支持分发 NPM、GitHub、WordPress SVN 的文件 基础使用可能看起来，官方的使用方法十分复杂，但其实就一句话：把仓库链接的域名替换成 jsDelivr 的域名。 如托管在 GitHub 的仓库链接都是 https://github.com/username/repo/branch/file 的形式，而我们就可以将前面的 github.com 改成 jsDelivr 提供加速 GitHub 仓库的域名 cdn.jsdelivr.net/gh 。 嗯，兴冲冲配置一发，发现什么都没有？其实还是有一点点小差别的。比如分支那里，jsDelivr 默认要直接在仓库名后面 @ ，所以真正其实是 https://cdn.jsdelivr.net/gh/username/repo@branch/file 的形式。当然，如果你放在仓库的默认分支，还可以直接将 branch 这个关键字直接删了，变成 https://cdn.jsdelivr.net/gh/username/repo/file 一样能获取到！ 另外，如果是一些比较稳定的文件，后面不会频繁地改动，还可以发布成一个版本，然后在 repo 后 @version 就可以引用对应的版本。 加速图床如果你还记得笔者之前写的 PicGo + GitHub 搭建免费图床 的话，不难发现 jsDelivr 也是能加速这个图床（本质不还是一个 GitHub 仓库嘛）的。我们只需要在 GitHub 图床设置 中将链接设置为 https://cdn.jsdelivr.net/gh/username/repo 即可！前提是你上传到默认分支。","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"mybatis框架(一)","slug":"mybatis框架-一","date":"2020-05-19T11:04:42.000Z","updated":"2020-05-22T11:12:13.440Z","comments":true,"path":"2020/05/19/mybatis框架-一/","link":"","permalink":"http://yoursite.com/2020/05/19/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%80/","excerpt":"mybatis笔记(一)","text":"mybatis笔记(一) mybatis概述mybatis是一个持久层框架，用java编写，封装了很多jdbc细节，开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程，它使用了ORM思想，实现了结果集的封装。 ORM：Object Relational Mappging 对象关系映射简单的说：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类及实现操作数据库 mybatis环境搭建 1.创建maven工程并导入坐标12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.18&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2.创建实体类和dao接口 3.创建mybatis的主配置文件SqlMapConfig.xml 4.创建映射配置文件注意事项 1.包在创建时 com.demomybatis.dao他是三级目录结构 2.mybatis的映射配置文件位置必须和dao接口的包结构相同 3.映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定而类名 4.映射配置文件的擦偶哦配置(select) id的取值必须是dao接口的方法名 当我们遵从2，3，4点之后，我们开发中就无需再写dao的实现类 SqlMapConfig.xml代码1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default&#x3D;&quot;mysql&quot;&gt; &lt;environment id&#x3D;&quot;mysql&quot;&gt; &lt;!--使用jdbc事务管理 --&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;!-- 数据库连接池(数据源) --&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!-- 引入映射配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;cn&#x2F;demomybatis&#x2F;dao&#x2F;StudentDao.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; StudentDao.xml代码123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace：命名空间，用于隔离sql--&gt;&lt;mapper namespace&#x3D;&quot;cn.demomybatis.dao.StudentDao&quot;&gt; &lt;!-- 配置查询所有 id为dao的方法名--&gt; &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;cn.demomybatis.domain.Student&quot; parameterType&#x3D;&quot;cn.demomybatis.domain.Student&quot;&gt; select * from student &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; mybatis入门案例： 1.读取配置文件 2.创建SqlSessionFactory工厂 3.创建SqlSession 4.创建Dao接口的代理 5.执行Dao中的方法 6.释放资源 注意：需要在映射配置中告知mybatis要封装到哪个实体类中，配置的方式：指定实体类的全类名 增删改需要提交事务 sqlSession.commit() 测试代码1234567891011121314151617181920212223242526272829303132333435363738package cn.demomybatis.test;import cn.demomybatis.dao.StudentDao;import cn.demomybatis.domain.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;&#x2F;** * mybatis入门 *&#x2F;public class mybatistest &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;读取配置文件 InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); &#x2F;&#x2F;创建工厂 SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder(); SqlSessionFactory factory &#x3D; builder.build(in); &#x2F;&#x2F;使用工厂生产SqlSession对象 SqlSession sqlSession &#x3D; factory.openSession(); &#x2F;&#x2F;创建Dao接口的代理对象 StudentDao studentDao &#x3D; sqlSession.getMapper(StudentDao.class); &#x2F;&#x2F;使用代理对象执行方法 List&lt;Student&gt; list &#x3D; studentDao.findAll(); for (Student student:list)&#123; System.out.println(student); &#125; &#x2F;&#x2F;释放资源 sqlSession.close(); in.close(); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"抽取Servlet","slug":"抽取Servlet","date":"2020-05-13T09:15:56.000Z","updated":"2020-05-17T07:41:58.636Z","comments":true,"path":"2020/05/13/抽取Servlet/","link":"","permalink":"http://yoursite.com/2020/05/13/%E6%8A%BD%E5%8F%96Servlet/","excerpt":"BaseServlet代码","text":"BaseServlet代码 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.travel.web.servlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;完成方法的分发 &#x2F;&#x2F;获取请求路径 String uri &#x3D; req.getRequestURI(); System.out.println(&quot;请求uri:&quot;+uri); &#x2F;&#x2F;获取方法对象 String methodName &#x3D; uri.substring(uri.lastIndexOf(&quot;&#x2F;&quot;)+1); System.out.println(&quot;方法名称：&quot;+methodName); &#x2F;&#x2F;获取方法对象Method try &#123; Method method &#x3D; this.getClass().getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class); &#x2F;&#x2F;暴力反射 &#x2F;&#x2F;method.setAccessible(true); &#x2F;&#x2F;执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; UserServlet代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198package cn.travel.web.servlet;import cn.travel.damain.ResultInfo;import cn.travel.damain.User;import cn.travel.service.UserService;import cn.travel.service.impl.UserServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;&#x2F;user&#x2F;*&quot;)public class UserServlet extends BaseServlet &#123; &#x2F;** * 注册功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void regist(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;验证码校验 String checkcode &#x3D; request.getParameter(&quot;checkcode&quot;); String checkcode_session &#x3D; (String) request.getSession().getAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;防止验证码复用 保证验证码只能使用一次 request.getSession().removeAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;比较 if (checkcode_session &#x3D;&#x3D; null || !checkcode_session.equalsIgnoreCase(checkcode)) &#123; ResultInfo info &#x3D; new ResultInfo(); info.setFlag(false); info.setErrorMsg(&quot;验证码错误&quot;); &#x2F;&#x2F;将info对象序列化为json ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(info); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); return; &#125; &#x2F;&#x2F;获取数据 String username &#x3D; request.getParameter(&quot;username&quot;); String password &#x3D; request.getParameter(&quot;password&quot;); String name &#x3D; request.getParameter(&quot;name&quot;); String birthday &#x3D; request.getParameter(&quot;birthday&quot;); String email &#x3D; request.getParameter(&quot;email&quot;); &#x2F;&#x2F;封装对象 User user &#x3D; new User(); user.setUsername(username); user.setPassword(password); user.setName(name); user.setBirthday(birthday); user.setEmail(email); &#x2F;&#x2F;调用service完成注册 UserService service &#x3D; new UserServiceImpl(); boolean flag &#x3D; service.regist(user); &#x2F;&#x2F;响应结果 ResultInfo resultInfo &#x3D; new ResultInfo(); if (flag) &#123; &#x2F;&#x2F;注册成功 resultInfo.setFlag(true); &#125; else &#123; &#x2F;&#x2F;注册失败 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;注册失败！&quot;); &#125; &#x2F;&#x2F;将resultInfo对象序列化为JSON，并写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); &#x2F;&#x2F;将json数据写回客户端 &#x2F;&#x2F;设置content-type response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 登录功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取用户名和密码数据 Map&lt;String, String[]&gt; map &#x3D; request.getParameterMap(); &#x2F;&#x2F;分装user对象 User user &#x3D; new User(); try &#123; BeanUtils.populate(user, map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;调用service查询 UserService service &#x3D; new UserServiceImpl(); User u &#x3D; service.login(user); &#x2F;&#x2F;判断 ResultInfo resultInfo &#x3D; new ResultInfo(); if (u &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;用户名密码错误 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;用户名或密码错误!&quot;); &#125; &#x2F;&#x2F;判断用户是否激活 if (u !&#x3D; null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;用户尚未激活 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;您尚未激活，请前往邮箱激活!&quot;); &#125; &#x2F;&#x2F;登录成功的判断 if (u !&#x3D; null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;登录成功 resultInfo.setFlag(true); &#125; request.getSession().setAttribute(&quot;user&quot;, u); &#x2F;&#x2F;响应数据 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 查找单个对象 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); &#x2F;&#x2F;将user写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); mapper.writeValue(response.getOutputStream(), user); &#125; &#x2F;** * 退出 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void exit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;销毁session request.getSession().invalidate(); &#x2F;&#x2F;跳转页面 重定向 response.sendRedirect(request.getContextPath() + &quot;&#x2F;login.html&quot;); &#125; &#x2F;** * 激活 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void active(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取激活码 String code &#x3D; request.getParameter(&quot;code&quot;); if (code !&#x3D; null) &#123; &#x2F;&#x2F;调用service完成激活 UserService service &#x3D; new UserServiceImpl(); Boolean flag &#x3D; service.active(code); &#x2F;&#x2F;判断标记 String msg &#x3D; null; if (flag) &#123; &#x2F;&#x2F;激活成功 msg &#x3D; &quot;激活成功，请&lt;a href&#x3D;&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;; &#125; else &#123; &#x2F;&#x2F;激活失败 msg &#x3D; &quot;激活失败，联系管理员&quot;; &#125; response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); response.getWriter().write(msg); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"redis数据库","slug":"redis数据库","date":"2020-05-01T04:10:36.000Z","updated":"2020-05-18T07:48:47.217Z","comments":true,"path":"2020/05/01/redis数据库/","link":"","permalink":"http://yoursite.com/2020/05/01/redis%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"Redis","text":"Redis 下载：百度云下载 提取码：o1ui Github下载 概念：一款高性能的NOSQL系列的非关系型数据库命令：redis存储的是：key，value格式的数据，其中key都是字符串，value有5中不同的数据结构 value的数据结构 1.字符串类型 string 2.哈希类型 hash ：相当于map集合 3.列表集合 list ：linkedlist格式 4.集合类型 set 5.有序集合类型 sortedset字符串类型string1.存储 set key value 2.获取 get key 3.删除 del key 哈希类型 hash1.存储 hset key field value 2.获取 hget key field hgetall key 获取所有的键和值 3.删除 hdel key field 列表类型 list1.lpush key value 将元素加入列表左边 2.rpush key value 将元素加入列表右边 3.lrange key start end 获取范围 4.lpop key 删除列表最左边的元素，并将元素返回 5.rpop key 删除列表最右边的元素 集合类型 set1.存储：sadd key value 2.获取：smembers key ：获取集合中所有元素 3.删除：srem key value ：删除集合的某个元素 有序集合类型 sortedset1.存储：zadd key score value 2.获取：zrange key start end 3.删除：zrem key value 通用命令：1.keys * ：查询所有的键 2.type key：获取键对应的value的类型 3.del key：删除指定的key value 持久化存储 1.redis是一个内存数据库，东redis服务器重启后，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘中 2.redis持久化机制 1.RDB：默认方式。 在一定的间隔时间中，检测key的变化情况，然后去持久化数据 2.AOF：日志记录的方式，可以检测每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windows.conf文件 appendonly no 给成yes Java客户端JedisJedis是一款java操作redis数据库的工具Jedis连接池：JedisPool1.创建JedisPool连接池对象 2.调用getResource()方法获取Jedis的连接工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142package cn.jedis.utlis;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;&#x2F;*JedisPool工具类加载配置文件，配置连接池参数提供获取连接的方法 *&#x2F;public class JedisPoolUtils &#123; private static JedisPool jedisPool; static &#123; &#x2F;&#x2F;读取配置文件 InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); &#x2F;&#x2F;创建一个Properties对象 Properties pro &#x3D; new Properties(); &#x2F;&#x2F;关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中 JedisPoolConfig config &#x3D; new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); &#x2F;&#x2F;初始化JedisPool jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; &#x2F;&#x2F;获取连接 public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"AJAX和JSON","slug":"ajax和JSON","date":"2020-04-28T11:12:12.000Z","updated":"2020-05-17T07:39:30.306Z","comments":true,"path":"2020/04/28/ajax和JSON/","link":"","permalink":"http://yoursite.com/2020/04/28/ajax%E5%92%8CJSON/","excerpt":"AJAX","text":"AJAX 概念：ASynchronous JavaScript And XML 异步的javascript和xml实现方式: 1.原生的JS实现方式 2.JQuery实现方式 1.$.ajax()} $.ajax({键值对}); 2.$.get() 3.$.post() JOSN概念：JavaScript Object Notation JavaScript对象表示法基本规则：获取数据:json对象.键名 json对象[“键名”] 数组对象[索引] 遍历JSON123for (var key in person)&#123; alert(key+&quot;:&quot;+person[key])&#125; JSON数据和Java对象的相互转换1.JSON转为Java 1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 12345678String json &#x3D; &quot;&#123;\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:20,\\&quot;gender\\&quot;:\\&quot;男\\&quot;&#125;&quot;;&#x2F;&#x2F;创建ObjectMappperObjectMapper mapper &#x3D; new ObjectMapper();mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);&#x2F;&#x2F;转换为Java的对象Person person &#x3D; mapper.readValue(json,Person.class);System.out.println(person); 2.Java转为JSON1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 123456789101112131415161718192021public void test1() throws Exception &#123; Person p &#x3D; new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGendeer(&quot;男&quot;); &#x2F;&#x2F;创建Jackson的核心对象 ObjectMapper ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;调用方法 转换 String JSON &#x3D; mapper.writeValueAsString(p); System.out.println(JSON); &#x2F;&#x2F;wirterValue 将数据写入到D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt中 &#x2F;&#x2F;mapper.writeValue(new File(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt&quot;),p); &#x2F;&#x2F;writeValue将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;b.txt&quot;),p);&#125; 注解：1.@JsonIgnore:排除属性 2.@JsonFormat:属性值格式化案例校验用户是否存在 html代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;注册&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;JS&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F;页面加载完成后 给文本框绑定离开焦点事件 $(function () &#123; $(&quot;#username&quot;).blur(function () &#123; &#x2F;&#x2F;获取username获取文本输入框的值 var username &#x3D; $(this).val(); &#x2F;&#x2F;发送ajax请求 $.get(&quot;findUserServlet&quot;,&#123;username:username&#125;,function (data) &#123; var span &#x3D; $(&quot;#s_username&quot;) if (data.userExsit)&#123; &#x2F;&#x2F;用户名存在 span.css(&quot;color&quot;,&quot;red&quot;) span.html(data.msg) &#125;else &#123; &#x2F;&#x2F;用户名不存在 span.css(&quot;color&quot;,&quot;green&quot;) span.html(data.msg) &#125; &#125;,&quot;json&quot;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form&gt; &lt;input id&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt; &lt;span id&#x3D;&quot;s_username&quot;&gt;&lt;&#x2F;span&gt;&lt;br&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;注册&quot;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Servlet代码 123456789101112131415161718192021222324252627282930313233343536373839package cn.test.web.servlet;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;&#x2F;findUserServlet&quot;)public class findUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username &#x3D; request.getParameter(&quot;username&quot;); &#x2F;&#x2F;设置响应数据为JSON response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); if (&quot;Tom&quot;.equals(username))&#123; &#x2F;&#x2F;存在 map.put(&quot;userExsit&quot;,true); map.put(&quot;msg&quot;,&quot;用户名已经存在&quot;); &#125;else &#123; &#x2F;&#x2F;不存在 map.put(&quot;userExsit&quot;,false); map.put(&quot;msg&quot;,&quot;用户名可用&quot;); &#125; &#x2F;&#x2F;将map转为json，并且传递给客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); mapper.writeValue(response.getWriter(),map); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JQuery笔记","slug":"JQuery笔记","date":"2020-04-26T08:04:39.000Z","updated":"2020-05-17T07:43:32.163Z","comments":true,"path":"2020/04/26/JQuery笔记/","link":"","permalink":"http://yoursite.com/2020/04/26/JQuery%E7%AC%94%E8%AE%B0/","excerpt":"JQuery笔记","text":"JQuery笔记 概念：一个JavaScript框架，简化JS开发 使用步骤： 1.下载JQuery 2.导入JQuery的js文件 导入min.js 3.使用 JQuery对象和JS对象的区别 方法不互通 转换： jq -&gt; js : jq对象[索引] 或者 jp对象.get(索引) js -&gt; jq : $(js对象)选择器：筛选具有相似特征的元素(标签)1.基本选择器 1.标签选择器(元素选择器) `$(&quot;html标签名&quot;)` 获得所有匹配标签名称的元素 2.id选择器 `$(&quot;#id的属性值&quot;)` 获得与指定id值匹配的元素 3.类选择器 `$(&quot;.class的属性&quot;)` 获得与指定的class属性值相匹配的元素2.层级选择器 1.后代选择器： `$(&quot;A B&quot;)` 选择A元素所有内部的B元素 2.子选择器 `$(&quot;A &gt; B&quot;)` 选择A元素内部的所有B子元素 3.属性选择器 1.属性名称选择器 $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2.属性选择器 $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3.符合属性选择器 $(&quot;A[属性名=&apos;值&apos;][ ]...&quot;) 包含多个属性条件的选择器 4.过滤选择器 1.首元素选择器 :first 获得选择的元素中第一个元素 2.尾元素选择器 :last 获得选择的元素中最后一个元素 3.非元素选择器 not(.selector) 不包括指定内容的元素 4.偶数选择器 even 偶数，从0开始计数 5.奇数选择器 odd 奇数 ，从0开始 6.等于索引选择器 eq(index) 指定索引元素 7.大于索引选择器 gt(index) 大于指定索引选择器 8.小于索引选择器 lt(index) 小于指定索引选择器 9.标题选择器 header 获得标题(h1-h6)元素，固定写法 5.表单过滤选择器 1.可用元素选择器 :enabled 获得可用元素 2.不可以用元素选择器 :disabled 获得不可用元素 3.选中选择器 :checked 获得单选，复选框中的元素 4.选中选择器 :selected 获得下拉框中选中的元素 DOM操作1.内容操作 1.html() ： 获取/设置元素的标签体内容， 内容 –&gt; 内容 2.text() ： 获取/设置元素标签体纯文本内容 内容 –&gt; 内容 3.val() : 获取/设置元素的属性值 2.属性操作 1.通用属性操作 1.attr() 获取/设置元素的属性 2.removeAttr() 删除属性 3.prop() 获取/设置元素的属性 4.removeProp() 删除属性 *attr和prop的区别 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素的自定义属性，则建议是attr 2.对class属性操作 1.addClass() 添加class属性值 2.removeClass() 删除class属性值 3.toggleClass() 切换class属性值 3.CRUD操作 1.append(): 父元素将子元素追加到末尾 - 对象1.append(对象2)：将对象2添加到对象1元素内部，并且在末尾 2.prepend():父元素将子元素追加到开头 -对象1.prepend(对象2)：将对象2添加到对象1元素内部，并且在开头 3.appendto(): 4.prependto(): 5.after():添加元素到元素后边 6.before()：将元素添加到元素前边 7.insertAfter(): 8.insertBrfore(): 9.remove()：删除元素 10.empty()：清空元素的所有后代元素JQuery高级1.动画 1.三种方式显示和隐藏元素 1.show([speed,[easing],[fn]]) 2.hide([speed,[easing],[fn]]) 3.toggle([speed],[easing],[fn]) 2.滑动显示和隐藏方式 1.slideDown([speed],[easing],[fn]) 2.slideUp([speed,[easing],[fn]]) 3.slieToggle([speed],[easing],[fn]) 3.淡入淡出的显示和隐藏方式 1.fadeIn([speed],[easing],[fn]) 2.fadeOut([speed],[easing],[fn]) 3.fadeToggle([speed,[easing],[fn]])2.遍历 1.jq对象.each(callback) 2.$.each(object,[callback]) 3.for..of: 3.事件绑定 1.jquery标准的绑定方式 jq对象.事件方法(回调函数) 2.on绑定事件/off绑定事件 jq对象.on(&quot;事件名称&quot;,回调函数) jq对象.off(&quot;事件名称&quot;) 3.事件切换 jq对象.toggle(fn1,fn2...) 案例需求：1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;*需求： 1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失 分析： 1.使用定时器来完成。setTimeout(执行一次) 2.JQuery的动画效果就是控制display属性 *&#x2F; &#x2F;&#x2F;入口函数，在页面加载完成后定义定时器，调用这两个方法 $(function () &#123; &#x2F;&#x2F;定时器 调用adShow()方法 setTimeout(adShow,3000); setTimeout(adHide,8000); &#125;) &#x2F;&#x2F;显示广告方法 function adShow() &#123; &#x2F;&#x2F;获取广告div 调用show方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; &#x2F;&#x2F;隐藏广告方法 function adHide() &#123; $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt; &lt;div id&#x3D;&quot;ad&quot; style&#x3D;&quot;display: none;&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;广告.jpg&quot;&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;content&quot;&gt; 正文部分 &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 需求：抽奖案例 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;抽奖&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;* 分析： 1.给开始按钮绑定单击事件 1.1定义循环定时器 1.2切换小相框的src属性 定义一个数组，存放图片资源的路径 生成随机数 数组索引 2.给结束按钮绑定单击事件 2.1停止定时器 2.2给大相框设置src属性 *&#x2F; var imgs &#x3D; [&quot;..&#x2F;img&#x2F;1.jpg&quot;,&quot;..&#x2F;img&#x2F;2.jpg&quot;,&quot;..&#x2F;img&#x2F;3.jpg&quot;,&quot;..&#x2F;img&#x2F;4.jpg&quot;,&quot;..&#x2F;img&#x2F;5.jpg&quot;,&quot;..&#x2F;img&#x2F;6.jpg&quot;,&quot;..&#x2F;img&#x2F;0.jpg&quot;] var startId;&#x2F;&#x2F;开始定时器的一个Id var index; $(function () &#123; &#x2F;&#x2F;开始按钮 $(&quot;#startID&quot;).click(function () &#123; startId &#x3D; setInterval(function () &#123; &#x2F;&#x2F;生成随机角标 index &#x3D; Math.floor(Math.random() * 7) &#x2F;&#x2F;设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20) &#125;) &#x2F;&#x2F;结束按钮 $(&quot;#stopID&quot;).click(function () &#123; $(&quot;#stopID&quot;).click(function () &#123; &#x2F;&#x2F;停止定时器 clearInterval(startId) $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--小相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;width: 160px;height: 100px;&quot;&gt; &lt;img id&#x3D;&quot;img1ID&quot; style&#x3D;&quot;width: 160px;height: 100px&quot; src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot;&gt;&lt;&#x2F;div&gt;&lt;!--大相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;height: 500px;position: absolute;left: 500px;top: 10px&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot; id&#x3D;&quot;img2ID&quot; width&#x3D;&quot;800px&quot;height&#x3D;&quot;600px&quot;&gt;&lt;&#x2F;div&gt;&lt;!--开始按钮--&gt;&lt;input id&#x3D;&quot;startID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击开始&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;!--停止按钮--&gt;&lt;input id&#x3D;&quot;stopID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击停止&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Filter过滤器","slug":"Filter过滤器","date":"2020-04-23T06:49:44.000Z","updated":"2020-05-17T07:42:52.842Z","comments":true,"path":"2020/04/23/Filter过滤器/","link":"","permalink":"http://yoursite.com/2020/04/23/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"Filter：过滤器","text":"Filter：过滤器 步骤： 1.定义一个类，实现Filter 2.复写方法 3.配置拦截路径 web.xml的配置12345678&lt;filter&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;cn.filter.demo1&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&#x2F;&#x2F;拦截路径&lt;&#x2F;filter-mapping&gt; 过滤器的生命周期 1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次用于加载资源 2.doFilter:每次拦截资源时被执行，执行很多次。 3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。执行一次，用于释放资源。 拦截路径的配置 1.具体的资源路径:/index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2.目录拦截: /user/* 访问/user下的所有资源时，过滤器都会被执行 3.后缀名拦截： *.jsp 访问所有后缀名为jsp的资源时，过滤器都会被执行 4.拦截所有资源： /* 访问所有资源时，过滤器都会被执行 拦截方式的配置注解配置： 1.REQUEST:默认值 浏览器直接请求资源 2.FORWARD:转发访问资源 3.INCLUDE:包含访问资源 4.ERROR:错误跳转 5.ASYNC:异步访问资源 过滤器先后顺序问题1.注解配置:按照类名的字符串比较规则比较，值小的先执行 2.web.xml配置:&lt;filter-mappping&gt;谁定义在前面，谁先执行登录案例判断是否登录分析1.判断是否是登录的相关资源 * 是 直接放行 * 不是 判断是否登录 2.判断当前用户是否登录，判断Session是否有user * 有 已经登录 放行 * 没有 没有登录 跳转到登录页面代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;&#x2F;** * 登录验证的过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class loginFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;0.强制转换 HttpServletRequest request &#x3D; (HttpServletRequest) req; &#x2F;&#x2F;1.获取请求资源的路径 String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F;2.判断是否包含登录相关的路径 if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;&#x2F;loginServlet&quot;) || uri.contains(&quot;&#x2F;checkcodeServlet&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;))&#123; &#x2F;&#x2F;放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;不包含 需要验证用户是否登录 &#x2F;&#x2F;从Session获取user Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); if (user!&#x3D;null)&#123; &#x2F;&#x2F;登录了 放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;没有登录 跳转登录页面 request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp); &#125; &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 敏感词汇过滤分析1.对request对象进行增强。增强获取参数相关方法 2.放行。爨地代理对象增强对象的功能设计模式：一些通用的解决固定问题的方式 * 1.装饰模式 * 2.代理模式 实现步骤： - 1.代理对象和真实对象实现相同的接口 - 2.代理对象 = Proxy.newProxyInstance(); - 3.使用代理对象调用方法 - 4.增强方法 增强方式： - 1.增强参数列表 - 2.增强返回值类型 - 3.增强方法体执行逻辑代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.*;&#x2F;** * 敏感词汇过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class sensitiveWordsFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;创建代理对象，增强getParameter方法 ServletRequest proxy_req &#x3D; (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; &#x2F;&#x2F;判断是否是getParameter if (method.getName().equals(&quot;getParameter&quot;))&#123; &#x2F;&#x2F;增强返回值 &#x2F;&#x2F;获取返回值 String value &#x3D; (String) method.invoke(req,args); if (value !&#x3D; null)&#123; for (String str:list)&#123; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); &#125; &#125; &#125; return value; &#125; &#x2F;&#x2F;判断是否是getParameterMap if (method.getName().equals(&quot;getParameterMap&quot;))&#123; &#x2F;&#x2F;由request得到的原数组不可改变，他是被锁住的，所以这里创建一个新数组来复制原数组，返回新的数组 &#x2F;&#x2F;其实想法很想简单，既然传递进来的映射不可改变，那么自己new一个出来不就行了 Map&lt;String,String[]&gt; map1 &#x3D; new HashMap&lt;&gt;(); Map&lt;String,String[]&gt; map &#x3D; (Map&lt;String, String[]&gt;) method.invoke(req,args); Set&lt;String&gt; keySet &#x3D; map.keySet(); if (keySet !&#x3D; null)&#123; for (String str:list)&#123; for (String key:keySet)&#123; String[] values &#x3D; map.get(key); for (int i&#x3D;0;i&lt;values.length;i++)&#123; String value &#x3D; values[i]; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); values[i] &#x3D; value; &#125; &#125;map1.put(key,values); &#125; &#125; &#125; return map1; &#125; return method.invoke(req,args); &#125; &#125;); &#x2F;&#x2F;放行 chain.doFilter(proxy_req, resp); &#125; private List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F;敏感词汇 public void init(FilterConfig config) throws ServletException &#123; try &#123; &#x2F;&#x2F;获取文件真实路径 ServletContext context &#x3D; config.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;敏感词汇.txt&quot;); &#x2F;&#x2F;读取文件 BufferedReader br &#x3D; new BufferedReader(new FileReader(realPath)); &#x2F;&#x2F;将文件的每一行数据添加到list集合中 String line &#x3D; null; while ((line&#x3D;br.readLine())!&#x3D;null)&#123; list.add(line); &#125; br.close();&#x2F;&#x2F;释放资源 System.out.println(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Jetbrains系列产品2020.1最新激活方法","slug":"Jetbrains系列产品2020-1最新激活方法","date":"2020-04-15T03:56:11.000Z","updated":"2020-05-17T07:43:23.388Z","comments":true,"path":"2020/04/15/Jetbrains系列产品2020-1最新激活方法/","link":"","permalink":"http://yoursite.com/2020/04/15/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812020-1%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/","excerpt":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。","text":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。 大家熟知Jetbrains的话应该知道：他们家的所有产品升级到2018.2.1及以上版本后，先前可用的注册服务器都失效了，无法激活升级到最新版本体验最新黑科技。 这次要送的这份礼就是： Jetbrains全系列产品2020.1及以下版本（理论上适用于目前所有新老版本）最新注册服务器（License Server）的破解，可使用它来激活你手头上的Jetbrains IDE，具体支持产品和版本见下文的列表。 传送门: 百度云下载 提取码：w26y 使用方法: 0.先下载压缩包解压后得到jetbrains-agent.jar。 1.启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。 2.将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。（事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题） 3.在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。 4.重启IDE，搞定。 x. 支持两种注册方式：License server 和 Activation code: 1). 选择License server方式，地址填入：https://fls.jetbrains-agent.com （HTTP也可用，网络不佳用第2种方式） 2). 选择Activation code方式离线激活，请使用：ACTIVATION_CODE.txt 内的注册码激活 License key is in legacy format == Key invalid，表示agent配置未生效。 如果你需要自定义License name，请访问：https://zhile.io/custom-license.html 3). 现在你可以使用jetbrains-agent + activation code/license server激活jetbrains平台的付费插件了！ 现有Jetbrains付费插件Activation code: https://zhile.io/jetbrains-paid-plugins-license.html 现在有这些付费插件：https://plugins.jetbrains.com/search?isPaid=true 本项目在最新2020.1上测试通过。理论上适用于目前Jetbrains全系列所有新老版本。IDE升级会从旧版本导入以上设置，导入配置后可能提示未注册（因为刚导入的vmoptions未生效），直接重启IDE即可，无需其他操作。 本项目只做学习研究之用，不得用于商业用途！","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"BeanUtils工具类的使用","slug":"BeanUtils工具类的使用","date":"2020-04-11T07:17:27.000Z","updated":"2020-05-17T07:42:44.634Z","comments":true,"path":"2020/04/11/BeanUtils工具类的使用/","link":"","permalink":"http://yoursite.com/2020/04/11/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"BeanUtils工具类，简化数据封装","text":"BeanUtils工具类，简化数据封装 用于封装JavaBean的JavaBean：标准Java类要求： 1.类必须被public修饰 2.必须提供空参的构造器 3.成员变量必须使用private修饰 4.提供公共的setter和getter方法功能：封装数据下载点解链接下载 BeanUtils工具常用工具类有两个：BeanUtils、ConvertUtils。BeanUtils用于封装数据 方法 描述 BeanUtils对象 populate(Object bean, Map&lt;String,String[]&gt;properties) 将Map数据封装到指定Javabean中，一般用于将表单的所有数据封装到javabean setProperty(Object obj,String name,Object value) 设置属性值 getProperty(Object obj,String name) 获得属性值 代码123456789101112&#x2F;&#x2F;获取所有请求参数 Map&lt;String,String[]&gt; map &#x3D; req.getParameterMap (); &#x2F;&#x2F;创建User对象 User loginuser &#x3D; new User(); &#x2F;&#x2F;使用BeanUtils try &#123; BeanUtils.populate(loginuser,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"http的request对象和response对象","slug":"http","date":"2020-04-10T04:53:03.000Z","updated":"2020-05-17T07:43:05.982Z","comments":true,"path":"2020/04/10/http/","link":"","permalink":"http://yoursite.com/2020/04/10/http/","excerpt":"http的request对象和response对象","text":"http的request对象和response对象 概念：Hyper Text Transfer Protocol 超文本传输协议特点： 1.基于TCP/IP的高级协议 2.默认端口号8080 3.基于请求/相应模型：一次请求对应一次相应 4.无状态的：每次请求直接相互独立 请求消息的数据格式 1.请求行 请求方式 请求url 请求协议/版本 请求方式： GET 1.请求参数在请求行中，在url后面 2.请求url的长度有限 3.不太安全 POST 1.请求参数在请求体中 2.请求url长度没有限制 3.相对安全 2.请求头 3.请求空行 4.请求体 请求消息数据格式Request request和response对象的原理 1.request和response对象由服务器创建，我蛮来使用他们 2.request对象是来获取请求消息，response是来设置相应消息 request获取请求消息 获取请求行的数据 GET /test/demo1?name=zhangsan HTTP/1.1 1.获取请求方式 GET String getMethod() 2.获取虚拟目录 /test String getContextPath() 3.获取Servlet路径 /demo1 String getServletPath() 4.获取get方式请求传参 name=zhangsan String getQueryString() 5.获取URI /test/demo1 String getRequestURI() 6.获取协议及版本 HTTP/1.1 String getProtocol() 7.获取客户机的ip地址 String getRemoteAddr() 获取请求头的方法 String getHeader(String name)通过获取请求头的名称，获取请求头的值 获取请求体数据 只有post请求方式，才有请求体，在请求体中封装了post请求的请求参数 步骤： 1.获取流对象 BufferedReader getReader():获取字符输入流 ServletInputStream getInputStream():获取字节输入流 2.再从流对象中拿数据 获取请求参数的通用方法 1.String getParameter(String name):根据参数名称获取参数值 2.String[] getParameterValues(String name):根据参数名称获取参数值的数组 3.Enumeration&lt;String&gt; getParameterNames():获取所有请参数的名称 4.Map&lt;String,String[]&gt; getParameterMap():获取参数的所有Map集合12&#x2F;&#x2F;设置流的编码 防止乱码 req.setCharacterEncoding(&quot;utf-8&quot;); 请求转发：一种在服务器内部资源的跳转方式 步骤： 1.通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2.使用RequestDispatcher对象进行转发，forword(ServletRequest req,ServletRespnonse resp) 特点： 1.浏览器地址栏不发生变化 2.只能转发到当前服务器内部资源中 3.转发是一次请求 数据共享域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用域请求转发的多个资源中共享数据 方法： 1.void setAttribute(String name,Object obj):存储数据 2.Object getAttribute(String name):通过键获取值 3.void removeAttribute(String name):通过键来移除键值对获取ServletContext对象ServletContext getServletContext()响应消息相应消息的数据格式 1.相应行 组成：协议/版本 相应状态码 状态码描述 状态码分类： 1.1XX:服务器接收客户端消息，但没有接收完全，等待一段时间后，发送1XX 2.2XX:成功。200 3.3XX:重定向 302(重定向) 304(访问缓存) 4.4XX:客户端错误 404(请求路径没有对应的资源) 405(请求方式没有对应的doXXX方法) 5.5XX:服务器端错误 500(服务器内部出现异常) 2.相应头 1.格式:头名称:值 2.常见的相应头: 1.Content-Type:服务器告诉客户端本次相应体数据格式以及编码格式 2.Content-disposition:服务器告诉客户端以什么格式打开相应数据 3.相应空行 4.相应体 Response对象功能:设置相应消息 设置相应行 设置状态码:setStatus(int sc) 设置相应头 setHeader(String name,string value) 设置相应体 使用步骤: 1.获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 2.使用输出流，将数据输出到客户端浏览器 完成重定向代码实现 12&#x2F;&#x2F;简单的重定向的方法 resp.sendRedirect(&quot;&#x2F;ReaponseDemo_war_exploded&#x2F;responseDemo2&quot;); 特点: 1.地址栏发生变化 2.重定向可以访问其他站点 3.重定向是两次请求，不能使用request对象来共享数据 路径的写法 相对路径:不可以确定唯一资源 规则:.开头 找到当前资源和目标资源之间的相对位置关系 据对路径:可以确定唯一资源 服务器输出字符数据到浏览器步骤: 1.获取字符输出流 2.输出数据防止乱码 1234resp.setHeader(&quot;content-type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);&#x2F;&#x2F;简单的形式设计编码 resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); ServletContext对象1.概念:代表整个web应用，可以和程序的容器(服务器)通信 2.获取: 1.通过request对象获取request.getServletContext() 2.通过HttpServlet获取this.getServletContext 3.功能: 1.获取MIME类型 MIME类型:在互联网通信过程中定义的一种文件类型 格式:大类型/小类型 text/html 获取: `String getMineType(String file)` 代码示例 12345678ServletContext context &#x3D; this.getServletContext();&#x2F;&#x2F;定义文件名称String filename &#x3D; &quot;a.jpg&quot;;&#x2F;&#x2F;获取MIME类型String MimeType &#x3D; context.getMimeType(filename);System.out.println(MimeType); 2.域对象:共享数据 1.setAttribute(String name,String value) 2.getAttribute(String name) 3.removeAttribute(String name) ServletContext对象范围:所有用户请求的数据 3.获取文件的真实服务器路径 1.方法:String getRealPath() 案例文件下载需求: 1.页面显示超链接 2.点击链接后弹出下载提示框 3.完成图片文件下载123456789101112131415161718192021222324@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;获取请求参数 文件名称 String filename &#x3D; req.getParameter(&quot;filename&quot;); &#x2F;&#x2F;使用字节输入流，加载文件进内存 ServletContext context &#x3D; this.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;img&#x2F;&quot;+filename);&#x2F;&#x2F;获取文件真实路径 FileInputStream fis &#x3D; new FileInputStream(realPath); &#x2F;&#x2F;设置Response的相应头 String mineType &#x3D; context.getMimeType(filename);&#x2F;&#x2F;获取文件的MIME类型 resp.setHeader(&quot;content-type&quot;,mineType); resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename); &#x2F;&#x2F;将输入流的数据写出到输出流 ServletOutputStream sos &#x3D; resp.getOutputStream(); byte[] bytes &#x3D; new byte[1024]; int len &#x3D; 0; while ((len&#x3D;fis.read(bytes))!&#x3D;-1)&#123; sos.write(bytes,0,len); &#125; fis.close(); &#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"tomcat及Servlet","slug":"tomcat及Servlet","date":"2020-04-08T06:47:13.000Z","updated":"2020-05-17T07:44:01.625Z","comments":true,"path":"2020/04/08/tomcat及Servlet/","link":"","permalink":"http://yoursite.com/2020/04/08/tomcat%E5%8F%8AServlet/","excerpt":"Tomcat","text":"Tomcat 安装tomcat进入官网，个人推荐下载解压版，方便快捷 解压到工作目录后就可以使用了 进入bin目录 双击startup.bat linux打开.sh 可能遇到的两个问题 双击之后没有启动tomcat 黑窗口秒关闭—-JAVA_HOME的环境变量没有没配置好 运行日志乱码—-打开cd到tomcat/conf/目录下修改logging.properties找到 java.util.logging.ConsoleHandler.encoding = utf-8 这行将utf-8改为GBK 部署项目 1.直接将项目放到webapps目录下即可 /hello :项目访问的路径—-&gt;虚拟目录将项目打包成一个war包，再将war包放到webapps目录下 war包会自动解压 2.配置conf/server.xml 在标签体中配置 docBase：项目存放的路径 path:虚拟目录 3.在conf\\Catalina\\localhost创建任意名称的xml文件，在文件中编写 `&lt;Context docBase=&quot;D:\\hello&quot;&gt;` 虚拟目录就是文件的名称 静态项目和动态项目：目录结构： --项目的根目录 --WEB-INF目录 --web.xml:web项目的核心配置文件 --classes目录：放置字节码文件的目录 --lib目录：防止依赖的jar包Servlet 概念：server applet 运行在服务器端的小程序 servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则步骤：1.创建javaEE项目 2.定义一个类，实现Servlet接口 3.实现接口中的抽象方法 4.配置 Servlet---- 在web.xml中配置 配置代码12345678&lt;servlet&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;servlet-class&gt;cn.test.web.Servlet.ServletDemo1&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 执行原理 1.当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的Servlet的资源路径 2.查找web.xml文件，是否有对应的标签体内容 3.如果有，则再找到对应的全类名 4.tomcat会将字节码文件加载进内存，并创建其对象 5.调用方法Servlet的生命周期 1.被创建：执行init方法，只执行一次 2.提供服务：执行servlet方法，执行多次 3.被销毁：执行destroy方法，执行一次 Servlet3.0支持注解文件配置，可以不需要web.xml 步骤： 1.创建javaEE的项目，选择Servlet的版本 3.0以上，可以不勾选web.xml 2.定义一个类，实现Servlet接口 3.重写方法 4.在类上使用一个注解 @WebServlet(&quot;资源路径&quot;)Servlet的体系结构 Servlet 接口 GenericServlet 抽象类 将Servlet接口的其他方法做了默认实现，只将service()方法作为抽象 HttpServlet 抽象类 对HTPP协议的一种封装，简化操作 1.定义类继承HttpServlet 2.复写doGet/doPost方法 Servlet相关配置 1.urlpartten：Servlet访问的路径 1.一个Servlet可以定义多个访问路径:WebServlet({&quot;/d4&quot;,&quot;Demo4&quot;}) 2.路径的定义规则：/XXX，/XXX，*.do","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"XML解析器","slug":"XML解析器","date":"2020-04-07T11:24:23.000Z","updated":"2020-05-17T07:44:10.154Z","comments":true,"path":"2020/04/07/XML解析器/","link":"","permalink":"http://yoursite.com/2020/04/07/XML%E8%A7%A3%E6%9E%90%E5%99%A8/","excerpt":"解析：操作xml文档，将文档中的数据读取到内存中","text":"解析：操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式： DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树* 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 SAX：逐行读取，基于事件驱动的。* 优点：不占内存。 * 缺点：只能读取，不能增删改 xml常见的解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。快速入门：步骤： 1.导入jar包—-链接：https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw提取码：6sg6 下载完成后解压，将jsoup-1.11.2.jar 和 JsoupXpath-0.3.2.jar(后面Jsoup_Xpath查询会用到，现在一块导入) ，压缩包包括jsoup-1.11.2-javadoc、jsoup-1.11.2.jar、jsoup-1.11.2-javadoc.jar、jsoup-1.11.2-sources.jar、JsoupXpath-0.3.2.jar 2 获取Document对象 3.获取对应的标签Element对象 4.获取数据 代码 123456789101112131415161718192021222324252627282930313233343536373839404142import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;public class Demo1 &#123; public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F;获取Document对象，根据XML文档获取 &#x2F;&#x2F;获取student.xml的path String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); &#x2F;&#x2F;获取元素对象 Element Elements elements &#x3D; document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); &#x2F;&#x2F;获取第一个name的Element对象 Element element &#x3D; elements.get(0); &#x2F;&#x2F;获取数据 String name &#x3D; element.text(); System.out.println(name); &#125;&#125;&#96;&#96;&#96; studen.xml文件中的代码&#96;&#96;&#96;&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;utf-8&#39;?&gt;&lt;users&gt; &lt;user id&#x3D;&#39;1&#39;&gt; &lt;name id&#x3D;&quot;0001&quot;&gt;张三&lt;&#x2F;name&gt; &lt;age&gt;23&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt; &lt;user id&#x3D;&#39;2&#39;&gt; &lt;name&gt;李四&lt;&#x2F;name&gt; &lt;age&gt;30&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt;&lt;&#x2F;users&gt; 对象的使用：1. Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。 parse​(String html)：解析xml或html字符串 parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList来使用4. Element：元素对象 1.获取子元素对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式： selector:选择器 使用的方法：Elements select​(String cssQuery)cssQuery按照以前css选择器名字来做 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 示例代码： 1234567891011121314151617181920212223242526272829package Jsoup;import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;import cn.wanghaomiao.xpath.model.JXDocument;import cn.wanghaomiao.xpath.model.JXNode;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;import java.util.List;public class Demo5 &#123; public static void main(String[] args) throws IOException, XpathSyntaxErrorException &#123; String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); JXDocument jxDocument &#x3D; new JXDocument(document);&#x2F;&#x2F; List&lt;JXNode&gt; users &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;);&#x2F;&#x2F; for (JXNode j:users)&#123;&#x2F;&#x2F; System.out.println(j);&#x2F;&#x2F; &#125; List&lt;JXNode&gt; list &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;); for (JXNode jxNode:list)&#123; System.out.println(jxNode); &#125; &#125;&#125;","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"python爬虫","slug":"python爬虫","date":"2020-04-06T10:21:00.000Z","updated":"2020-05-17T07:43:40.587Z","comments":true,"path":"2020/04/06/python爬虫/","link":"","permalink":"http://yoursite.com/2020/04/06/python%E7%88%AC%E8%99%AB/","excerpt":"scrapy爬虫框架的安装","text":"scrapy爬虫框架的安装 用pip install scrapy命令安装会提示失败，是因为缺少twisted程序进入官网 按住ctrl+f 查找关键字下载好与python版本配对的文件用命令安装下载好的文件 注意路径最好不要太长 否则容易报错安装好插件以后用命令pip install scrapy安装框架安装好以后用命令’scrapy’查看版本出现以上代码说明安装成功","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"搭建个人博客及其部署","slug":"安装Hexo环境","date":"2020-04-06T08:17:01.000Z","updated":"2020-05-18T12:17:57.429Z","comments":true,"path":"2020/04/06/安装Hexo环境/","link":"","permalink":"http://yoursite.com/2020/04/06/%E5%AE%89%E8%A3%85Hexo%E7%8E%AF%E5%A2%83/","excerpt":"特别鸣up主CodeSheep","text":"特别鸣up主CodeSheep 基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。安装Node.js官网建议下载第一个安装步骤非常简单，一直next，下一步就可以了，默认安装就行。 安装git官网然后我们选择windows版本的下载安装也是一直点下一步，安装官方默认的来就行，安装完了，在开始菜单可以看到 安装hexo创建一个工作目录 比如在c盘建一个blog文件夹用管理员属性打开cmd cd到工作目录使用npm 安装hexonpm install -g hexo-cli输入hexo -v判断hexo是否安装成功输入hexo init初始化一个博客这里是hexo常用的命令 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 输入hexo s之后可以进入http://localhost:4000/这个地址查看我们的博客 部署服务器这里我们选用的部署到github上面首先新建一个github的仓库这里的name一定要填自己的用户名.github.io 不然会出问题去工作目录找到_config.yml这个文件 双击打开 我这里使用vscode打开的 用notepad++ 文本打开都可以红线换成自己的github用户名就行了 其他两行按照这个填写安装 hexo-deployer-git。npm install hexo-deployer-git --save部署一下就好了 123hexo cleanhexo ghexo d 这样你就可以通过自己的git仓库的域名访问你自己的博客了同样还可以部署在码云和coding上这个可以加快访问的速度 开启github pages服务，绑定域名如果你觉域名比较难记，可以自己去申请一个域名 这里我们以腾讯云为例，前提是我已经申请好了点击解析域名最好添加一个主机记录为@记录类型为CNAME类型，记录值写自己github仓库的地址名。 接下来配置github的 pages服务 找到博客对应的仓库，点击setting 下滑找到Github Pages，填入自己的域名，点击save保存 这样就可以通过自己的域名访问呢了","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}