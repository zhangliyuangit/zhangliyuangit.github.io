{"meta":{"title":"张利源","subtitle":"","description":"但愿日子平静，抬头遇见的都是柔情","author":"张利源","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-17T08:00:27.682Z","updated":"2020-05-17T08:00:27.682Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-05-17T07:53:41.596Z","updated":"2020-05-17T07:53:41.596Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"java小白一枚"},{"title":"所有分类","date":"2020-05-17T07:54:19.336Z","updated":"2020-05-17T07:54:19.336Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-05-17T07:58:54.752Z","updated":"2020-05-17T07:58:54.752Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2020-05-17T07:56:17.193Z","updated":"2020-05-17T07:56:17.193Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Java JavaWeb 软件"}],"posts":[{"title":"mybatis框架(一)","slug":"mybatis框架-一","date":"2020-05-19T11:04:42.000Z","updated":"2020-05-19T11:19:09.667Z","comments":true,"path":"2020/05/19/mybatis框架-一/","link":"","permalink":"http://yoursite.com/2020/05/19/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%80/","excerpt":"mybatis笔记","text":"mybatis笔记 mybatis概述mybatis是一个持久层框架，用java编写，封装了很多jdbc细节，开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程，它使用了ORM思想，实现了结果集的封装。 ORM：Object Relational Mappging 对象关系映射简单的说：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类及实现操作数据库 mybatis环境搭建 1.创建maven工程并导入坐标12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.18&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2.创建实体类和dao接口 3.创建mybatis的主配置文件SqlMapConfig.xml 4.创建映射配置文件注意事项 1.包在创建时 com.demomybatis.dao他是三级目录结构 2.mybatis的映射配置文件位置必须和dao接口的包结构相同 3.映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定而类名 4.映射配置文件的擦偶哦配置(select) id的取值必须是dao接口的方法名 当我们遵从2，3，4点之后，我们开发中就无需再写dao的实现类 SqlMapConfig.xml代码1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default&#x3D;&quot;mysql&quot;&gt; &lt;environment id&#x3D;&quot;mysql&quot;&gt; &lt;!--使用jdbc事务管理 --&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;!-- 数据库连接池(数据源) --&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!-- 引入映射配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;cn&#x2F;demomybatis&#x2F;dao&#x2F;StudentDao.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; StudentDao.xml代码123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace：命名空间，用于隔离sql--&gt;&lt;mapper namespace&#x3D;&quot;cn.demomybatis.dao.StudentDao&quot;&gt; &lt;!-- 配置查询所有 id为dao的方法名--&gt; &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;cn.demomybatis.domain.Student&quot; parameterType&#x3D;&quot;cn.demomybatis.domain.Student&quot;&gt; select * from student &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 测试代码1234567891011121314151617181920212223242526272829303132333435363738package cn.demomybatis.test;import cn.demomybatis.dao.StudentDao;import cn.demomybatis.domain.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;&#x2F;** * mybatis入门 *&#x2F;public class mybatistest &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;读取配置文件 InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); &#x2F;&#x2F;创建工厂 SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder(); SqlSessionFactory factory &#x3D; builder.build(in); &#x2F;&#x2F;使用工厂生产SqlSession对象 SqlSession sqlSession &#x3D; factory.openSession(); &#x2F;&#x2F;创建Dao接口的代理对象 StudentDao studentDao &#x3D; sqlSession.getMapper(StudentDao.class); &#x2F;&#x2F;使用代理对象执行方法 List&lt;Student&gt; list &#x3D; studentDao.findAll(); for (Student student:list)&#123; System.out.println(student); &#125; &#x2F;&#x2F;释放资源 sqlSession.close(); in.close(); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"抽取Servlet","slug":"抽取Servlet","date":"2020-05-13T09:15:56.000Z","updated":"2020-05-17T07:41:58.636Z","comments":true,"path":"2020/05/13/抽取Servlet/","link":"","permalink":"http://yoursite.com/2020/05/13/%E6%8A%BD%E5%8F%96Servlet/","excerpt":"BaseServlet代码","text":"BaseServlet代码 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.travel.web.servlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;完成方法的分发 &#x2F;&#x2F;获取请求路径 String uri &#x3D; req.getRequestURI(); System.out.println(&quot;请求uri:&quot;+uri); &#x2F;&#x2F;获取方法对象 String methodName &#x3D; uri.substring(uri.lastIndexOf(&quot;&#x2F;&quot;)+1); System.out.println(&quot;方法名称：&quot;+methodName); &#x2F;&#x2F;获取方法对象Method try &#123; Method method &#x3D; this.getClass().getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class); &#x2F;&#x2F;暴力反射 &#x2F;&#x2F;method.setAccessible(true); &#x2F;&#x2F;执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; UserServlet代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198package cn.travel.web.servlet;import cn.travel.damain.ResultInfo;import cn.travel.damain.User;import cn.travel.service.UserService;import cn.travel.service.impl.UserServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;&#x2F;user&#x2F;*&quot;)public class UserServlet extends BaseServlet &#123; &#x2F;** * 注册功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void regist(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;验证码校验 String checkcode &#x3D; request.getParameter(&quot;checkcode&quot;); String checkcode_session &#x3D; (String) request.getSession().getAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;防止验证码复用 保证验证码只能使用一次 request.getSession().removeAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;比较 if (checkcode_session &#x3D;&#x3D; null || !checkcode_session.equalsIgnoreCase(checkcode)) &#123; ResultInfo info &#x3D; new ResultInfo(); info.setFlag(false); info.setErrorMsg(&quot;验证码错误&quot;); &#x2F;&#x2F;将info对象序列化为json ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(info); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); return; &#125; &#x2F;&#x2F;获取数据 String username &#x3D; request.getParameter(&quot;username&quot;); String password &#x3D; request.getParameter(&quot;password&quot;); String name &#x3D; request.getParameter(&quot;name&quot;); String birthday &#x3D; request.getParameter(&quot;birthday&quot;); String email &#x3D; request.getParameter(&quot;email&quot;); &#x2F;&#x2F;封装对象 User user &#x3D; new User(); user.setUsername(username); user.setPassword(password); user.setName(name); user.setBirthday(birthday); user.setEmail(email); &#x2F;&#x2F;调用service完成注册 UserService service &#x3D; new UserServiceImpl(); boolean flag &#x3D; service.regist(user); &#x2F;&#x2F;响应结果 ResultInfo resultInfo &#x3D; new ResultInfo(); if (flag) &#123; &#x2F;&#x2F;注册成功 resultInfo.setFlag(true); &#125; else &#123; &#x2F;&#x2F;注册失败 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;注册失败！&quot;); &#125; &#x2F;&#x2F;将resultInfo对象序列化为JSON，并写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); &#x2F;&#x2F;将json数据写回客户端 &#x2F;&#x2F;设置content-type response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 登录功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取用户名和密码数据 Map&lt;String, String[]&gt; map &#x3D; request.getParameterMap(); &#x2F;&#x2F;分装user对象 User user &#x3D; new User(); try &#123; BeanUtils.populate(user, map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;调用service查询 UserService service &#x3D; new UserServiceImpl(); User u &#x3D; service.login(user); &#x2F;&#x2F;判断 ResultInfo resultInfo &#x3D; new ResultInfo(); if (u &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;用户名密码错误 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;用户名或密码错误!&quot;); &#125; &#x2F;&#x2F;判断用户是否激活 if (u !&#x3D; null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;用户尚未激活 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;您尚未激活，请前往邮箱激活!&quot;); &#125; &#x2F;&#x2F;登录成功的判断 if (u !&#x3D; null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;登录成功 resultInfo.setFlag(true); &#125; request.getSession().setAttribute(&quot;user&quot;, u); &#x2F;&#x2F;响应数据 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 查找单个对象 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); &#x2F;&#x2F;将user写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); mapper.writeValue(response.getOutputStream(), user); &#125; &#x2F;** * 退出 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void exit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;销毁session request.getSession().invalidate(); &#x2F;&#x2F;跳转页面 重定向 response.sendRedirect(request.getContextPath() + &quot;&#x2F;login.html&quot;); &#125; &#x2F;** * 激活 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void active(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取激活码 String code &#x3D; request.getParameter(&quot;code&quot;); if (code !&#x3D; null) &#123; &#x2F;&#x2F;调用service完成激活 UserService service &#x3D; new UserServiceImpl(); Boolean flag &#x3D; service.active(code); &#x2F;&#x2F;判断标记 String msg &#x3D; null; if (flag) &#123; &#x2F;&#x2F;激活成功 msg &#x3D; &quot;激活成功，请&lt;a href&#x3D;&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;; &#125; else &#123; &#x2F;&#x2F;激活失败 msg &#x3D; &quot;激活失败，联系管理员&quot;; &#125; response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); response.getWriter().write(msg); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"redis数据库","slug":"redis数据库","date":"2020-05-01T04:10:36.000Z","updated":"2020-05-18T07:48:47.217Z","comments":true,"path":"2020/05/01/redis数据库/","link":"","permalink":"http://yoursite.com/2020/05/01/redis%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"Redis","text":"Redis 下载：百度云下载 提取码：o1ui Github下载 概念：一款高性能的NOSQL系列的非关系型数据库命令：redis存储的是：key，value格式的数据，其中key都是字符串，value有5中不同的数据结构 value的数据结构 1.字符串类型 string 2.哈希类型 hash ：相当于map集合 3.列表集合 list ：linkedlist格式 4.集合类型 set 5.有序集合类型 sortedset字符串类型string1.存储 set key value 2.获取 get key 3.删除 del key 哈希类型 hash1.存储 hset key field value 2.获取 hget key field hgetall key 获取所有的键和值 3.删除 hdel key field 列表类型 list1.lpush key value 将元素加入列表左边 2.rpush key value 将元素加入列表右边 3.lrange key start end 获取范围 4.lpop key 删除列表最左边的元素，并将元素返回 5.rpop key 删除列表最右边的元素 集合类型 set1.存储：sadd key value 2.获取：smembers key ：获取集合中所有元素 3.删除：srem key value ：删除集合的某个元素 有序集合类型 sortedset1.存储：zadd key score value 2.获取：zrange key start end 3.删除：zrem key value 通用命令：1.keys * ：查询所有的键 2.type key：获取键对应的value的类型 3.del key：删除指定的key value 持久化存储 1.redis是一个内存数据库，东redis服务器重启后，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘中 2.redis持久化机制 1.RDB：默认方式。 在一定的间隔时间中，检测key的变化情况，然后去持久化数据 2.AOF：日志记录的方式，可以检测每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windows.conf文件 appendonly no 给成yes Java客户端JedisJedis是一款java操作redis数据库的工具Jedis连接池：JedisPool1.创建JedisPool连接池对象 2.调用getResource()方法获取Jedis的连接工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142package cn.jedis.utlis;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;&#x2F;*JedisPool工具类加载配置文件，配置连接池参数提供获取连接的方法 *&#x2F;public class JedisPoolUtils &#123; private static JedisPool jedisPool; static &#123; &#x2F;&#x2F;读取配置文件 InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); &#x2F;&#x2F;创建一个Properties对象 Properties pro &#x3D; new Properties(); &#x2F;&#x2F;关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中 JedisPoolConfig config &#x3D; new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); &#x2F;&#x2F;初始化JedisPool jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; &#x2F;&#x2F;获取连接 public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"AJAX和JSON","slug":"ajax和JSON","date":"2020-04-28T11:12:12.000Z","updated":"2020-05-17T07:39:30.306Z","comments":true,"path":"2020/04/28/ajax和JSON/","link":"","permalink":"http://yoursite.com/2020/04/28/ajax%E5%92%8CJSON/","excerpt":"AJAX","text":"AJAX 概念：ASynchronous JavaScript And XML 异步的javascript和xml实现方式: 1.原生的JS实现方式 2.JQuery实现方式 1.$.ajax()} $.ajax({键值对}); 2.$.get() 3.$.post() JOSN概念：JavaScript Object Notation JavaScript对象表示法基本规则：获取数据:json对象.键名 json对象[“键名”] 数组对象[索引] 遍历JSON123for (var key in person)&#123; alert(key+&quot;:&quot;+person[key])&#125; JSON数据和Java对象的相互转换1.JSON转为Java 1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 12345678String json &#x3D; &quot;&#123;\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:20,\\&quot;gender\\&quot;:\\&quot;男\\&quot;&#125;&quot;;&#x2F;&#x2F;创建ObjectMappperObjectMapper mapper &#x3D; new ObjectMapper();mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);&#x2F;&#x2F;转换为Java的对象Person person &#x3D; mapper.readValue(json,Person.class);System.out.println(person); 2.Java转为JSON1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 123456789101112131415161718192021public void test1() throws Exception &#123; Person p &#x3D; new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGendeer(&quot;男&quot;); &#x2F;&#x2F;创建Jackson的核心对象 ObjectMapper ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;调用方法 转换 String JSON &#x3D; mapper.writeValueAsString(p); System.out.println(JSON); &#x2F;&#x2F;wirterValue 将数据写入到D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt中 &#x2F;&#x2F;mapper.writeValue(new File(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt&quot;),p); &#x2F;&#x2F;writeValue将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;b.txt&quot;),p);&#125; 注解：1.@JsonIgnore:排除属性 2.@JsonFormat:属性值格式化案例校验用户是否存在 html代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;注册&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;JS&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F;页面加载完成后 给文本框绑定离开焦点事件 $(function () &#123; $(&quot;#username&quot;).blur(function () &#123; &#x2F;&#x2F;获取username获取文本输入框的值 var username &#x3D; $(this).val(); &#x2F;&#x2F;发送ajax请求 $.get(&quot;findUserServlet&quot;,&#123;username:username&#125;,function (data) &#123; var span &#x3D; $(&quot;#s_username&quot;) if (data.userExsit)&#123; &#x2F;&#x2F;用户名存在 span.css(&quot;color&quot;,&quot;red&quot;) span.html(data.msg) &#125;else &#123; &#x2F;&#x2F;用户名不存在 span.css(&quot;color&quot;,&quot;green&quot;) span.html(data.msg) &#125; &#125;,&quot;json&quot;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form&gt; &lt;input id&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt; &lt;span id&#x3D;&quot;s_username&quot;&gt;&lt;&#x2F;span&gt;&lt;br&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;注册&quot;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Servlet代码 123456789101112131415161718192021222324252627282930313233343536373839package cn.test.web.servlet;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;&#x2F;findUserServlet&quot;)public class findUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username &#x3D; request.getParameter(&quot;username&quot;); &#x2F;&#x2F;设置响应数据为JSON response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); if (&quot;Tom&quot;.equals(username))&#123; &#x2F;&#x2F;存在 map.put(&quot;userExsit&quot;,true); map.put(&quot;msg&quot;,&quot;用户名已经存在&quot;); &#125;else &#123; &#x2F;&#x2F;不存在 map.put(&quot;userExsit&quot;,false); map.put(&quot;msg&quot;,&quot;用户名可用&quot;); &#125; &#x2F;&#x2F;将map转为json，并且传递给客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); mapper.writeValue(response.getWriter(),map); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JQuery笔记","slug":"JQuery笔记","date":"2020-04-26T08:04:39.000Z","updated":"2020-05-17T07:43:32.163Z","comments":true,"path":"2020/04/26/JQuery笔记/","link":"","permalink":"http://yoursite.com/2020/04/26/JQuery%E7%AC%94%E8%AE%B0/","excerpt":"JQuery笔记","text":"JQuery笔记 概念：一个JavaScript框架，简化JS开发 使用步骤： 1.下载JQuery 2.导入JQuery的js文件 导入min.js 3.使用 JQuery对象和JS对象的区别 方法不互通 转换： jq -&gt; js : jq对象[索引] 或者 jp对象.get(索引) js -&gt; jq : $(js对象)选择器：筛选具有相似特征的元素(标签)1.基本选择器 1.标签选择器(元素选择器) `$(&quot;html标签名&quot;)` 获得所有匹配标签名称的元素 2.id选择器 `$(&quot;#id的属性值&quot;)` 获得与指定id值匹配的元素 3.类选择器 `$(&quot;.class的属性&quot;)` 获得与指定的class属性值相匹配的元素2.层级选择器 1.后代选择器： `$(&quot;A B&quot;)` 选择A元素所有内部的B元素 2.子选择器 `$(&quot;A &gt; B&quot;)` 选择A元素内部的所有B子元素 3.属性选择器 1.属性名称选择器 $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2.属性选择器 $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3.符合属性选择器 $(&quot;A[属性名=&apos;值&apos;][ ]...&quot;) 包含多个属性条件的选择器 4.过滤选择器 1.首元素选择器 :first 获得选择的元素中第一个元素 2.尾元素选择器 :last 获得选择的元素中最后一个元素 3.非元素选择器 not(.selector) 不包括指定内容的元素 4.偶数选择器 even 偶数，从0开始计数 5.奇数选择器 odd 奇数 ，从0开始 6.等于索引选择器 eq(index) 指定索引元素 7.大于索引选择器 gt(index) 大于指定索引选择器 8.小于索引选择器 lt(index) 小于指定索引选择器 9.标题选择器 header 获得标题(h1-h6)元素，固定写法 5.表单过滤选择器 1.可用元素选择器 :enabled 获得可用元素 2.不可以用元素选择器 :disabled 获得不可用元素 3.选中选择器 :checked 获得单选，复选框中的元素 4.选中选择器 :selected 获得下拉框中选中的元素 DOM操作1.内容操作 1.html() ： 获取/设置元素的标签体内容， 内容 –&gt; 内容 2.text() ： 获取/设置元素标签体纯文本内容 内容 –&gt; 内容 3.val() : 获取/设置元素的属性值 2.属性操作 1.通用属性操作 1.attr() 获取/设置元素的属性 2.removeAttr() 删除属性 3.prop() 获取/设置元素的属性 4.removeProp() 删除属性 *attr和prop的区别 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素的自定义属性，则建议是attr 2.对class属性操作 1.addClass() 添加class属性值 2.removeClass() 删除class属性值 3.toggleClass() 切换class属性值 3.CRUD操作 1.append(): 父元素将子元素追加到末尾 - 对象1.append(对象2)：将对象2添加到对象1元素内部，并且在末尾 2.prepend():父元素将子元素追加到开头 -对象1.prepend(对象2)：将对象2添加到对象1元素内部，并且在开头 3.appendto(): 4.prependto(): 5.after():添加元素到元素后边 6.before()：将元素添加到元素前边 7.insertAfter(): 8.insertBrfore(): 9.remove()：删除元素 10.empty()：清空元素的所有后代元素JQuery高级1.动画 1.三种方式显示和隐藏元素 1.show([speed,[easing],[fn]]) 2.hide([speed,[easing],[fn]]) 3.toggle([speed],[easing],[fn]) 2.滑动显示和隐藏方式 1.slideDown([speed],[easing],[fn]) 2.slideUp([speed,[easing],[fn]]) 3.slieToggle([speed],[easing],[fn]) 3.淡入淡出的显示和隐藏方式 1.fadeIn([speed],[easing],[fn]) 2.fadeOut([speed],[easing],[fn]) 3.fadeToggle([speed,[easing],[fn]])2.遍历 1.jq对象.each(callback) 2.$.each(object,[callback]) 3.for..of: 3.事件绑定 1.jquery标准的绑定方式 jq对象.事件方法(回调函数) 2.on绑定事件/off绑定事件 jq对象.on(&quot;事件名称&quot;,回调函数) jq对象.off(&quot;事件名称&quot;) 3.事件切换 jq对象.toggle(fn1,fn2...) 案例需求：1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;*需求： 1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失 分析： 1.使用定时器来完成。setTimeout(执行一次) 2.JQuery的动画效果就是控制display属性 *&#x2F; &#x2F;&#x2F;入口函数，在页面加载完成后定义定时器，调用这两个方法 $(function () &#123; &#x2F;&#x2F;定时器 调用adShow()方法 setTimeout(adShow,3000); setTimeout(adHide,8000); &#125;) &#x2F;&#x2F;显示广告方法 function adShow() &#123; &#x2F;&#x2F;获取广告div 调用show方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; &#x2F;&#x2F;隐藏广告方法 function adHide() &#123; $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt; &lt;div id&#x3D;&quot;ad&quot; style&#x3D;&quot;display: none;&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;广告.jpg&quot;&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;content&quot;&gt; 正文部分 &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 需求：抽奖案例 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;抽奖&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;* 分析： 1.给开始按钮绑定单击事件 1.1定义循环定时器 1.2切换小相框的src属性 定义一个数组，存放图片资源的路径 生成随机数 数组索引 2.给结束按钮绑定单击事件 2.1停止定时器 2.2给大相框设置src属性 *&#x2F; var imgs &#x3D; [&quot;..&#x2F;img&#x2F;1.jpg&quot;,&quot;..&#x2F;img&#x2F;2.jpg&quot;,&quot;..&#x2F;img&#x2F;3.jpg&quot;,&quot;..&#x2F;img&#x2F;4.jpg&quot;,&quot;..&#x2F;img&#x2F;5.jpg&quot;,&quot;..&#x2F;img&#x2F;6.jpg&quot;,&quot;..&#x2F;img&#x2F;0.jpg&quot;] var startId;&#x2F;&#x2F;开始定时器的一个Id var index; $(function () &#123; &#x2F;&#x2F;开始按钮 $(&quot;#startID&quot;).click(function () &#123; startId &#x3D; setInterval(function () &#123; &#x2F;&#x2F;生成随机角标 index &#x3D; Math.floor(Math.random() * 7) &#x2F;&#x2F;设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20) &#125;) &#x2F;&#x2F;结束按钮 $(&quot;#stopID&quot;).click(function () &#123; $(&quot;#stopID&quot;).click(function () &#123; &#x2F;&#x2F;停止定时器 clearInterval(startId) $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--小相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;width: 160px;height: 100px;&quot;&gt; &lt;img id&#x3D;&quot;img1ID&quot; style&#x3D;&quot;width: 160px;height: 100px&quot; src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot;&gt;&lt;&#x2F;div&gt;&lt;!--大相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;height: 500px;position: absolute;left: 500px;top: 10px&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot; id&#x3D;&quot;img2ID&quot; width&#x3D;&quot;800px&quot;height&#x3D;&quot;600px&quot;&gt;&lt;&#x2F;div&gt;&lt;!--开始按钮--&gt;&lt;input id&#x3D;&quot;startID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击开始&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;!--停止按钮--&gt;&lt;input id&#x3D;&quot;stopID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击停止&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Filter过滤器","slug":"Filter过滤器","date":"2020-04-23T06:49:44.000Z","updated":"2020-05-17T07:42:52.842Z","comments":true,"path":"2020/04/23/Filter过滤器/","link":"","permalink":"http://yoursite.com/2020/04/23/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"Filter：过滤器","text":"Filter：过滤器 步骤： 1.定义一个类，实现Filter 2.复写方法 3.配置拦截路径 web.xml的配置12345678&lt;filter&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;cn.filter.demo1&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&#x2F;&#x2F;拦截路径&lt;&#x2F;filter-mapping&gt; 过滤器的生命周期 1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次用于加载资源 2.doFilter:每次拦截资源时被执行，执行很多次。 3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。执行一次，用于释放资源。 拦截路径的配置 1.具体的资源路径:/index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2.目录拦截: /user/* 访问/user下的所有资源时，过滤器都会被执行 3.后缀名拦截： *.jsp 访问所有后缀名为jsp的资源时，过滤器都会被执行 4.拦截所有资源： /* 访问所有资源时，过滤器都会被执行 拦截方式的配置注解配置： 1.REQUEST:默认值 浏览器直接请求资源 2.FORWARD:转发访问资源 3.INCLUDE:包含访问资源 4.ERROR:错误跳转 5.ASYNC:异步访问资源 过滤器先后顺序问题1.注解配置:按照类名的字符串比较规则比较，值小的先执行 2.web.xml配置:&lt;filter-mappping&gt;谁定义在前面，谁先执行登录案例判断是否登录分析1.判断是否是登录的相关资源 * 是 直接放行 * 不是 判断是否登录 2.判断当前用户是否登录，判断Session是否有user * 有 已经登录 放行 * 没有 没有登录 跳转到登录页面代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;&#x2F;** * 登录验证的过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class loginFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;0.强制转换 HttpServletRequest request &#x3D; (HttpServletRequest) req; &#x2F;&#x2F;1.获取请求资源的路径 String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F;2.判断是否包含登录相关的路径 if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;&#x2F;loginServlet&quot;) || uri.contains(&quot;&#x2F;checkcodeServlet&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;))&#123; &#x2F;&#x2F;放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;不包含 需要验证用户是否登录 &#x2F;&#x2F;从Session获取user Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); if (user!&#x3D;null)&#123; &#x2F;&#x2F;登录了 放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;没有登录 跳转登录页面 request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp); &#125; &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 敏感词汇过滤分析1.对request对象进行增强。增强获取参数相关方法 2.放行。爨地代理对象增强对象的功能设计模式：一些通用的解决固定问题的方式 * 1.装饰模式 * 2.代理模式 实现步骤： - 1.代理对象和真实对象实现相同的接口 - 2.代理对象 = Proxy.newProxyInstance(); - 3.使用代理对象调用方法 - 4.增强方法 增强方式： - 1.增强参数列表 - 2.增强返回值类型 - 3.增强方法体执行逻辑代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.*;&#x2F;** * 敏感词汇过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class sensitiveWordsFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;创建代理对象，增强getParameter方法 ServletRequest proxy_req &#x3D; (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; &#x2F;&#x2F;判断是否是getParameter if (method.getName().equals(&quot;getParameter&quot;))&#123; &#x2F;&#x2F;增强返回值 &#x2F;&#x2F;获取返回值 String value &#x3D; (String) method.invoke(req,args); if (value !&#x3D; null)&#123; for (String str:list)&#123; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); &#125; &#125; &#125; return value; &#125; &#x2F;&#x2F;判断是否是getParameterMap if (method.getName().equals(&quot;getParameterMap&quot;))&#123; &#x2F;&#x2F;由request得到的原数组不可改变，他是被锁住的，所以这里创建一个新数组来复制原数组，返回新的数组 &#x2F;&#x2F;其实想法很想简单，既然传递进来的映射不可改变，那么自己new一个出来不就行了 Map&lt;String,String[]&gt; map1 &#x3D; new HashMap&lt;&gt;(); Map&lt;String,String[]&gt; map &#x3D; (Map&lt;String, String[]&gt;) method.invoke(req,args); Set&lt;String&gt; keySet &#x3D; map.keySet(); if (keySet !&#x3D; null)&#123; for (String str:list)&#123; for (String key:keySet)&#123; String[] values &#x3D; map.get(key); for (int i&#x3D;0;i&lt;values.length;i++)&#123; String value &#x3D; values[i]; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); values[i] &#x3D; value; &#125; &#125;map1.put(key,values); &#125; &#125; &#125; return map1; &#125; return method.invoke(req,args); &#125; &#125;); &#x2F;&#x2F;放行 chain.doFilter(proxy_req, resp); &#125; private List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F;敏感词汇 public void init(FilterConfig config) throws ServletException &#123; try &#123; &#x2F;&#x2F;获取文件真实路径 ServletContext context &#x3D; config.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;敏感词汇.txt&quot;); &#x2F;&#x2F;读取文件 BufferedReader br &#x3D; new BufferedReader(new FileReader(realPath)); &#x2F;&#x2F;将文件的每一行数据添加到list集合中 String line &#x3D; null; while ((line&#x3D;br.readLine())!&#x3D;null)&#123; list.add(line); &#125; br.close();&#x2F;&#x2F;释放资源 System.out.println(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Jetbrains系列产品2020.1最新激活方法","slug":"Jetbrains系列产品2020-1最新激活方法","date":"2020-04-15T03:56:11.000Z","updated":"2020-05-17T07:43:23.388Z","comments":true,"path":"2020/04/15/Jetbrains系列产品2020-1最新激活方法/","link":"","permalink":"http://yoursite.com/2020/04/15/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812020-1%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/","excerpt":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。","text":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。 大家熟知Jetbrains的话应该知道：他们家的所有产品升级到2018.2.1及以上版本后，先前可用的注册服务器都失效了，无法激活升级到最新版本体验最新黑科技。 这次要送的这份礼就是： Jetbrains全系列产品2020.1及以下版本（理论上适用于目前所有新老版本）最新注册服务器（License Server）的破解，可使用它来激活你手头上的Jetbrains IDE，具体支持产品和版本见下文的列表。 传送门: 百度云下载 提取码：w26y 使用方法: 0.先下载压缩包解压后得到jetbrains-agent.jar。 1.启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。 2.将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。（事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题） 3.在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。 4.重启IDE，搞定。 x. 支持两种注册方式：License server 和 Activation code: 1). 选择License server方式，地址填入：https://fls.jetbrains-agent.com （HTTP也可用，网络不佳用第2种方式） 2). 选择Activation code方式离线激活，请使用：ACTIVATION_CODE.txt 内的注册码激活 License key is in legacy format == Key invalid，表示agent配置未生效。 如果你需要自定义License name，请访问：https://zhile.io/custom-license.html 3). 现在你可以使用jetbrains-agent + activation code/license server激活jetbrains平台的付费插件了！ 现有Jetbrains付费插件Activation code: https://zhile.io/jetbrains-paid-plugins-license.html 现在有这些付费插件：https://plugins.jetbrains.com/search?isPaid=true 本项目在最新2020.1上测试通过。理论上适用于目前Jetbrains全系列所有新老版本。IDE升级会从旧版本导入以上设置，导入配置后可能提示未注册（因为刚导入的vmoptions未生效），直接重启IDE即可，无需其他操作。 本项目只做学习研究之用，不得用于商业用途！","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"BeanUtils工具类的使用","slug":"BeanUtils工具类的使用","date":"2020-04-11T07:17:27.000Z","updated":"2020-05-17T07:42:44.634Z","comments":true,"path":"2020/04/11/BeanUtils工具类的使用/","link":"","permalink":"http://yoursite.com/2020/04/11/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"BeanUtils工具类，简化数据封装","text":"BeanUtils工具类，简化数据封装 用于封装JavaBean的JavaBean：标准Java类要求： 1.类必须被public修饰 2.必须提供空参的构造器 3.成员变量必须使用private修饰 4.提供公共的setter和getter方法功能：封装数据下载点解链接下载 BeanUtils工具常用工具类有两个：BeanUtils、ConvertUtils。BeanUtils用于封装数据 方法 描述 BeanUtils对象 populate(Object bean, Map&lt;String,String[]&gt;properties) 将Map数据封装到指定Javabean中，一般用于将表单的所有数据封装到javabean setProperty(Object obj,String name,Object value) 设置属性值 getProperty(Object obj,String name) 获得属性值 代码123456789101112&#x2F;&#x2F;获取所有请求参数 Map&lt;String,String[]&gt; map &#x3D; req.getParameterMap (); &#x2F;&#x2F;创建User对象 User loginuser &#x3D; new User(); &#x2F;&#x2F;使用BeanUtils try &#123; BeanUtils.populate(loginuser,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"http的request对象和response对象","slug":"http","date":"2020-04-10T04:53:03.000Z","updated":"2020-05-17T07:43:05.982Z","comments":true,"path":"2020/04/10/http/","link":"","permalink":"http://yoursite.com/2020/04/10/http/","excerpt":"http的request对象和response对象","text":"http的request对象和response对象 概念：Hyper Text Transfer Protocol 超文本传输协议特点： 1.基于TCP/IP的高级协议 2.默认端口号8080 3.基于请求/相应模型：一次请求对应一次相应 4.无状态的：每次请求直接相互独立 请求消息的数据格式 1.请求行 请求方式 请求url 请求协议/版本 请求方式： GET 1.请求参数在请求行中，在url后面 2.请求url的长度有限 3.不太安全 POST 1.请求参数在请求体中 2.请求url长度没有限制 3.相对安全 2.请求头 3.请求空行 4.请求体 请求消息数据格式Request request和response对象的原理 1.request和response对象由服务器创建，我蛮来使用他们 2.request对象是来获取请求消息，response是来设置相应消息 request获取请求消息 获取请求行的数据 GET /test/demo1?name=zhangsan HTTP/1.1 1.获取请求方式 GET String getMethod() 2.获取虚拟目录 /test String getContextPath() 3.获取Servlet路径 /demo1 String getServletPath() 4.获取get方式请求传参 name=zhangsan String getQueryString() 5.获取URI /test/demo1 String getRequestURI() 6.获取协议及版本 HTTP/1.1 String getProtocol() 7.获取客户机的ip地址 String getRemoteAddr() 获取请求头的方法 String getHeader(String name)通过获取请求头的名称，获取请求头的值 获取请求体数据 只有post请求方式，才有请求体，在请求体中封装了post请求的请求参数 步骤： 1.获取流对象 BufferedReader getReader():获取字符输入流 ServletInputStream getInputStream():获取字节输入流 2.再从流对象中拿数据 获取请求参数的通用方法 1.String getParameter(String name):根据参数名称获取参数值 2.String[] getParameterValues(String name):根据参数名称获取参数值的数组 3.Enumeration&lt;String&gt; getParameterNames():获取所有请参数的名称 4.Map&lt;String,String[]&gt; getParameterMap():获取参数的所有Map集合12&#x2F;&#x2F;设置流的编码 防止乱码 req.setCharacterEncoding(&quot;utf-8&quot;); 请求转发：一种在服务器内部资源的跳转方式 步骤： 1.通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2.使用RequestDispatcher对象进行转发，forword(ServletRequest req,ServletRespnonse resp) 特点： 1.浏览器地址栏不发生变化 2.只能转发到当前服务器内部资源中 3.转发是一次请求 数据共享域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用域请求转发的多个资源中共享数据 方法： 1.void setAttribute(String name,Object obj):存储数据 2.Object getAttribute(String name):通过键获取值 3.void removeAttribute(String name):通过键来移除键值对获取ServletContext对象ServletContext getServletContext()响应消息相应消息的数据格式 1.相应行 组成：协议/版本 相应状态码 状态码描述 状态码分类： 1.1XX:服务器接收客户端消息，但没有接收完全，等待一段时间后，发送1XX 2.2XX:成功。200 3.3XX:重定向 302(重定向) 304(访问缓存) 4.4XX:客户端错误 404(请求路径没有对应的资源) 405(请求方式没有对应的doXXX方法) 5.5XX:服务器端错误 500(服务器内部出现异常) 2.相应头 1.格式:头名称:值 2.常见的相应头: 1.Content-Type:服务器告诉客户端本次相应体数据格式以及编码格式 2.Content-disposition:服务器告诉客户端以什么格式打开相应数据 3.相应空行 4.相应体 Response对象功能:设置相应消息 设置相应行 设置状态码:setStatus(int sc) 设置相应头 setHeader(String name,string value) 设置相应体 使用步骤: 1.获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 2.使用输出流，将数据输出到客户端浏览器 完成重定向代码实现 12&#x2F;&#x2F;简单的重定向的方法 resp.sendRedirect(&quot;&#x2F;ReaponseDemo_war_exploded&#x2F;responseDemo2&quot;); 特点: 1.地址栏发生变化 2.重定向可以访问其他站点 3.重定向是两次请求，不能使用request对象来共享数据 路径的写法 相对路径:不可以确定唯一资源 规则:.开头 找到当前资源和目标资源之间的相对位置关系 据对路径:可以确定唯一资源 服务器输出字符数据到浏览器步骤: 1.获取字符输出流 2.输出数据防止乱码 1234resp.setHeader(&quot;content-type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);&#x2F;&#x2F;简单的形式设计编码 resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); ServletContext对象1.概念:代表整个web应用，可以和程序的容器(服务器)通信 2.获取: 1.通过request对象获取request.getServletContext() 2.通过HttpServlet获取this.getServletContext 3.功能: 1.获取MIME类型 MIME类型:在互联网通信过程中定义的一种文件类型 格式:大类型/小类型 text/html 获取: `String getMineType(String file)` 代码示例 12345678ServletContext context &#x3D; this.getServletContext();&#x2F;&#x2F;定义文件名称String filename &#x3D; &quot;a.jpg&quot;;&#x2F;&#x2F;获取MIME类型String MimeType &#x3D; context.getMimeType(filename);System.out.println(MimeType); 2.域对象:共享数据 1.setAttribute(String name,String value) 2.getAttribute(String name) 3.removeAttribute(String name) ServletContext对象范围:所有用户请求的数据 3.获取文件的真实服务器路径 1.方法:String getRealPath() 案例文件下载需求: 1.页面显示超链接 2.点击链接后弹出下载提示框 3.完成图片文件下载123456789101112131415161718192021222324@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;获取请求参数 文件名称 String filename &#x3D; req.getParameter(&quot;filename&quot;); &#x2F;&#x2F;使用字节输入流，加载文件进内存 ServletContext context &#x3D; this.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;img&#x2F;&quot;+filename);&#x2F;&#x2F;获取文件真实路径 FileInputStream fis &#x3D; new FileInputStream(realPath); &#x2F;&#x2F;设置Response的相应头 String mineType &#x3D; context.getMimeType(filename);&#x2F;&#x2F;获取文件的MIME类型 resp.setHeader(&quot;content-type&quot;,mineType); resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename); &#x2F;&#x2F;将输入流的数据写出到输出流 ServletOutputStream sos &#x3D; resp.getOutputStream(); byte[] bytes &#x3D; new byte[1024]; int len &#x3D; 0; while ((len&#x3D;fis.read(bytes))!&#x3D;-1)&#123; sos.write(bytes,0,len); &#125; fis.close(); &#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"tomcat及Servlet","slug":"tomcat及Servlet","date":"2020-04-08T06:47:13.000Z","updated":"2020-05-17T07:44:01.625Z","comments":true,"path":"2020/04/08/tomcat及Servlet/","link":"","permalink":"http://yoursite.com/2020/04/08/tomcat%E5%8F%8AServlet/","excerpt":"Tomcat","text":"Tomcat 安装tomcat进入官网，个人推荐下载解压版，方便快捷 解压到工作目录后就可以使用了 进入bin目录 双击startup.bat linux打开.sh 可能遇到的两个问题 双击之后没有启动tomcat 黑窗口秒关闭—-JAVA_HOME的环境变量没有没配置好 运行日志乱码—-打开cd到tomcat/conf/目录下修改logging.properties找到 java.util.logging.ConsoleHandler.encoding = utf-8 这行将utf-8改为GBK 部署项目 1.直接将项目放到webapps目录下即可 /hello :项目访问的路径—-&gt;虚拟目录将项目打包成一个war包，再将war包放到webapps目录下 war包会自动解压 2.配置conf/server.xml 在标签体中配置 docBase：项目存放的路径 path:虚拟目录 3.在conf\\Catalina\\localhost创建任意名称的xml文件，在文件中编写 `&lt;Context docBase=&quot;D:\\hello&quot;&gt;` 虚拟目录就是文件的名称 静态项目和动态项目：目录结构： --项目的根目录 --WEB-INF目录 --web.xml:web项目的核心配置文件 --classes目录：放置字节码文件的目录 --lib目录：防止依赖的jar包Servlet 概念：server applet 运行在服务器端的小程序 servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则步骤：1.创建javaEE项目 2.定义一个类，实现Servlet接口 3.实现接口中的抽象方法 4.配置 Servlet---- 在web.xml中配置 配置代码12345678&lt;servlet&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;servlet-class&gt;cn.test.web.Servlet.ServletDemo1&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 执行原理 1.当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的Servlet的资源路径 2.查找web.xml文件，是否有对应的标签体内容 3.如果有，则再找到对应的全类名 4.tomcat会将字节码文件加载进内存，并创建其对象 5.调用方法Servlet的生命周期 1.被创建：执行init方法，只执行一次 2.提供服务：执行servlet方法，执行多次 3.被销毁：执行destroy方法，执行一次 Servlet3.0支持注解文件配置，可以不需要web.xml 步骤： 1.创建javaEE的项目，选择Servlet的版本 3.0以上，可以不勾选web.xml 2.定义一个类，实现Servlet接口 3.重写方法 4.在类上使用一个注解 @WebServlet(&quot;资源路径&quot;)Servlet的体系结构 Servlet 接口 GenericServlet 抽象类 将Servlet接口的其他方法做了默认实现，只将service()方法作为抽象 HttpServlet 抽象类 对HTPP协议的一种封装，简化操作 1.定义类继承HttpServlet 2.复写doGet/doPost方法 Servlet相关配置 1.urlpartten：Servlet访问的路径 1.一个Servlet可以定义多个访问路径:WebServlet({&quot;/d4&quot;,&quot;Demo4&quot;}) 2.路径的定义规则：/XXX，/XXX，*.do","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"XML解析器","slug":"XML解析器","date":"2020-04-07T11:24:23.000Z","updated":"2020-05-17T07:44:10.154Z","comments":true,"path":"2020/04/07/XML解析器/","link":"","permalink":"http://yoursite.com/2020/04/07/XML%E8%A7%A3%E6%9E%90%E5%99%A8/","excerpt":"解析：操作xml文档，将文档中的数据读取到内存中","text":"解析：操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式： DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树* 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 SAX：逐行读取，基于事件驱动的。* 优点：不占内存。 * 缺点：只能读取，不能增删改 xml常见的解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。快速入门：步骤： 1.导入jar包—-链接：https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw提取码：6sg6 下载完成后解压，将jsoup-1.11.2.jar 和 JsoupXpath-0.3.2.jar(后面Jsoup_Xpath查询会用到，现在一块导入) ，压缩包包括jsoup-1.11.2-javadoc、jsoup-1.11.2.jar、jsoup-1.11.2-javadoc.jar、jsoup-1.11.2-sources.jar、JsoupXpath-0.3.2.jar 2 获取Document对象 3.获取对应的标签Element对象 4.获取数据 代码 123456789101112131415161718192021222324252627282930313233343536373839404142import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;public class Demo1 &#123; public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F;获取Document对象，根据XML文档获取 &#x2F;&#x2F;获取student.xml的path String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); &#x2F;&#x2F;获取元素对象 Element Elements elements &#x3D; document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); &#x2F;&#x2F;获取第一个name的Element对象 Element element &#x3D; elements.get(0); &#x2F;&#x2F;获取数据 String name &#x3D; element.text(); System.out.println(name); &#125;&#125;&#96;&#96;&#96; studen.xml文件中的代码&#96;&#96;&#96;&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;utf-8&#39;?&gt;&lt;users&gt; &lt;user id&#x3D;&#39;1&#39;&gt; &lt;name id&#x3D;&quot;0001&quot;&gt;张三&lt;&#x2F;name&gt; &lt;age&gt;23&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt; &lt;user id&#x3D;&#39;2&#39;&gt; &lt;name&gt;李四&lt;&#x2F;name&gt; &lt;age&gt;30&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt;&lt;&#x2F;users&gt; 对象的使用：1. Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。 parse​(String html)：解析xml或html字符串 parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList来使用4. Element：元素对象 1.获取子元素对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式： selector:选择器 使用的方法：Elements select​(String cssQuery)cssQuery按照以前css选择器名字来做 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 示例代码： 1234567891011121314151617181920212223242526272829package Jsoup;import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;import cn.wanghaomiao.xpath.model.JXDocument;import cn.wanghaomiao.xpath.model.JXNode;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;import java.util.List;public class Demo5 &#123; public static void main(String[] args) throws IOException, XpathSyntaxErrorException &#123; String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); JXDocument jxDocument &#x3D; new JXDocument(document);&#x2F;&#x2F; List&lt;JXNode&gt; users &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;);&#x2F;&#x2F; for (JXNode j:users)&#123;&#x2F;&#x2F; System.out.println(j);&#x2F;&#x2F; &#125; List&lt;JXNode&gt; list &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;); for (JXNode jxNode:list)&#123; System.out.println(jxNode); &#125; &#125;&#125;","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"python爬虫","slug":"python爬虫","date":"2020-04-06T10:21:00.000Z","updated":"2020-05-17T07:43:40.587Z","comments":true,"path":"2020/04/06/python爬虫/","link":"","permalink":"http://yoursite.com/2020/04/06/python%E7%88%AC%E8%99%AB/","excerpt":"scrapy爬虫框架的安装","text":"scrapy爬虫框架的安装 用pip install scrapy命令安装会提示失败，是因为缺少twisted程序进入官网 按住ctrl+f 查找关键字下载好与python版本配对的文件用命令安装下载好的文件 注意路径最好不要太长 否则容易报错安装好插件以后用命令pip install scrapy安装框架安装好以后用命令’scrapy’查看版本出现以上代码说明安装成功","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"搭建个人博客及其部署","slug":"安装Hexo环境","date":"2020-04-06T08:17:01.000Z","updated":"2020-05-18T12:17:57.429Z","comments":true,"path":"2020/04/06/安装Hexo环境/","link":"","permalink":"http://yoursite.com/2020/04/06/%E5%AE%89%E8%A3%85Hexo%E7%8E%AF%E5%A2%83/","excerpt":"特别鸣up主CodeSheep","text":"特别鸣up主CodeSheep 基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。安装Node.js官网建议下载第一个安装步骤非常简单，一直next，下一步就可以了，默认安装就行。 安装git官网然后我们选择windows版本的下载安装也是一直点下一步，安装官方默认的来就行，安装完了，在开始菜单可以看到 安装hexo创建一个工作目录 比如在c盘建一个blog文件夹用管理员属性打开cmd cd到工作目录使用npm 安装hexonpm install -g hexo-cli输入hexo -v判断hexo是否安装成功输入hexo init初始化一个博客这里是hexo常用的命令 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 输入hexo s之后可以进入http://localhost:4000/这个地址查看我们的博客 部署服务器这里我们选用的部署到github上面首先新建一个github的仓库这里的name一定要填自己的用户名.github.io 不然会出问题去工作目录找到_config.yml这个文件 双击打开 我这里使用vscode打开的 用notepad++ 文本打开都可以红线换成自己的github用户名就行了 其他两行按照这个填写安装 hexo-deployer-git。npm install hexo-deployer-git --save部署一下就好了 123hexo cleanhexo ghexo d 这样你就可以通过自己的git仓库的域名访问你自己的博客了同样还可以部署在码云和coding上这个可以加快访问的速度 开启github pages服务，绑定域名如果你觉域名比较难记，可以自己去申请一个域名 这里我们以腾讯云为例，前提是我已经申请好了点击解析域名最好添加一个主机记录为@记录类型为CNAME类型，记录值写自己github仓库的地址名。 接下来配置github的 pages服务 找到博客对应的仓库，点击setting 下滑找到Github Pages，填入自己的域名，点击save保存 这样就可以通过自己的域名访问呢了","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}