{"meta":{"title":"张利源","subtitle":"","description":"但愿日子平静，抬头遇见的都是柔情","author":"张利源","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-17T08:00:27.682Z","updated":"2020-05-17T08:00:27.682Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-05-21T03:07:01.804Z","updated":"2020-05-21T03:07:01.804Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"欢迎添加我的QQ！！！ java小白一枚"},{"title":"我的朋友们","date":"2020-05-17T07:58:54.752Z","updated":"2020-05-17T07:58:54.752Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2020-05-17T07:56:17.193Z","updated":"2020-05-17T07:56:17.193Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Java JavaWeb 软件"},{"title":"所有分类","date":"2020-05-17T07:54:19.336Z","updated":"2020-05-17T07:54:19.336Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2020-12-21T08:34:15.000Z","updated":"2020-12-21T14:56:06.434Z","comments":true,"path":"2020/12/21/Docker学习笔记/","link":"","permalink":"http://yoursite.com/2020/12/21/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Docker学习笔记","text":"Docker学习笔记 虚拟机配置网络可以使用dhclint工具为虚拟机分配一个可用的ip 一.修改网络配置: vi /etc/sysconfig/network-scripts/ifcfg-ens33 2.输入i进入编辑模式，将最后一行的ONBOOT=no改为ONBOOT=yes 按Esc键，输入“：wq!”,保存并退出 然后重启网络，输入service network restart 输入ip addr查看ip Docker的历史有意思的是，Docker 公司起初是一家名为 dotCloud 的平台即服务（Platform-as-a-Service, PaaS）提供商。 底层技术上，dotCloud 平台利用了 Linux 容器技术。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的！ 2013年，dotCloud 的 PaaS 业务并不景气，公司需要寻求新的突破。于是他们聘请了 Ben Golub 作为新的 CEO，将公司重命名为“Docker”，放弃dotCloud PaaS 平台，怀揣着“将 Docker 和容器技术推向全世界”的使命，开启了一段新的征程。 如今 Docker 公司被普遍认为是一家创新型科技公司，据说其市场价值约为 10 亿美元。Docker 公司已经通过多轮融资，吸纳了来自硅谷的几家风投公司的累计超过 2.4 亿美元的投资。 几乎所有的融资都发生在公司更名为“Docker”之后。 提示：“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人。 Docker能干嘛 之前的虚拟机技术 虚拟机缺点 资源占用多 冗余步骤多 启动慢 容器化技术 容器化技术并不是一个完整的技术 一个容器包含了运行环境和应用，每个容器时互相隔离的，容器直接运行在操作系统之上，从分利用操作系统的资源。 Docker 是一个开源的应用容器引擎，基于Go语言并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 比较Docker和虚拟机不同： 传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，在这个系统上安装和操作软件。 容器内的应用直接运行在宿主机的内容，容器是没有内核的，也没有虚拟我们的硬件，所以是非常轻便的。 没有容器间是相互隔离的，每个容器都有属于自己的文件系统，互不影响。 DevOps(g发、运维) 更快速的交付和部署。 更便捷的升级和扩缩容。 更简单的系统运维。 更高效的计算机资源利用(Docker是内核级别的虚拟化) Docker的基本组成 镜像(image)镜像就是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建很多容器 容器(container)Docker利用容器独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启用，开始，停止，删除。每个容器都是相互隔离的，保证安全的平台。 可以把容器看作是一个简易版的Linux环境(包括root用户权限，进程空间，用户空间和网络空间等)和运行在其中的应用程序。 容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的 仓库(repository)仓库是集中存放镜像文件的场所。 仓库和仓库注册服务器(Registry)是有区别的，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签 仓库分为公开仓库(public)和私有仓库(private)两种形式 最大的开放仓库是Docker Hub： https://hub.docker.com/ 存放了数量庞大的镜像供用户下载。 国内的公开仓库包括阿里云，网易云等 安装Docker查看系统内核 12[root@MiWiFi-R4A-srv /]# uname -r3.10.0-1062.el7.x86_64 查看系统版本 12345678910111213141516[root@MiWiFi-R4A-srv /]# cat /etc/os-release NAME=\"CentOS Linux\"VERSION=\"7 (Core)\"ID=\"centos\"ID_LIKE=\"rhel fedora\"VERSION_ID=\"7\"PRETTY_NAME=\"CentOS Linux 7 (Core)\"ANSI_COLOR=\"0;31\"CPE_NAME=\"cpe:/o:centos:centos:7\"HOME_URL=\"https://www.centos.org/\"BUG_REPORT_URL=\"https://bugs.centos.org/\"CENTOS_MANTISBT_PROJECT=\"CentOS-7\"CENTOS_MANTISBT_PROJECT_VERSION=\"7\"REDHAT_SUPPORT_PRODUCT=\"centos\"REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 卸载旧的版本 12345678910111213141516171819202122232425262728293031323334353637383940414243# 卸载旧版本$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 需要的安装包sudo yum install -y yum-utils# 设置镜像的仓库sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 更新yum软件包索引yum makecache fast# 安装docker相关 docker-ce社区版 ee版企业版sudo yum install docker-ce docker-ce-cli containerd.io# 启动dockersudo systemctl start docker# 使用docker -version查看是否安装成功docker -version# hello world程序docker run hello-world# 查看镜像[root@MiWiFi-R4A-srv ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtomcat latest 6d15a1d68603 7 days ago 649MBmysql 8.0.22 ab2f358b8612 8 days ago 545MBmysql latest ab2f358b8612 8 days ago 545MBredis latest ef47f3b6dc11 8 days ago 104MBcentos centos7 8652b9f0cb4c 5 weeks ago 204MBhello-world latest bf756fb1ae65 11 months ago 13.3kB 卸载Docker 12345# 卸载依赖$ sudo yum remove docker-ce docker-ce-cli containerd.io# 删除资源$ sudo rm -rf /var/lib/docker 阿里云镜像加速 1234567891011sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://n1p195zp.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 底层原理Docker是怎么工作的？ Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 DockerServer接收到Docker-Client的指令，就会执行这个命令。 为什么Docker比VM快？ Docker有着虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上Docker将会有明显优势。 Docker利用的是宿主机的内核，而不需要GuestOS，因此，当新建一个容器时Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载GuestOS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker只需几秒钟。 Docker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 Docker的常用命令帮助命令123docker --version # 显示Docker的版本信息docker info # 显示Docker的系统信息，包括镜像和容器的数量docker --help # 帮助命令 镜像命令123docker images # 查看本地所有镜像docker images -a # 列出本地所有的镜像（含中间映像层）docker images -q # 只显示id 12docker search mysql # 搜索镜像docker search mysql --filter=STARS=3000 # 过滤只搜索3000satr以上的 12docker pull mysql # 如果不写tag，默认latest最新版docker pull mysql:5.7 # 指定版本下载 1docker rmi 697daaecf703 # Docker删除镜像 容器命令有镜像才能创建容器，下载一个centos镜像来学习。 1docker pull centos 新建容器并启动 123456789101112131415161718docker run [可选参数] image# 参数说明--name=\"NAME\" 容器名字，用来区别容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p -p 8080:8080 -p 主机端口:容器端口(常用) -p 容器端口 容器端口-P 随机指定端口# 测试docker run -it centos /bin/bash# 从容器退回主机exit 列出所有正在运行的容器 12345678910[root@MiWiFi-R4A-srv /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES581a17d041b4 centos \"/bin/bash\" 3 minutes ago Up 3 minutes nice_roentgendocker ps -a # 列出所有容器docker ps -a -n=1 # 显示最近创建的容器docker ps -aq # 显示当前容器的编号 退出容器 12exit # 直接容器停止并退出Ctrl + P + Q # 容器不停止退出 删除容器 12docker rm 容器id # 删除指定的容器，不能删除正在运行的容器docker rm -f $(docker ps -ap) # 删除所有的容器 启动和停止容器操作 1234docker start容器id # 启动容器docker restart 容器id # 重启容器docker stop 容器id # 停止容器docker kill 容器id #强制停止当前容器 常用其他命令后台启动容器 123docker run -d centos# docker ps发现centos停止了# 常见的坑，dokcer容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 查看日志 1docker logs -f -t --tail 容器id 查看容器中进程信息 123[root@MiWiFi-R4A-srv ~]# docker top 847858ee8a4aUID PID PPID C STIME TTY TIME CMDroot 5967 5947 0 22:28 ? 00:00:00 /bin/bash 查看镜像的元数据 1docker inspect 847858ee8a4a","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"Dubbo和Zookeeper集成","slug":"Dubbo和Zookeeper集成","date":"2020-10-24T03:01:19.000Z","updated":"2020-10-24T07:02:32.995Z","comments":true,"path":"2020/10/24/Dubbo和Zookeeper集成/","link":"","permalink":"http://yoursite.com/2020/10/24/Dubbo%E5%92%8CZookeeper%E9%9B%86%E6%88%90/","excerpt":"分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。","text":"分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 什么是RPC框架RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； dubbo基本概念 服务提供者(Provider):暴露服务的服务提供发，服务提供者启动时，向注册中心注册自己提供的服务 服务消费者(Consumer):调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己锁需要的服务，服务消费者从提供者列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选用另一台 注册中心(Register):注册中心返回服务提供者地址列表给服务消费者，如果有变更，注册中心将基于长连接推送变更数据给数据消费者 监控中心(Moiter):服务消费者和提供者，在内存累计调用次数和调用时间，定义每分钟发送一次统计数据到监控中心 使用Dubbo-admindubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。 地址 ：https://github.com/apache/dubbo-admin/tree/master 下载完成后解压,修改dubbo-admin-server下的配置文件，修改成我们自己的配置即可 将这个项目达成jar包 mvn clean package -Dmaven.test.skip=true 用java -jar启动就好了 访问localhost:8080 测试环境搭建Linux安装zookeeper xftp上传zookeeper到根目录 解压zookeeper到指定目录 tar -zxvf zookeeper-3.4.6.tar.gz -C /usr/local/ 进入zookeeper目录 cd zookeeper-3.4.6 创建data目录 mkdir data 进入conf目录 cd conf 重命名/拷贝zoo_sample.cfg,修改为zoo.cfg mv zoo_sample.cfg zoo.cfg vim进入zoo.cfg文件 vim zoo.cfg 修改zoo.cfg文件 修改datadir=/usr/local/zookeeper-3.4.6/data注意:使用i进入修改模式,修改后使用esc退出修改,输入:wq退出vim 操作zookeeper1.启动进入bin目录下,执行./zkServer.sh start 2.停止./zkServer.sh stop 3.查看状态./zkServer.sh status SpringBoot+dubbo+zookeeper编写服务提供者 导入依赖 12345678910111213141516171819202122232425262728293031323334353637&lt;!--dubbo--&gt;&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 编写service接口 12345678package com.gem.service;/** * @author zhang * @date 2020/10/24 13:43 */public interface HelloService &#123; String sayHello(String name);&#125; 编写实现类 这里注意@Service注解使用的是dubbo的而非spring提供的，loadbalance表示负载均衡，interfaceClass指定接口 12345678910111213141516package com.gem.service.impl;import com.gem.service.HelloService;import org.apache.dubbo.config.annotation.Service;/** * @author zhang * @date 2020/10/24 13:50 */@Service(loadbalance = \"random\",interfaceClass = HelloService.class)public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return \"Hello,\" + name; &#125;&#125; 配置文件 12345678#当前应用名称dubbo.application.name=dubbo-prodiver#注册中心地址dubbo.registry.address=zookeeper://192.168.40.130:2181#扫描指定包下的服务dubbo.scan.base-packages=com.gem.service#服务器端口server.port=9999 编写服务消费者 导入依赖 同上 编写service接口 同上 配置文件 123456789101112#当前应用名称dubbo: application: name: dubbo-consumer registry: address: zookeeper://192.168.40.130:2181 scan: base-packages: com.gem.controllerserver: port: 8888 编写Controller 我们要使用服务提供者的服务，使用@Reference注解去注册中心查找服务 123456789101112131415161718192021222324package com.gem.controller;import com.gem.service.HelloService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @author zhang * @date 2020/10/24 13:58 */@Controllerpublic class HelloController &#123; //到注册中心查找服务 @Reference(check = false,loadbalance = \"random\") HelloService helloService; @RequestMapping(\"/hello\") @ResponseBody public String sayHello(String name)&#123; return helloService.sayHello(name); &#125;&#125; 测试启动服务器，访问呢服务消费者的controller","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot集成editor.md","slug":"SpringBoot集成editor-md","date":"2020-10-13T12:21:23.000Z","updated":"2020-10-13T12:52:52.811Z","comments":true,"path":"2020/10/13/SpringBoot集成editor-md/","link":"","permalink":"http://yoursite.com/2020/10/13/SpringBoot%E9%9B%86%E6%88%90editor-md/","excerpt":"SpringBoot集成editor.md Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费。","text":"SpringBoot集成editor.md Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费。 基础工程搭建article：文章表 字段 类型 备注 id int 文章的唯一ID author varchar 作者 title varchar 标题 content longtext 文章的内容 建表SQL： 1234567CREATE TABLE `article` (`id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'int文章的唯一ID',`author` varchar(50) NOT NULL COMMENT '作者',`title` varchar(100) NOT NULL COMMENT '标题',`content` longtext NOT NULL COMMENT '文章的内容',PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 实体类 123456789101112//文章类@Data@NoArgsConstructor@AllArgsConstructorpublic class Article implements Serializable &#123; private int id; //文章的唯一ID private String author; //作者名 private String title; //标题 private String content; //文章的内容&#125; mapper接口 12345678910111213141516@Mapper@Repositorypublic interface ArticleMapper &#123; //查询所有的文章 List&lt;Article&gt; queryArticles(); //新增一个文章 int addArticle(Article article); //根据文章id查询文章 Article getArticleById(int id); //根据文章id删除文章 int deleteArticleById(int id);&#125; 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.kuang.mapper.ArticleMapper\"&gt; &lt;select id=\"queryArticles\" resultType=\"Article\"&gt; select * from article &lt;/select&gt; &lt;select id=\"getArticleById\" resultType=\"Article\"&gt; select * from article where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=\"addArticle\" parameterType=\"Article\"&gt; insert into article (author,title,content) values (#&#123;author&#125;,#&#123;title&#125;,#&#123;content&#125;); &lt;/insert&gt; &lt;delete id=\"deleteArticleById\" parameterType=\"int\"&gt; delete from article where id = #&#123;id&#125; &lt;/delete&gt; &lt;/mapper&gt; 文章编辑整合下载好的项目结构 进入examples文件夹css和js文件夹粘到项目的static文件夹下，另外粘贴项目根目录下的css文件夹的editormd.css和js文件夹下的editormd.js，最后把整个lib也粘贴过来。 项目路径 编辑文章页面 editor.html、需要引入 jQuery； 需要修改css和js的路径，和path的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html class=\"x-admin-sm\" lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi\" /&gt; &lt;!--Editor.md--&gt; &lt;link rel=\"stylesheet\" th:href=\"@&#123;/css/style.css&#125;\"&gt; &lt;link rel=\"stylesheet\" th:href=\"@&#123;/css/editormd.css&#125;\"/&gt; &lt;link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"layui-fluid\"&gt; &lt;div class=\"layui-row layui-col-space15\"&gt; &lt;div class=\"layui-col-md12\"&gt; &lt;!--博客表单--&gt; &lt;form name=\"mdEditorForm\"&gt; &lt;div&gt; 标题：&lt;input type=\"text\" name=\"title\"&gt; &lt;/div&gt; &lt;div&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt; &lt;/div&gt; &lt;div id=\"article-content\"&gt; &lt;textarea name=\"content\" id=\"content\" style=\"display:none;\"&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;!--editormd--&gt;&lt;script th:src=\"@&#123;/js/jquery.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/js/editormd.js&#125;\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var testEditor; //window.onload = function()&#123; &#125; $(function() &#123; testEditor = editormd(\"article-content\", &#123; width : \"100%\", height : 600, syncScrolling : \"single\", path : \"../lib/\", saveHTMLToTextarea : true, // 保存 HTML 到 Textarea emoji: true, theme: \"default\",//工具栏主题 previewTheme: \"default\",//预览主题 editorTheme: \"pastel-on-default\",//编辑主题 tex : true, // 开启科学公式TeX语言支持，默认关闭 flowChart : true, // 开启流程图支持，默认关闭 sequenceDiagram : true, // 开启时序/序列图支持，默认关闭, //图片上传 imageUpload : true, imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"], imageUploadURL : \"/article/file/upload\", onload : function() &#123; console.log('onload', this); &#125;, /*指定需要显示的功能按钮*/ toolbarIcons : function() &#123; return [\"undo\",\"redo\",\"|\", \"bold\",\"del\",\"italic\",\"quote\",\"ucwords\",\"uppercase\",\"lowercase\",\"|\", \"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"|\", \"list-ul\",\"list-ol\",\"hr\",\"|\", \"link\",\"reference-link\",\"image\",\"code\",\"preformatted-text\", \"code-block\",\"table\",\"datetime\",\"emoji\",\"html-entities\",\"pagebreak\",\"|\", \"goto-line\",\"watch\",\"preview\",\"fullscreen\",\"clear\",\"search\",\"|\", \"help\",\"info\",\"releaseIcon\", \"index\"] &#125;, /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/ toolbarIconTexts : &#123; releaseIcon : \"&lt;span bgcolor=\\\"gray\\\"&gt;发布&lt;/span&gt;\", index : \"&lt;span bgcolor=\\\"red\\\"&gt;返回首页&lt;/span&gt;\", &#125;, /*给自定义按钮指定回调函数*/ toolbarHandlers:&#123; releaseIcon : function(cm, icon, cursor, selection) &#123; //表单提交 mdEditorForm.method = \"post\"; mdEditorForm.action = \"/article/addArticle\";//提交至服务器的路径 mdEditorForm.submit(); &#125;, index : function()&#123; window.location.href = '/'; &#125;, &#125; &#125;); &#125;);&lt;/script&gt;&lt;/html&gt; 编写Controller，进行跳转，以及保存文章 123456789101112131415@Controller@RequestMapping(\"/article\")public class ArticleController &#123; @GetMapping(\"/toEditor\") public String toEditor()&#123; return \"editor\"; &#125; @PostMapping(\"/addArticle\") public String addArticle(Article article)&#123; articleMapper.addArticle(article); return \"editor\"; &#125;&#125; 图片上传问题js中添加 1234//图片上传imageUpload : true,imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],imageUploadURL : \"/article/file/upload\", // //这个是上传图片时的访问地址 后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.66&lt;/version&gt;&lt;/dependency&gt; controller 1234567891011121314151617181920212223242526272829303132333435//博客图片上传问题 @RequestMapping(\"/file/upload\") @ResponseBody public JSONObject fileUpload(@RequestParam(value = \"editormd-image-file\", required = true) MultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 //获得SpringBoot当前项目的路径：System.getProperty(\"user.dir\") String path = System.getProperty(\"user.dir\")+\"/upload/\"; //按照月份进行分类：// Calendar instance = Calendar.getInstance();// String month = (instance.get(Calendar.MONTH) + 1)+\"月\";// path = path+month; File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //解决文件名字问题：我们使用uuid; String filename = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ filename)); //给editormd进行回调 JSONObject res = new JSONObject(); res.put(\"url\",\"/upload/\"+\"/\"+ filename); res.put(\"success\", 1); res.put(\"message\", \"upload success!\"); return res; &#125; 解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！ 123456789101112@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; // 文件保存在真实目录/upload/下， // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/upload/**\") .addResourceLocations(\"file:\"+System.getProperty(\"user.dir\")+\"/upload/\"); &#125;&#125; 文章展示controller增加方法 123456@GetMapping(\"/&#123;id&#125;\")public String show(@PathVariable(\"id\") int id,Model model)&#123; Article article = articleMapper.getArticleById(id); model.addAttribute(\"article\",article); return \"article\";&#125; 编写页面 article.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;title th:text=\"$&#123;article.title&#125;\"&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt; &lt;h2 style=\"margin: auto 0\" th:text=\"$&#123;article.title&#125;\"&gt;&lt;/h2&gt; 作者：&lt;span style=\"float: left\" th:text=\"$&#123;article.author&#125;\"&gt;&lt;/span&gt; &lt;!--文章主体内容--&gt; &lt;div id=\"doc-content\" style=\"width: 80%;margin-left: 10%\"&gt; &lt;textarea style=\"display:none;\" placeholder=\"markdown\" th:text=\"$&#123;article.content&#125;\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt;&lt;link rel=\"stylesheet\" th:href=\"@&#123;/editormd/css/editormd.preview.css&#125;\" /&gt;&lt;script th:src=\"@&#123;/js/jquery.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/marked.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/prettify.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/raphael.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/underscore.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/sequence-diagram.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/flowchart.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/jquery.flowchart.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/js/editormd.js&#125;\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var testEditor; $(function () &#123; testEditor = editormd.markdownToHTML(\"doc-content\", &#123;//注意：这里是上面DIV的id htmlDecode: \"style,script,iframe\", emoji: true, taskList: true, tocm: true, tex: true, // 默认不解析 flowChart: true, // 默认不解析 sequenceDiagram: true, // 默认不解析 codeFold: true &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同样需要修改js和css","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot笔记","slug":"SpringBoot笔记","date":"2020-10-12T13:20:28.000Z","updated":"2020-10-14T10:57:57.216Z","comments":true,"path":"2020/10/12/SpringBoot笔记/","link":"","permalink":"http://yoursite.com/2020/10/12/SpringBoot%E7%AC%94%E8%AE%B0/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 Spring优缺点优点：Spring是java企业级的轻量代替品，Spring为企业级java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的java对象实现了EJB的功能。 缺点：虽然Spring的组件是轻量级的，但是Spring的配置文件确实重量级的，此外项目的依赖管理也是一件耗时耗力的事。 Spring的概述SpringBoot对上述Spring的缺点进行了改善了优化，基于约定由于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中。 SpringBoot的优点 为基于Spring的代码开发提供了更快的入门体验 开箱即用，没有代码生成，也无需xml配置，同时可以修改默认值来满足特定的需求 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器，安全，指标，健康检测，外部配置等。 SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式 SpringBoot的核心功能 起步依赖 起步依赖本质上是一个Maven项目对象模型，定义了对其他库的传递依赖，这些东西加载一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 自动配置 SpringBoot的自定配置是一个运行的过程，考虑了众多元素，才决定Spring配置中应该用哪个，不该用哪个，该过程是SpringBoot自动完成的。 SpringBoot原理分析起步依赖按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）： 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt; 按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）： 12345678910111213141516171819202122&lt;properties&gt; &lt;activemq.version&gt;5.15.13&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.82&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.12.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.6&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.16.1&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;awaitility.version&gt;4.0.3&lt;/awaitility.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;build-helper-maven-plugin.version&gt;3.1.0&lt;/build-helper-maven-plugin.version&gt; &lt;byte-buddy.version&gt;1.10.14&lt;/byte-buddy.version&gt; &lt;caffeine.version&gt;2.8.5&lt;/caffeine.version&gt; &lt;cassandra-driver.version&gt;4.6.1&lt;/cassandra-driver.version&gt; &lt;classmate.version&gt;1.5.1&lt;/classmate.version&gt; &lt;commons-codec.version&gt;1.14&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.7.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.10&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; &lt;commons-pool2.version&gt;2.8.1&lt;/commons-pool2.version&gt; &lt;couchbase-client.version&gt;3.0.8&lt;/couchbase-client.version&gt; &lt;db2-jdbc.version&gt;11.5.4.0&lt;/db2-jdbc.version&gt; 从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分的坐标版本、管理依赖、插件管理已经定义好了，所有我们的SpringBoot工程继承spring-boot-stater-parent后已经具备版本锁定等配置了。所有起步依赖的作用就是进行依赖的传递。 自动配置按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication 1234567@SpringBootApplicationpublic class Springdemo02Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Springdemo02Application.class, args); &#125;&#125; 注解@SpringBootApplication的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @AliasFor( annotation = EnableAutoConfiguration.class ) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor( annotation = EnableAutoConfiguration.class ) String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackages\" ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackageClasses\" ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = \"nameGenerator\" ) Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true;&#125; 其中，@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类@EnableAutoConfiguration：SpringBoot自动配置功能开启按住Ctrl点击查看注解@EnableAutoConfiguration 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; SpringBoot工程热部署在pom.xml中添加(也可在创建SpringBoot项目的时候勾选) 1234567&lt;!-- 热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 对idea进行配置 然后 Shift+Ctrl+Alt+/，选择Registry 勾选 SpringBoot配置文件SpringBoot是基于约定的，所有很多配置都有默认值，但如果相使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml进行配置。 自定义配置配置文件与配置类的映射方式 123person: name: zhangsan age: 20 使用@Value来映射我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上 1234567891011121314151617181920/** * @author zhang * @date 2020/10/10 9:39 */@Controllerpublic class HelloController &#123; @Value(\"$&#123;person.name&#125;\") private String name; @Value(\"$&#123;person.age&#125;\") private int age; @ResponseBody @RequestMapping(\"/index\") public String index()&#123; System.out.println(name + \"---------\" + age); return \"Hello Spring Boot\"; &#125;&#125; 使用@ConfigurationProperties先导入依赖 12345&lt;dependency&gt; &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt;&lt;/dependency&gt; 测试类(提供set方法) 12345678910111213141516171819202122232425262728/** * @author zhang * @date 2020/10/10 9:39 */@Controller@ConfigurationProperties(prefix = \"person\")public class HelloController &#123; private String name; private int age; @ResponseBody @RequestMapping(\"/index\") public String index()&#123; System.out.println(name + \"---------\" + age); return \"Hello Spring Boot\"; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 整合Myabtis添加Mybatis起步依赖和数据库驱动 123456789101112&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt;&lt;/dependency&gt; 在application.yml中添加数据库配置信息 1234567#数据源spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/study?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8 username: root password: root 在application.yml中添加mybatis配置信息 12345678#mybatis配置mybatis: #别名 type-aliases-package: com.gem.springdemo1.entity #扫描mapper mapper-locations: classpath:com/gem/springdemo1/mapper/*Mapper.xml configuration: log-impl: org.apache.ibatis.logging.log4j.Log4jImpl SpringBoot默认使用logback作为日志打印工具，我们要想查看sql语句，需要使用log4j 导入log4j的起步依赖 12345678910111213&lt;!-- log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;!-- 修复重复绑定报红的问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 在application.yml中配置 123mybatis: configuration: log-impl: org.apache.ibatis.logging.log4j.Log4jImpl 整合Junit添加依赖 123456&lt;!-- 测试启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在测试类上加上对应的注解 12@SpringBootTest(classes = Springdemo1Application.class)@RunWith(SpringRunner.class) 静态资源在SpringBoot中有四个目录可以放我们的静态资源 - &quot;classpath:/META-INF/resources/&quot; - &quot;classpath:/resources/&quot; - &quot;classpath:/static/&quot; - &quot;classpath:/public/&quot;例如 网站图标的说明 与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。 1、关闭SpringBoot默认图标 12#关闭默认图标spring.mvc.favicon.enabled=false 2、自己放一个图标在静态资源目录下 Thymeleaf模板引擎jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。SpringBoot推荐你可以来使用模板引擎 引入Thymeleaf 12345&lt;!-- thymeleaf模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 创建一个Controller，model添加一个User实体，返回hello.html 12345678910111213141516/** * @author zhang * @date 2020/10/12 9:42 */@Controllerpublic class HelloController &#123; @RequestMapping(\"/index\") public String index(Model model)&#123; User user = new User(1L,\"张三\",new Date()); model.addAttribute(\"user\",user); model.addAttribute(\"num\",10); model.addAttribute(\"gender\",\"w\"); return \"hello\"; &#125;&#125; 在hello.html中获取数据 在html中引入Thymeleaf 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 在标签中取值使用th:text(写在标签体中)，使用#datas.format来格式化时间 处理字符串和数字类型同理 12345&lt;div&gt; &lt;p th:text=\"$&#123;user.id&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;user.username&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;#dates.format(user.createDate,'yyyy-MM-dd HH:mm:ss')&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 如果是表单标签使用th:value设置值 1&lt;input type=\"text\" th:value=\"$&#123;user.id&#125;\"&gt; 单选框使用th:attr设置属性 12&lt;input name=\"gender\" type=\"radio\" th:attr=\"checked=$&#123;gender eq 'm'?true:false&#125;\"&gt;男 &lt;input name=\"gender\" type=\"radio\" th:attr=\"checked=$&#123;gender eq 'w'?true:false&#125;\"&gt;女 if123456&lt;div&gt; &lt;p th:if=\"$&#123;num == 10&#125;\"&gt;num:10&lt;/p&gt; &lt;p th:if=\"$&#123;num == 20&#125;\"&gt;num:20&lt;/p&gt; &lt;p th:if=\"$&#123;num == 30&#125;\"&gt;num:30&lt;/p&gt;&lt;/div&gt; switch case12345&lt;div th:switch=\"$&#123;num&#125;\"&gt; &lt;p th:case=\"10\"&gt;num为10&lt;/p&gt; &lt;p th:case=\"20\"&gt;num为20&lt;/p&gt; &lt;p th:case=\"30\"&gt;num为30&lt;/p&gt;&lt;/div&gt; each编写一个controller，模拟数据查询到的list 1234567891011121314151617181920/** * @author zhang * @date 2020/10/12 15:54 */@Controller@RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/userList\") public String userList(Model model)&#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L,\"张三\",new Date())); list.add(new User(2L,\"李四\",new Date())); list.add(new User(3L,\"王五\",new Date())); list.add(new User(4L,\"赵六\",new Date())); list.add(new User(5L,\"田七\",new Date())); model.addAttribute(\"userList\",list); return \"user\"; &#125;&#125; html代码 1234567891011121314151617&lt;table&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"u:$&#123;userList&#125;\"&gt; &lt;td th:text=\"$&#123;u.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.username&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(u.createDate,'yyyy-MM-dd')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href=\"@&#123;/user/edit(id=$&#123;u.id&#125;)&#125;\" th:text=\"编辑\"&gt;&lt;/a&gt; &lt;a th:href=\"@&#123;'/user/delete/' + $&#123;u.id&#125;&#125;\" th:text=\"删除\"&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; url、href、src问题，原始？传参版本使用th:href动态的写，参数使用()传递 1&lt;a th:href=\"@&#123;/user/edit(id=$&#123;u.id&#125;)&#125;\" th:text=\"编辑\"&gt;&lt;/a&gt; Controller 12345@RequestMapping(\"/edit\")public String editUser(int id)&#123; System.out.println(\"要修改的id是\" + id); return \"user\";&#125; Rest风格 1&lt;a th:href=\"@&#123;'/user/delete/' + $&#123;u.id&#125;&#125;\" th:text=\"删除\"&gt;&lt;/a&gt; Controller 12345@RequestMapping(\"/delete/&#123;id&#125;\")public String deleteUser(@PathVariable(\"id\") int id)&#123; System.out.println(\"要删除的id是:\" + id); return \"user\";&#125; 使用{参数}表示展位符，使用@pathVaiable注解获取url中占位符，并且绑定到方法的参数上。 引入css 1&lt;link rel=\"stylesheet\" th:href=\"@&#123;/css/style.css&#125;\"&gt; 全局异常处理@ControllerAdvice搭配@ExceptionHandler注解 123456789101112@ControllerAdvicepublic class WebException &#123; @ExceptionHandler(value = Exception.class) public ModelAndView defaultException(Exception e, HttpServletRequest request)&#123; ModelAndView mv=new ModelAndView(); mv.setViewName(\"error\"); //异常对象 mv.addObject(\"exception\",e); //异常请求 mv.addObject(\"url\",request.getRequestURI()); return mv; &#125; 拦截器springboot拦截器和springmvc一样，自己定义一个类实现HandlerInterceptor接口，实现其中的preHandle方法就可以了。 12345678910111213141516171819202122232425262728293031323334public class WebInterceptor implements HandlerInterceptor &#123; /** * * @param request * @param response * @param handler * @return * @throws Exception * * 登录验证： * 拦截所有请求 * 对于登录请求放行 * 非登录请求进行登录验证（currUser是否为空） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String uri=request.getRequestURI(); System.out.println(uri); if(uri.endsWith(\"/login\")||uri.endsWith(\"/toLogin\")||uri.endsWith(\"/\"))&#123; //登录请求 放行 return true; &#125; // HttpSession session=request.getSession(); Object user=session.getAttribute(\"currUser\"); if(user==null)&#123; //未登录 //跳转到登录页 response.sendRedirect(request.getContextPath()+\"/toLogin\"); return false; &#125; return true; &#125;&#125; 重要的是拦截器的配置。 自己定义一个配置类，打上@Configuration注解，实现WebMvcConfigurer接口,重写addInterceptors方法,注意静态资源要剔除掉。 1234567891011@Configurationpublic class WebMvc implements WebMvcConfigurer &#123; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new WebInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/css/**\") .excludePathPatterns(\"/js/**\") .excludePathPatterns(\"/images/**\"); &#125;&#125; 给指定视图添加控制层同样写一个配置类，实现WebMvcConfigurer接口，实现addViewControllers方法 123456789101112131415@Configurationpublic class WebMvc implements WebMvcConfigurer &#123; /** * * @param registry * registry给指定的视图添加控制层 * login */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //http://localhost:8088/ProductWeb/ registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/toLogin\").setViewName(\"login\"); &#125;&#125; 文件上传和配置本地静态资源路径配置本地服务器路径为静态路径 注意原来的静态资源路径也要配置进去，自己本地的路径前要加file 1234567spring: #将图片服务器路径配置为静态路径 resources: static-locations: classptah:/static/,classpath:/public/,classpath:/resource/,file:$&#123;imgFile&#125;#图片的访问路径imgFile: D:\\a_demo\\img 上传文件页面 修改表单的类型为multipart/form-data 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=\"@&#123;/file/upload&#125;\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"imgFile\"&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文件上传Controller，上传完毕进行展示 12345678910111213141516171819202122232425262728293031323334/** * @author zhang * @date 2020/10/14 9:20 */@Controller@RequestMapping(\"/file\")public class FileUploadController &#123; @Value(\"$&#123;imgFile&#125;\") private String targetPath; @RequestMapping(\"/uploadPage\") public String uploadPage()&#123; return \"/upload/fileupload\"; &#125; @RequestMapping(\"/upload\") public String upload(MultipartFile imgFile, Model model) throws IOException &#123; //获取文件名称，包含上传文件的后缀 String fileName = imgFile.getOriginalFilename(); //获取文件上传的后缀名 assert fileName != null; String suffix = fileName.substring(fileName.lastIndexOf(\".\")); //文件重命名 fileName = UUID.randomUUID().toString().replace(\"-\",\"\").toLowerCase() + suffix; System.out.println(\"上传的文件名称:\"+fileName); System.out.println(\"上传的路径\" + targetPath); //上传 imgFile.transferTo(new File(targetPath,fileName)); model.addAttribute(\"path\",fileName); return \"upload/show\"; &#125; 可以默认上传的文件大小 1234567spring: servlet: multipart: #单文件大小 max-file-size: 10MB #总文件大小 max-request-size: 100MB 整合Mybatis分页插件 PageHelper导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; 剩下的和Mybatis一样，设置分页参数，封装PageInfo对象即可。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2020-09-29T13:12:05.000Z","updated":"2020-09-29T13:13:48.554Z","comments":true,"path":"2020/09/29/SpringMVC/","link":"","permalink":"http://yoursite.com/2020/09/29/SpringMVC/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 三层架构和MVC三层架构表现层：也就是我们常说的web层，它负责接收客户端请求，向客户端相应结果，，通常客户端使用http请求web层。 业务层：也就是我们说的service层，负责逻辑业务处理，和我们开发项目的需求息息相关，web层依赖于业务层，但业务层不依赖于web层。 持久层：也就是我们常说的dao层，负责数据持久化。通俗的讲，持久层就是和数据库交互，对数据库表进行增删改查。 MVC模型 全名Model View Controller，是模型，视图，和控制器的缩写，是一种用于设计创建web应用程序表现层的模式。是一种软件设计规范。 是将业务逻辑，数据，显示分离的方式来阻止代码。 MVC的主要作用是降低视图和业务逻辑之间的双向耦合 MVC不是一种设计模式，是一种架构模式 Model(模型)：通常指我们的数据模型，作用一般情况下用于封装数据。 View(视图)：负责进行模型的展示，通常指我们的jsp或者html。 Controller(控制器)：接收请求，委托给模型处理，，处理完毕后把返回的模型数据返回给视图，由视图负责展示。 SpringMVC Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 SpringMVC的特点: 轻量级，简单易学 高效，基于请求的相应的MVC框架 与Spring兼容性好，无缝结合 约定大于配置 功能强大:restful、数据验证、格式化、本地化、主题等 简单灵活 SpringMVC和Structs2的优略分析共同点: ​ 他们都是表现层框架，都是基于MVC模型编写的。 ​ 他们的底层都离不开原始的ServletAPI ​ 它们处理请求的机制都是一个核心控制器 区别: ​ SpringMVC的入口是Servlet和Structs2是Filter ​ SpringMVC基于方法设计的，而Structs是基于类，Structs2每次执行都会创建一个动作类，所有SpringMVC会稍比Structs2快些。 ​ SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 ​ SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。 ​ pring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高 入门程序修改web.xml，配置DispatherServlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;!--配置SpringMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc配置文件(XML配置文件)--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--容器启动时就创建前端控制器对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置全局过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 注意：/ 和 /* 的区别 &lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错 配置mvc配置文件 mvc.xml类似于spring配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--mvc注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置mvc扫描包--&gt; &lt;context:component-scan base-package=\"com.gem.controller\"/&gt; &lt;!--配置静态资源处理--&gt;&lt;!-- &lt;mvc:resources mapping=\"/asserts/**\" location=\"/asserts/\"/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--拦截路径--&gt; &lt;mvc:mapping path=\"/test/**\"/&gt; &lt;!--剔除拦截--&gt; &lt;mvc:exclude-mapping path=\"/test/test2\"/&gt; &lt;bean class=\"com.gem.interceptor.MyInterceptor\" id=\"myInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!--配置文件上传解析器--&gt; &lt;bean class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\" id=\"multipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt; &lt;/bean&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--指定视图类型(JSP),可以省略--&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--视图前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;!--视图后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建Controller，打上@Controller和@RequestMapping注解 测试 @RequestMapping注解@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 属性 value表示映射路径 method表示触发该路径的方式,指定哪种方式就只能通过该方式触发，触发方法不对，报405异常。 params表示请求中必须含有的参数，如果没有该参数则报400异常。 注意:可以使用XXXMapping来替代RequestMapping(method=XXX) 1234567@RequestMapping(value = \"/index\", method = RequestMethod.GET, params = &#123;\"id\"&#125;)public String index(Long id) &#123; System.out.println(\"请求中的参数为: \" + id); // 视图解析器会作用在这个index前后自动拼接完整跳转路径 // 默认使用转发跳转 return \"index\";&#125; 可以接收基本类型，String类型和pojo类型，如果我们传入一个实体类，SpringMVC会自动帮我们封装成一个对象(参数列表必须要和实体类字段对应，不然为null)。 静态资源过滤问题 方式一 12&lt;!--配置静态资源处理--&gt;&lt;mvc:resources mapping=\"/asserts/**\" location=\"/asserts/\"/&gt; 方式二 1&lt;mvc:default-servlet-handler/&gt; 方式三(使用tomcat默认servlet来解决) web.xml中添加 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 表单提交乱码问题post方式提交表单会出现中文乱码问题，这时候我们想要配置springMVC自带的过滤器，可以在web.xml中配置。 12345678910111213141516171819&lt;!--配置字符集过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--配置过滤器使用UTF-8字符集--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--强制使用该字符集过滤器设置--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 处理日期类型参数在需要处理的实体类字段打上@DateTimeFormat注解，pattern属性传入要格式化的字符串。 123//参数绑定字符串和日期转换注解@DateTimeFormat(pattern = \"yyyy-MM-dd\")private LocalDate createDate; 常用注解RequestParam修饰绑定的参数 value 表示参数名称，用来对应方法的形参，默认和方法的形参同名 required 表示参数是否是必须参数，默认值为true，表示该参数必须要有 defaultValue 表示如果没有传入该参数，则使用默认值。 required=false，defaultValue = “XXX”连用 123456@GetMapping(\"/index4\")public String index4(@RequestParam(value = \"sname\", required = false, defaultValue = \"admin\") String name, int age) &#123; System.out.println(name); System.out.println(age); return\"success\";&#125; 运行结果 RequestBody修饰属性,用来获取请求体中的数据,即参数键值 required 表示是否是必须的,默认是true 注意:此注解只能通过post请求触发才能获取响应数据,不支持get请求 12345@PostMapping(\"/index5\")public String index5(@RequestBody(required = false) String body) &#123; System.out.println(body); return \"success\";&#125; PathVariable表示在URL中使用占位符来指定方法形参，它是后面我们使用Restful风格URL的基础 12345@GetMapping(\"/index6/&#123;id&#125;\")public String index6(@PathVariable(\"id\") Long id) &#123; System.out.println(id); return \"success\";&#125; 运行结果 RequestHeader获取请求头中指定key对应的value值 12345@GetMapping(\"/header\")public String header(@RequestHeader(\"User-Agent\") String header) &#123; System.out.println(header); return \"success\";&#125; 访问路径 localhost:8888/mvc/hello/header 运行结果 CookieValue表示获取Cookie中指定名称的值 12345@GetMapping(\"/cookie\")public String cookie(@CookieValue(\"JSESSIONID\") String cookieValue) &#123; System.out.println(cookieValue); return \"success\";&#125; ModelAttribute该注解是SpringMVC4.3版本后新加入的，它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行前执行，它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。当表单提交数据不是完整的实体类数据时，保证没有提交数据字段使用数据库原来对象的数据。 123456789101112@ModelAttributepublic void showModel(User user) &#123; System.out.println(\"HelloMvc.testModelAttribute\"); System.out.println(user); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");&#125;@GetMapping(\"/testma\")public String testModelAttribute(@ModelAttribute(\"user\") User user) &#123; System.out.println(user); return \"success\";&#125; model对象多个页面中数据共享使用Model对象。 它相当于request请求作用域,如果想要联动操作session,则可以在类上面使用@SessionAttributes注解,该注解可以把放入到model中的数据,同等的放入到session中 1234567891011//Session操作@SessionAttributes(&#123;\"message\"&#125;)public class HelloMvc &#123; @RequestMapping(\"/index10\") public ModelAndView index10()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"message\",\"Hello\"); modelAndView.setViewName(\"success\"); return modelAndView; &#125;&#125; jsp使用el表达式提取 12$&#123;requestScope.message&#125;$&#123;sessionScope.message&#125; 结果 如果要在控制器的方法中获取session,则可以使用model.get(“”)来获取如果要清空session,则可以在控制器方法参数中传入SessionStatus对象,然后调用该对象的setComplete()方法即可 restful风格url由于浏览器的form表单只支持GET与POST请求，而delete、put等方法不支持，Spring3.0添加了一个过滤器，可以将浏览器请求改为指定的请求方式，使得支持get、post、put、delete请求 使用方法： 1.在web.xml中配置该过滤器 123456789&lt;!--配置Rest请求URL方式转换过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.请求方式必须使用post请求 3.按照要求提供_method请求参数，该参数的取值就是我们的请求方式 12345678910&lt;form action=\"user/1\" method=\"post\"&gt; &lt;%--&lt;input type=\"text\" name=\"username\"/&gt; &lt;input type=\"password\" name=\"password\"/&gt;--%&gt; &lt;%--设置请求方式--%&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"&gt; &lt;input type=\"text\" name=\"id\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 4.对应Controller 123456789101112131415161718192021222324252627282930313233343536373839404142package com.gem.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;/** * 本类用来演示Restful风格URL * * 查询 /user/1 GET * 删除 /user/1 DELETE * 修改 /user/1 PUT * 添加 /user POST */@Controller@RequestMapping(\"/user\")public class RestController &#123; //localhost:8888/mvc/user/1 @GetMapping(\"/&#123;id&#125;\") public String select(@PathVariable(\"id\") Long id) &#123; System.out.println(\"执行查询操作的id:\" + id); return \"success\"; &#125; //localhost:8888/mvc/user @PostMapping public String add() &#123; System.out.println(\"执行添加操作\"); return \"success\"; &#125; //localhost:8888/mvc/user/1 @DeleteMapping(\"/&#123;id&#125;\") public String delete(@PathVariable(\"id\") Long id) &#123; System.out.println(\"执行删除操作的id:\" + id); return \"success\"; &#125;&#125; SpringMVC方法返回Json数据1.导入jackson jar包(Spring内置转换就是基于jackson) 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; 2.在控制器对应方法上添加注解@ResponseBody ​ @ResponseBody放在方法上,表示该方法返回纯数据,即不是视图名称 ​ @ResponseBody放在类上,则表示该类中所有的方法返回的都是纯数据 @ResponseBody + @Controller = @RestController 123456789@RestControllerpublic class JsonController &#123; @GetMapping(\"/json\") public User getData() &#123; User user = new User(1L, \"admin\", \"123456\"); return user; &#125;&#125; 访问http://localhost:8888/mvc/json 运行结果 SpringMVC文件上传 引入maven依赖(commons-fileupload+commons-io) 123456&lt;!--文件上传组件--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 提供form表单(post,multipart/form-data,file表单控件) 1234567891011121314&lt;%@ page contentType=\"text/html; charset=UTF-8\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMVC文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 图片：&lt;input type=\"file\" name=\"uploadFile\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Controller 1234567891011121314151617181920@Controllerpublic class UploadController &#123; @PostMapping(\"/upload\") public String upload(MultipartFile uploadFile) throws IOException &#123; //定义文件名 String fileName = \"\"; //1.获取原始文件名 String uploadFileName = uploadFile.getOriginalFilename(); //2.截取文件扩展名 String extendName = uploadFileName.substring(uploadFileName.lastIndexOf(\".\") + 1, uploadFileName.length()); //3.把文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\").toUpperCase(); fileName = uuid + \".\" + extendName; //4.判断路径是否存在 File file = new File(\"D:/a_dmeo/img/\" + fileName); //5.使用MulitpartFile接口中方法，把上传的文件写到指定位置 uploadFile.transferTo(file); return \"success\"; &#125; 配置文件上传解析器 1234&lt;!--配置文件上传解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt;&lt;/bean&gt; 全局异常处理 方式一(web.xml配置错误页面) 12345&lt;!--web全局异常处理--&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/pages/error.jsp&lt;/location&gt;&lt;/error-page&gt; 方式二 123456789101112/**全局异常处理增强类*/@ControllerAdvicepublic class ExceptionAdvice &#123; @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) // 响应 状态码500 // @ExceptionHandler 参数为 要处理器的 异常类(或子类) // 注解参数不声明指定异常类，则默认为方法列表中的异常参数类 @ExceptionHandler(ArithmeticException.class) public String showInfo(Exception e) &#123; System.out.println(e.getMessage()); return \"error\"; &#125;&#125; 拦截器SpringMVC的拦截器类似于Servlet开发中的过滤器Filter，拦截器只会拦截访问控制器的方法，不会拦截静态资源。 步骤 编写一个普通的实现类实现HandlerInterceptor接口 在mvc.xml中配置拦截器 可以配置要剔除的路径。 多个拦截器的执行顺序 两个拦截器同时拦截一个请求 SSM整合pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.gem&lt;/groupId&gt; &lt;artifactId&gt;ssmdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssmdemo Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.2.9.RELEASE&lt;/spring.version&gt; &lt;tomcat.version&gt;7.0.86&lt;/tomcat.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;version&gt;2.7.19&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssmdemo&lt;/finalName&gt; &lt;!-- 将mapper.xml一起打包 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/ssm&lt;/path&gt; &lt;port&gt;8888&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;staticContextPath&gt;/img&lt;/staticContextPath&gt; &lt;staticContextDocbase&gt;D:\\a_demo\\img&lt;/staticContextDocbase&gt; &lt;contextReloadable&gt;false&lt;/contextReloadable&gt; &lt;useTestClasspath&gt;true&lt;/useTestClasspath&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-util&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-coyote&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jasper&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jasper-el&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-el-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-tribes&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina-ha&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-juli&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-logging-juli&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-logging-log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!--添加配置跳过测试--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--添加配置跳过测试--&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; spring配置文件 spring.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--导入外部配置文件--&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;context:component-scan base-package=\"com.gem.service\"/&gt; &lt;!--配置AOP注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--开启声明式事务--&gt; &lt;tx:annotation-driven/&gt; &lt;!--配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;mysql_driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;mysql_url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;mysql_user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;mysql_password&#125;\"/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactoryBean--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--绑定数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--配置mybatis--&gt; &lt;property name=\"configuration\"&gt; &lt;bean class=\"org.apache.ibatis.session.Configuration\"&gt; &lt;property name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;property name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;property name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.gem.entity\"/&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"defaultEnumTypeHandler\" value=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\"/&gt; &lt;/bean&gt; &lt;!--配置Mapper扫描器--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.gem.mapper\"/&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt;&lt;/beans&gt; mvc配置文件 mvc.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--mvc注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置mvc扫描包--&gt; &lt;context:component-scan base-package=\"com.gem.controller\"/&gt; &lt;!--配置默认跳转--&gt; &lt;mvc:view-controller path=\"/\" view-name=\"user/login\"/&gt; &lt;!--配置静态资源处理--&gt; &lt;mvc:resources mapping=\"/asserts/**\" location=\"/asserts/\"/&gt; &lt;!--配置文件上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt; &lt;/bean&gt; &lt;!--配置拦截器--&gt; &lt;!--&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &amp;lt;!&amp;ndash;拦截路径&amp;ndash;&amp;gt; &lt;mvc:mapping path=\"/**\"/&gt; &amp;lt;!&amp;ndash;剔除拦截&amp;ndash;&amp;gt; &lt;mvc:exclude-mapping path=\"\"/&gt; &lt;bean class=\"com.gem.interceptor.AdminInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;--&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--指定视图类型(JSP),可以省略--&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--视图前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;!--视图后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; log4j配置文件log4j.properties 12345678# \\u5168\\u5C40\\u65E5\\u5FD7\\u914D\\u7F6Elog4j.rootLogger=WARN, stdout# \\u63A7\\u5236\\u53F0\\u8F93\\u51FAlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n# MyBatis \\u65E5\\u5FD7\\u914D\\u7F6Elog4j.logger.com.gem.mapper=DEBUG mybatis缓存配置文件ehcache.xml 1234567891011121314151617181920212223&lt;ehcache&gt; &lt;!--二级缓存存储路径--&gt; &lt;diskStore path=\"D:\\java\\ehcache\"/&gt; &lt;!-- maxElementsInMemory 内存中存储缓存对象的最大值 maxElementsOnDisk 磁盘中存储缓存对象的最大值 eternal 缓存对象是否是永久的 overflowToDisk 缓存对象是否允许被写到磁盘中 timeToIdleSeconds 缓存对象最大空闲时间,超时将被销毁 timeToLiveSeconds 缓存对象最长存活时间,超时将被销毁 --&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"true\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"600\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 数据库配置文件db.properties 1234mysql_driver=com.p6spy.engine.spy.P6SpyDrivermysql_url=jdbc:p6spy:mysql:///ssm?serverTimezone=GMT%2B8mysql_user=rootmysql_password=root p6spy配置文件spy.properties 1234mysql_driver=com.p6spy.engine.spy.P6SpyDrivermysql_url=jdbc:p6spy:mysql:///ssm?serverTimezone=GMT%2B8mysql_user=rootmysql_password=root web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;!--web全局异常处理--&gt; &lt;!--&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/pages/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/pages/error.jsp&lt;/location&gt; &lt;/error-page&gt;--&gt; &lt;!--配置session过期时间(分钟)--&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!--配置spring容器监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--指定spring配置文件路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置SpringMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc配置文件(XML配置文件)--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--容器启动时就创建前端控制器对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置字符集过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--配置过滤器使用UTF-8字符集--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--强制使用该字符集过滤器设置--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置Rest请求URL方式转换过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Mybatis巩固","slug":"Mybatis巩固","date":"2020-09-22T10:35:24.000Z","updated":"2020-09-24T10:51:04.225Z","comments":true,"path":"2020/09/22/Mybatis巩固/","link":"","permalink":"http://yoursite.com/2020/09/22/Mybatis%E5%B7%A9%E5%9B%BA/","excerpt":"Mybatis再学习","text":"Mybatis再学习 Mybatis工具类(线程安全版本)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.gem.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.Reader;/** * @author zhang * @date 2020/9/22 9:34 */public class MybatisUtil &#123; private static SqlSessionFactory sqlSessionFactory = null; private static ThreadLocal&lt;SqlSession&gt; threadLocal = new ThreadLocal(); static &#123; try &#123; Reader reader = Resources.getResourceAsReader(\"sqlMapConfig.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 获取SqlSessionFactory * @return */ public static SqlSessionFactory getSqlSessionFactory()&#123; return sqlSessionFactory; &#125; /** * 新建一个Sqlsession对象，并且把他放入线程变量中 */ private static void newSqlSession()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(true); threadLocal.set(sqlSession); &#125; /** * 获取sqlSession * @return */ public static SqlSession getSqlSession()&#123; SqlSession sqlSession = threadLocal.get(); if (sqlSession ==null)&#123; newSqlSession(); sqlSession = threadLocal.get(); &#125; return sqlSession; &#125; /** * 关闭sqlSession对象，并且从线程变量中删除 */ public static void closeSqlSession()&#123; //获取线程变量中的SqlSession对象 SqlSession sqlSession = threadLocal.get(); //判断 if (sqlSession != null)&#123; sqlSession.close(); threadLocal.set(null); &#125; &#125;&#125; 配置别名给整个包下的所有类配置别名，默认首字符大小写都可以 1234&lt;!--别名--&gt;&lt;typeAliases&gt; &lt;package name=\"com.gem.entity\"/&gt;&lt;/typeAliases&gt; 配置类型处理器实体类存在枚举类型 12345678910111213/** * @author zhang * @date 2020/9/21 16:50 */@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private Integer id; private String name; private LocalDate birthday; private Gender gender;&#125; 1234567/** * @author zhang * @date 2020/9/21 16:50 */public enum Gender &#123; MALE,FEMALE;&#125; 数据库存的是枚举的下标0，1 ，直接查询会报错 这是因为mybatis提供了两种枚举处理器，默认情况下是EnumTypeHandler(字符串)，我们需要修改默认的枚举处理器，使用下标来实现 1234&lt;!--枚举下标--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\" javaType=\"com.gem.entity.Gender\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 引入外部配置文件我们可以使用properties标签来引入外部文件，将数据库的配置文件分离开来。 12&lt;!--引入外部配置文件 --&gt;&lt;properties resource=\"db.properties\"/&gt; 使用log4j实现日志功能导入log4j依赖 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 导入log4j配置文件 12345678# \\u5168\\u5C40\\u65E5\\u5FD7\\u914D\\u7F6Elog4j.rootLogger=WARN, stdout# \\u63A7\\u5236\\u53F0\\u8F93\\u51FAlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n# MyBatis \\u65E5\\u5FD7\\u914D\\u7F6Elog4j.logger.com.gem.mapper=DEBUG 使用p6spy探测sql语句上面我们可以看出使用Log4j输出的日志信息并没有完整的sql语句，想要查看完整的sql语句 ，我们需要使用第三方工具p6spy 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt;&lt;/dependency&gt; 替换mysql驱动 123&lt;!--使用p6spy探测SQL语句,替换原有驱动--&gt;&lt;!--&lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;--&gt;&lt;property name=\"driver\" value=\"com.p6spy.engine.spy.P6SpyDriver\"/&gt; 修改url 12&lt;!--并且修改url--&gt;&lt;property name=\"url\" value=\"jdbc:p6spy:mysql:///study?serverTimezone=GMT%2B8\"/&gt; P6Spy是一个可以用来在应用程序中拦截和修改数据操作语句的开源框架。 通过P6Spy我们可以对SQL语句进行拦截，相当于一个SQL语句的记录器，这样我们可以用它来作相关的分析，比如性能分析。 P6SPY提供了如下几个功能： 记录SQL语句的执行时间戳。 记录SQL语句类型 记录SQL填入参数的和没有填入参数的SQL语句 根据配置的时间控制SQL语句的执行时间，对超出时间的SQL语句输出到日志文件中 #{} 和 ${} 需求:通过姓名模糊查询 1List&lt;Student&gt; selectStudentsByName(String name); 两种实现方式 123&lt;select id=\"selectStudentsByName\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student where name like concat('%',#&#123;name&#125;,'%');&lt;/select&gt; 123&lt;select id=\"selectStudentsByName\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student where name like '%$(name)%';&lt;/select&gt; 虽然两种方法都可以实现，但是${}是不可取的 #{}是预编译处理，$ {}是字符串替换。使用 #{} 可以有效的防止SQL注入，提高系统安全性。 当然在在某些特殊的场合下只能使用${},不能用#{}。例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成ORDER BY “id”,这显然是一种错误的写法。 动态SQL通过mybatis提供的各种标签方法实现动态拼接sql。 if需求：更新用户信息 1int updateStudent(Student student); 正常写法 1234&lt;update id=\"updateStudent\"&gt; update mybatis_student set name = #&#123;name&#125;,birthday = #&#123;birthday&#125;,gender = #&#123;gender&#125; where id = #&#123;id&#125;&lt;/update&gt; 如果我们不想修改name属性并没有设置name属性，这时候就会把数据库更新为null，这就不符合要求了。这时候就需要使用if标签进行判断了 1234567891011121314151617&lt;!--更新--&gt; &lt;!--动态SQL语句--&gt; &lt;update id=\"updateStudent\"&gt; update mybatis_student set id=#&#123;id&#125; &lt;if test=\"name !=null and name!=''\"&gt; ,name=#&#123;name&#125; &lt;/if&gt; &lt;if test=\"birthday !=null and birthday!=''\"&gt; ,birthday=#&#123;birthday&#125; &lt;/if&gt; &lt;if test=\"gender !=null and gender!=''\"&gt; ,gender=#&#123;gender&#125; &lt;/if&gt; &lt;where&gt; id=#&#123;id&#125; &lt;/where&gt; &lt;/update&gt; where需求：按多个要求查找 1List&lt;Student&gt; selectStudentsByConditions(@Param(\"name\") String name, @Param(\"gender\")Gender gender); 这个正常实现 12345678910&lt;select id=\"selectStudentsByConditions\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student where &lt;if test=\"name != null and name != ''\"&gt; and name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender != null\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 传入两个参数没有问题，但是如果我们只传入最后一个参数就会解析有问题，多出一个and这时候就需要使用where标签 123456789101112&lt;select id=\"selectStudentsByConditions\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; and name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender != null\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where标签会自动帮我们去除第一个and，保证sql语句的正确解析。 foreach向sql传递数组或者list，mybatis使用foreach解析 需求：传入一个list，查找id在其中的student 1List&lt;Student&gt; selectStudentsByIds(@Param(\"ids\") List&lt;Long&gt; ids); 12345678910&lt;select id=\"selectStudentsByIds\" resultType=\"Student\"&gt; select * from mybatis_student &lt;where&gt; &lt;if test=\"ids != null and ids.size &gt; 0\"&gt; &lt;foreach collection=\"ids\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; collection 表示迭代的集合或者数组 open 表示迭代开始的内容 close 表示迭代结束的内容 item 表示迭代的每一个项 separator 表示迭代间隔符 SQL片段Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下： 原本sql 123456789101112&lt;select id=\"selectStudentsByConditions\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; and name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender != null\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 我们可以将where条件抽取成sql片段 1234567891011&lt;!--定义SQL片段--&gt; &lt;sql id=\"query_student_condition\"&gt; &lt;where&gt; &lt;if test=\"name!=null and name!=''\"&gt; and name=concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender!=null\"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; 使用include引入 1234567&lt;select id=\"selectStudentsByConditions\" resultType=\"Student\"&gt; select * from mybatis_student &lt;!--引用SQL片段--&gt; &lt;!--注意:如果想要引用其他xml文件中的SQL片段,必须指定全名(命名空间+sqlid)--&gt; &lt;include refid=\"query_student_condition\"&gt;&lt;/include&gt; &lt;/select&gt; 关联查询一对一husband和wife实体 1234567@Datapublic class Husband &#123; private Integer id; private String name; private Wife wife;&#125; 12345@Datapublic class Wife &#123; private Integer id; private String name;&#125; 需求：级联查询，如果通过姓名查询丈夫，如果丈夫有妻子则一起查出 1Husband selectHusbandByName(String name); 实现 12345678910111213&lt;resultMap id=\"husbandAndWife\" type=\"Husband\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;!--关联绑定--&gt; &lt;association property=\"wife\" javaType=\"Wife\"&gt; &lt;id property=\"id\" column=\"wid\"/&gt; &lt;result property=\"name\" column=\"wname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectHusbandByName\" resultMap=\"husbandAndWife\"&gt; select h.id,h.name,w.id wid,w.name wname from mybatis_husband h left join mybatis_wife w on h.wife_id = w.id where h.name = #&#123;name&#125;&lt;/select&gt; 一对一使用association标签，property表示实体类字段，column表述数据库字段，使用javaType属性 一对多顾客和订单实体 1234567@Datapublic class Customer &#123; private Long id; private String name; // 体现一对多关系 private List&lt;Order&gt; orders;&#125; 123456@Datapublic class Order &#123; private Long id; private String orderno; private Double price;&#125; 需求：根据客户名查询客户,如果该客户有订单,则级联查询该客户的订单信息 1Customer selectCustomerAndOrders(String name); 实现 12345678910111213141516171819&lt;mapper namespace=\"com.gem.mapper.CustomerMapper\"&gt; &lt;resultMap id=\"customerAndOrdersMap\" type=\"Customer\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!--一对多关系绑定--&gt; &lt;collection property=\"orders\" ofType=\"Order\"&gt; &lt;id property=\"id\" column=\"oid\"/&gt; &lt;result property=\"orderno\" column=\"orderno\"/&gt; &lt;result property=\"price\" column=\"price\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectCustomerAndOrders\" resultMap=\"customerAndOrdersMap\"&gt; select c.id, c.name, o.id oid, o.orderno, o.price from hbm_customer c left join hbm_order o on o.customer_id = c.id where c.name = #&#123;name&#125; &lt;/select&gt; 一对多使用collection标签，使用ofType表示多端类型 多对多用户和角色实体 12345678@Datapublic class User &#123; private Long id; private String username; private String password; // 多对多 private List&lt;Role&gt; roles;&#125; 1234567@Datapublic class Role &#123; private Long id; private String roleName; // 多对多 private List&lt;User&gt; users;&#125; 需求：根据姓名查询用户信息,并且级联查询出用户的角色 1User selectUserAndRoles(String name); 实现 123456789101112131415161718&lt;mapper namespace=\"com.gem.mapper.UserMapper\"&gt; &lt;resultMap id=\"userAndRolesMap\" type=\"User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;collection property=\"roles\" ofType=\"Role\"&gt; &lt;id property=\"id\" column=\"rid\"/&gt; &lt;result property=\"roleName\" column=\"roleName\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectUserAndRoles\" resultMap=\"userAndRolesMap\"&gt; select u.id, u.username, u.password, r.id rid, r.roleName from mybatis_user u join mybatis_ur ur on ur.user_id = u.id join mybatis_role r on ur.role_id = r.id where u.username = #&#123;username&#125; &lt;/select&gt; 需要关联一张中间表，多对多和一对多一致。 获取自增id的值实体对应上面的客户表 1int insertCustomer(Customer customer); 123&lt;insert id=\"insertCustomer\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into hbm_customer(name) value (#&#123;name&#125;)&lt;/insert&gt; useGeneratedKeys属性设置为true，keyProperty设置为id 测试类 1234567@Testpublic void insertCustomer() &#123; Customer customer = new Customer(); customer.setName(\"张三\"); mapper.insertCustomer(customer); System.out.println(\"id为----&gt;\" + customer.getId());&#125; 输出结果 我们还可以通过&lt;selectKey&gt;实现 123456&lt;insert id=\"insertCustomer\" parameterType=\"Customer\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into hbm_customer(name) value (#&#123;name&#125;)&lt;/insert&gt; 延迟加载打开延迟加载开关 设置项 描述 允许值 默认值 lazyLoadingEnabled 全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。 true | false false aggressiveLazyLoading 当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。 true | false true 在mybatis核心配置文件中配置： 1234567&lt;!--延迟加载--&gt;&lt;settings&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--关闭积极加载--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 实现 需求：根据姓名查询丈夫信息,如果该丈夫有妻子,则延迟加载妻子的信息 Mapper接口中的两个方法 123Husband selectHusbandAndWifeLazy(String name);Wife selectWifeById(Long id); xml的实现 12345678910111213141516&lt;resultMap id=\"lazyHusbandAndWife\" type=\"Husband\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!-- association,collection中使用select标签调用其他查询来实现延迟加载 --&gt; &lt;association property=\"wife\" javaType=\"Wife\" select=\"selectWifeById\" column=\"id\"&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectHusbandAndWifeLazy\" resultMap=\"lazyHusbandAndWife\"&gt; select * from mybatis_husband where name = #&#123;name&#125;;&lt;/select&gt;&lt;select id=\"selectWifeById\" resultType=\"com.gem.entity.Wife\"&gt; select * from mybatis_wife where husband_id = #&#123;id&#125;&lt;/select&gt; 于正常级联查询不同，将原本一个sql分为两个单独sql，但是不同的是查询丈夫的时候，并没有返回丈夫的实体，而是返回了一个resultMap，association标签也并没有去绑定实体，而是去引用另一个sql，association本身提供懒加载功能 测试 我们只打印丈夫的name 1System.out.println(husband.getName()); sql语句并没有执行查询妻子的部分 尝试输出妻子的信息 1System.out.println(husband.getWife()); 两句sql都有执行 小结 ​ 当需要查询关联信息时再去数据库查询，默认不去关联查询，提高数据库性能。 ​ 只有使用resultMap支持延迟加载设置。 场合： ​ 当只有部分记录需要关联查询其它信息时，此时可按需延迟加载，需要关联查询时再向数据库发出sql，以提高数据库性能。 ​ 当全部需要关联查询信息时，此时不用延迟加载，直接将关联查询信息全部返回即可，可使用resultType或resultMap完成映射。 查询缓存Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。 Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存 一级缓存 测试 1234567891011121314/** * 测试一级缓存 默认开启 */@Testpublic void testFirstLevelCache()&#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); Student s1 = mapper.selectStudentById(1); System.out.println(s1); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); Student s2 = mapper.selectStudentById(1); System.out.println(s2); System.out.println(s1 == s2);&#125; 二级缓存 二级缓存区域是根据mapper的namespace划分的，相同namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解为二级缓存区域是根据mapper划分。 每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。 Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象 sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。 开启二级缓存 描述 允许值 默认值 cacheEnabled 对在此配置文件下的所有cache 进行全局性开/关设置。 true false true 在核心配置文件SqlMapConfig.xml中加入 1234&lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 要在你的Mapper映射文件中添加一行：&lt;cache /&gt; ，表示此mapper开启二级缓存 二级缓存需要查询结果映射的实体对象实现java.io.Serializable接口实现序列化和反序列化操作，注意如果存在父类、成员pojo都需要实现序列化接口。 测试就可以实现了 使用ehcache实现二级缓存 引入maven依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 导入ehcahe的xml配置文件 1234567891011121314151617181920212223242526272829303132&lt;ehcache&gt; &lt;!--二级缓存存储路径--&gt; &lt;diskStore path=\"D:\\a_demo\\ehcache\"/&gt; &lt;!-- maxElementsInMemory 内存中存储缓存对象的最大值 maxElementsOnDisk 磁盘中存储缓存对象的最大值 eternal 缓存对象是否是永久的 overflowToDisk 缓存对象是否允许被写到磁盘中 timeToIdleSeconds 缓存对象最大空闲时间,超时将被销毁 timeToLiveSeconds 缓存对象最长存活时间,超时将被销毁 --&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"true\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"600\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt; &lt;!--可以配置多套缓存配置--&gt; &lt;!-- &lt;cache name=\"myCache1\"&gt; maxElementsInMemory=\"1000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"600\"&gt; &lt;/cache&gt;--&gt;&lt;/ehcache&gt; 在需要开启二级缓存的mapper文件中添加 12&lt;!--使用ehcache缓存--&gt;&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt;&lt;/cache&gt; 测试 1234567891011121314151617@Testpublic void testSecondLevelCache()&#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); Student s1 = mapper.selectStudentById(1); System.out.println(s1); MybatisUtil.closeSqlSession(); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); sqlSession = MybatisUtil.getSqlSession(); mapper = sqlSession.getMapper(StudentMapper.class); Student s2 = mapper.selectStudentById(1); System.out.println(s2); System.out.println(s1 == s2); MybatisUtil.closeSqlSession();&#125; 在第一次查询完毕过后，关闭sqlsession再次查询 pagehelper分页插件 导入maven依赖 123456&lt;dependency&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 在mybatis核心配置文件中添加插件 12345678&lt;!--mybatis插件配置--&gt;&lt;plugins&gt; &lt;!--pagehelper分页插件--&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt; &lt;property name=\"helperDialect\" value=\"mysql\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; mapper定义查询全部的方法 123public interface ProvinceMapper &#123; List&lt;Province&gt; selectAllProvinces();&#125; 1234&lt;select id=\"selectAllProvinces\" resultType=\"Province\"&gt; select * from province&lt;/select&gt; service层 12345678910public PageInfo&lt;Province&gt; selectAllProvincesByPage(int pageNow,int pageSize)&#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); ProvinceMapper mapper = sqlSession.getMapper(ProvinceMapper.class); //设置分页参数 PageHelper.startPage(pageNow,pageSize,true); List&lt;Province&gt; provinces = mapper.selectAllProvinces(); PageInfo&lt;Province&gt; pageInfo = new PageInfo&lt;&gt;(provinces); return pageInfo;&#125; 定义方法返回pageInfo对象，设置分页参数，pageInfo构造方法传入全部数据的集合即可 测试 123456789@Testpublic void selectAllProvincesByPage() &#123; PageInfo&lt;Province&gt; pageInfo = provinceService.selectAllProvincesByPage(1, 5); System.out.println(\"总页码\" + pageInfo.getPages()); System.out.println(\"每页显示条数\"+pageInfo.getPageSize()); pageInfo.getList().forEach(System.out::println); System.out.println(\"是否有下一页\" + pageInfo.isHasNextPage()); System.out.println(\"是否是第一页\" + pageInfo.isIsFirstPage());&#125; 逆向工程通用mapper 导入Maven依赖 123456&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.1.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 实体类配置 1234567891011@Data@Table(name = \"gem_person\")public class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; private String phone; private String qq; private String address;&#125; 需要在实体类上使用table注解指定数据库，使用id注解标明主键，自增字段需要加GeneratedValue，类似于Hibernate 编写mapper接口 123456/** * @author zhang * @date 2020/9/24 10:23 */public interface PersonMapper extends Mapper&lt;Person&gt; &#123;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test() throws IOException &#123; InputStream in = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = sqlSessionFactory.openSession(); MapperHelper mapperHelper = new MapperHelper(); mapperHelper.registerMapper(PersonMapper.class); mapperHelper.processConfiguration(sqlSession.getConfiguration()); PersonMapper mapper = sqlSession.getMapper(PersonMapper.class); //mapper.selectAll().forEach(System.out::println); //System.out.println(mapper.selectByPrimaryKey(1L)); Person person = new Person(); person.setName(\"张三\"); //System.out.println(mapper.select(person)); //System.out.println(mapper.selectOne(person)); //统计个数 //System.out.println(mapper.selectCount(null)); //条件组合工具 Example example = new Example(Person.class); //条件，一个create中可以组合无数个条件，但这些条件都是and关系 Example.Criteria criteria = example.createCriteria(); criteria.andLike(\"name\",\"%张%\"); //System.out.println(mapper.selectByExample(example)); Example.Criteria criteria1 = example.createCriteria(); criteria1.andEqualTo(\"name\",\"王五\"); example.or(criteria1); //System.out.println(mapper.selectByExample(example)); //排序 example.setOrderByClause(\"id desc\"); System.out.println(mapper.selectByExample(example));&#125; 在传统的Mybatis写法中，DAO接口需要与Mapper文件关联，即需要编写SQL来实现DAO接口中的方法。而在通用Mapper中，DAO只需要继承一个通用接口，即可拥有丰富的方法： 继承通用的Mapper，必须指定泛型","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Servlet生命周期","slug":"Servlet生命周期","date":"2020-09-08T13:43:25.000Z","updated":"2020-09-09T11:10:02.955Z","comments":true,"path":"2020/09/08/Servlet生命周期/","link":"","permalink":"http://yoursite.com/2020/09/08/Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Servlet生命周期总共由四个阶段：创建对象，初始化，服务，销毁","text":"Servlet生命周期总共由四个阶段：创建对象，初始化，服务，销毁 servlet类图 测试代码123456789101112131415161718192021222324252627282930313233343536package com.gem.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author zhang * @date 2020/9/8 14:44 */@WebServlet(\"/hello\")public class HelloServlet extends HttpServlet &#123; public HelloServlet()&#123; System.out.println(\"这是构造方法\"); &#125; @Override public void init() throws ServletException &#123; super.init(); System.out.println(\"初始化方法\"); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"这是服务方法\"); &#125; @Override public void destroy() &#123; System.out.println(\"这是销毁方法\"); super.destroy(); &#125;&#125; 多次请求hello 构造方法和初始化方法只加载一次，服务方法加载多次 创建对象(不存在线程安全问题)调用构造方法，默认情况下，当第一次访问到达服务器时，将调用构造方法创建对象，而且只创建一次(单例模式)，我们可用通过load-on-startup来调节Servlet的创建时机 1@WebServlet(urlPatterns = \"/hello\",loadOnStartup = 1) 整数表示服务器启动创建对象，值越小，约优先创建，0表示不在乎创建顺序，负数表示默认情况，表示当第一次到达创建 初始化(不存在线程安全问题)调用完构造方法之后，紧接着调用init初始化方法。 init方法一般用于初始化数据，执行费时费力的重量级代码， 我们可以配置初始化参数，通过ServletConfig对象来获取初始化参数 1@WebServlet(urlPatterns = \"/hello\",initParams = &#123;@WebInitParam(name = \"username\",value = \"root\"),@WebInitParam(name = \"password\",value = \"root\")&#125;) 获取初始化参数 1234ServletConfig config = getServletConfig();String username = config.getInitParameter(\"username\");String password = config.getInitParameter(\"password\");System.out.println(username + \"-------\" + password); 注意:Servlet顶级接口的init(ServletConfig config)方法时带参数的 。 我们可以发现HttpServlet的父类GenericServlet重写了带参数的init()方法，同时又提供了一个没有参数的init方法 在GenericServlet中,从servlet接口带来的init(ServletConfig config)对它进行重写时,如果忘了调用super.init(config)时,就会出现空指针异常,为了解决这样的 情况,GenericServlet中于是有了一个无参的init()方法,推荐大家重写init方法时, 重写无参的init()方法. 服务(非多线程安全)如果有必要的话，需要进行线程同步，保证线程并发安全。 HttpServlet对service方法进行了大量的细分，例如doGet、doPost、doPut、doDelete… 销毁(不存在线程安全问题)当卸载应用时，服务器会调用destory()方法，销毁当前Servlet的实例 注意： 如果当前Servlet没有提供服务，则可以被销毁。 如果当前Servlet实例正在提供服务，则调用destory()方法时，会等待一段时间，超时后销毁。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"NIO","slug":"NIO","date":"2020-08-09T08:24:52.000Z","updated":"2020-08-09T10:53:21.421Z","comments":true,"path":"2020/08/09/NIO/","link":"","permalink":"http://yoursite.com/2020/08/09/NIO/","excerpt":"Java NIO","text":"Java NIO NIO流在 JDK 1.4 中新加入了 NIO( New Input/ Output)类,引入了一种基于通道和缓冲区的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。 NIO是一种非线程阻塞的IO模型。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO时，可以同时做其他任务。同步的核心就是Selector，Selector代表了线程本事轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是线程和缓冲区，当IO事件就绪时，可以通过写道缓冲区，保证IO的成功，而无需线程阻塞时的等待。 IO和NIO的区别 IO NIO 面向流 面向缓冲 阻塞IO 基于Selector的非阻塞IO Buffer 缓冲区Java.nio.Buffer是特定的基本类型元素的线性有序序列。 缓冲区的类都有四个属性： 容量(Capacity) 上界(Limit) 位置(Position) 标记(Mark) 方法： flip()确定缓冲区数据的起始点和终止点 clear()缓冲区初始化，准备再次接收新数据到缓冲区 hasRemaining()判断postion到limit之间是否还有元素 缓冲区的分类有ByteBuffer(字节缓冲区)、CharBuffer(字符缓冲区)、ShortBuffer(短整型缓冲区)、IntBuffer(整形缓冲区)、LongBuffer(长整型缓冲区)、FloatBuffer(单精度缓冲区)、DoubleBuffer(双精度缓冲区)，就是没有布尔缓冲区。 他们都是抽象类所以不能实例化，然后他们都继承Buffer类，所以都有get()和set()方法，也都可以通过各自的静态方法allocation()创建缓冲区。 该方法是将现有的数组包装到缓冲区中来为缓冲区中的内容分配空间。 Channel 通道java.nio.Channel通过buffer(缓冲区)进行读写操作,read表示读取通道数据到缓冲区，writer表示把缓冲区数据写入到通道。 Channel需要通过节点流作为创建基础，例如FileInputStream和FileOutputStream的getChannel()方法.RandomAccessFile()也能创建文件通道，支持读写模式。通过IO创建通道是单向的，使用RandomAccessFile创建的通道支持双向。 通道可以异步读写，异步读写表示通道执行读写操作时，也能做别的事情， 解决线程阻塞。如果使用文件管道（FileChannel），建议用 RandomAccessFile 来创建管道，因为该类支持读写模式以及有大量处理文件的方法。 读取文件 写入文件","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合比较器规则","slug":"Java集合比较器规则","date":"2020-08-01T01:04:43.000Z","updated":"2020-08-01T01:28:58.094Z","comments":true,"path":"2020/08/01/Java集合比较器规则/","link":"","permalink":"http://yoursite.com/2020/08/01/Java%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83%E5%99%A8%E8%A7%84%E5%88%99/","excerpt":"Java集合框架自带一个排序的方法sort()，但是需要传入一个比较器对象","text":"Java集合框架自带一个排序的方法sort()，但是需要传入一个比较器对象 我们可以定义一个比较器的类，实现Comparator接口，重写compare方法 123456789101112//按照年龄比较class comparatorAge implements Comparator&lt;User&gt;&#123; @Override public int compare(User u1, User u2) &#123; if (u1.getAge() &gt; u2.getAge()) &#123; return -1; &#125;else if (u1.getAge() &lt; u2.getAge())&#123; return 1; &#125; return 0; &#125;&#125; 1users.sort(new comparatorAge()); sort传入比较方法就可以了，但这样写明显是不合理的。 我们可以改进成匿名内部类的形式 1234567891011users.sort(new Comparator&lt;User&gt;() &#123; @Override public int compare(User u1, User u2) &#123; if (u1.getAge() &gt; u2.getAge())&#123; return -1; &#125;else if (u1.getAge() &lt; u2.getAge())&#123; return 1; &#125; return 0; &#125;&#125;); 我们还可以用Java8的新特性lambda表达式优化一下 12345678910users.sort((u1,u2)-&gt;&#123; if (u1.getAge() &gt; u2.getAge())&#123; return -1; &#125;else if (u1.getAge() &lt; u2.getAge())&#123; return 1; &#125; return 0; //如果年龄相等我们可以根据名字来排序，字符串直接调用compareTo()方法就可以了。 //return u1.getName().compareTo(u2.getName());&#125;); 如果存在多个比较规则的话，这样代码写起来会比较困难，我们可以用之前的工厂模式进行简单封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package colltection;import java.util.Comparator;/** * @author zhang * @date 2020/7/31 11:11 */public class ComparatorFactort &#123; public final static int AGE_MIN_TO_MAX = 1; public final static int AGE_MAX_TO_MIN = 2; public final static int NAME_MAX_TO_MIN = 3; public final static int NAME_MIN_TO_MAX = 4; //public static Comparator&lt;User&gt; comparator = null; public static Comparator getComparator(int type)&#123; Comparator&lt;User&gt; comparator = null; if (type == AGE_MAX_TO_MIN)&#123; comparator = (p1,p2)-&gt;&#123; if (p1.getAge() &gt; p2.getAge())&#123; return -1; &#125;else if (p1.getAge() &lt; p2.getAge())&#123; return 1; &#125;return 0; &#125;; &#125; if (type == AGE_MIN_TO_MAX)&#123; comparator = (p1,p2)-&gt;&#123; if (p1.getAge() &gt; p2.getAge())&#123; return 1; &#125;else if (p1.getAge() &lt; p2.getAge())&#123; return -1; &#125; return 0; &#125;; &#125; if (type == NAME_MAX_TO_MIN)&#123; comparator = (p1,p2)-&gt; p1.getName().compareTo(p2.getName()); &#125; if (type == NAME_MIN_TO_MAX)&#123; comparator = (p1,p2)-&gt; p2.getName().compareTo(p1.getName()); &#125; return comparator; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"正则表达式的基本使用","slug":"正则表达式的基本使用","date":"2020-07-30T10:08:27.000Z","updated":"2020-07-30T10:56:25.532Z","comments":true,"path":"2020/07/30/正则表达式的基本使用/","link":"","permalink":"http://yoursite.com/2020/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。","text":"正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。 规则字符在java.util.regex Pattern类中 常见规则 表达式 规则 ^ 匹配行的开头 $ 匹配行的结尾 . 匹配换行符以外的任意字符 […] 匹配在方括号中的任意字符 * 匹配前面子表达式零次或多次 + 匹配前面子表达式一次或多次 ？ 匹配前面子表达式零次或一次 {n} 匹配前面子表达式n次 {n,} 匹配前面子表达式n次或n次以上 {n,m} 匹配前面子表达式至少n次，至多m次 a|b 匹配a或者b [^…] 匹配不在方括号的任意字符 Java中如何使用正则表达式在Java中调用正则表达式的类是Java.util.regex.Matcher和Java.util.regex.Pattern,java.util.regex是JDK1.4开始提供的，有多种写法来使用正则表达式。 当然String类也提供了matches()方法来匹配正则表达式 实现模糊查询","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Object类Clone()方法","slug":"Object类Clone-方法","date":"2020-07-28T10:21:24.000Z","updated":"2020-07-28T12:29:02.773Z","comments":true,"path":"2020/07/28/Object类Clone-方法/","link":"","permalink":"http://yoursite.com/2020/07/28/Object%E7%B1%BBClone-%E6%96%B9%E6%B3%95/","excerpt":"Object对象有个clone()方法，实现了对象中各个属性的复制.","text":"Object对象有个clone()方法，实现了对象中各个属性的复制. 实现步骤 实现Cloneable接口，这是一个标记接口，自身没有方法 覆盖clone()方法，可见性提升为public 这里说一下为什么要重写clone方法，并且提升为public类型 如果不重写，由于Object的clone()方法时protected修饰的，在不同包下别的类即使使用目标类的对象也不能访问目标类继承的clone()方法，只能在目标类内部使用，局限性大。 实现 测试 遇到点麻烦，我们之修改了克隆对象的地址，发现原来对象的地址也被改变了，这就涉及到了clone的浅拷贝和深拷贝。 浅拷贝和深拷贝clone()方法默认浅拷贝，即基本数据类型+常用类型(日期，字符串)，拷贝一份，修改克隆对象，不影响原对象。 但是对象类型的属性，拷贝的是引用(地址),它是两个对象共用的，所以修改克隆对象影响原对象。 如果想实现深拷贝，我们可以让属性对应的实体类同样实现Cloneable接口，重写clone()方法。 再次测试发现克隆对象的属性，原对象的属性不会发生变化，深克隆实现成功！","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java模板模式","slug":"Java模板模式","date":"2020-07-27T10:44:59.000Z","updated":"2020-07-27T11:20:39.998Z","comments":true,"path":"2020/07/27/Java模板模式/","link":"","permalink":"http://yoursite.com/2020/07/27/Java%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"在模板模式中，一个抽象类公开定义了执行它的方法的方式。它的子类可以按照重写方法实现，但调用将以抽象类中定义的方法进行。这种类型的设计模式属于行为型模式。","text":"在模板模式中，一个抽象类公开定义了执行它的方法的方式。它的子类可以按照重写方法实现，但调用将以抽象类中定义的方法进行。这种类型的设计模式属于行为型模式。 介绍意图：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法子类可以不改变算法的结构即可重定义该算法的某些步骤。 关键代码：在抽象类实现，其他步骤在子类实现 优点： 封装不变部分，扩展可变部分 提取公共代码便于维护 行为有父类控制子类实现 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 有多个子类共有方法，且逻辑相同 重要的、复杂的方法，可以考虑作为模板方法 注意事项：为了防止恶意操作，一般模板方法上都加上final关键字 实现我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。 步骤1创建一个抽象类，它的模板方法被设置为 final。 12345678910111213141516171819202122package class类.模板设计模式;/** * @author zhang * @date 2020/7/27 10:03 */public abstract class 春晚小品 &#123; abstract void 开场(); abstract void 叙事(); abstract void 煽情(); abstract void 谢幕(); /** * 顶级业务流程 */ public final void 演小品()&#123; 开场(); 叙事(); 煽情(); 谢幕(); &#125;&#125; 步骤2创建扩展了上述类的实体类 12345678910111213141516171819202122232425262728package class类.模板设计模式;/** * @author zhang * @date 2020/7/27 10:06 */public class 冯巩 extends 春晚小品&#123; @Override void 开场() &#123; System.out.println(\"朋友们想死你们了\"); &#125; @Override void 叙事() &#123; System.out.println(\"冯巩叙事\"); &#125; @Override void 煽情() &#123; System.out.println(\"冯巩煽情\"); &#125; @Override void 谢幕() &#123; System.out.println(\"冯巩谢幕\"); &#125;&#125; 测试12345678910111213package class类.模板设计模式;/** * @author zhang * @date 2020/7/27 10:07 */public class Test &#123; @org.junit.Test public void test() &#123; 春晚小品 冯巩 = new 冯巩(); 冯巩.演小品(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java抽象工厂模式","slug":"Java抽象工厂模式","date":"2020-07-27T09:58:55.000Z","updated":"2020-07-27T10:41:07.099Z","comments":true,"path":"2020/07/27/Java抽象工厂模式/","link":"","permalink":"http://yoursite.com/2020/07/27/Java%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。","text":"抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory*。接着定义工厂类 *ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo*，我们的演示类使用 *FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤1为形状创建一个接口 12345678910package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:14 * 形状接口 */public interface Shape &#123; void draw();&#125; 步骤2创建实现接口的实体类 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:15 */public class Rect implements Shape&#123; @Override public void draw() &#123; System.out.println(\"这是一个矩形！\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:16 */public class Square implements Shape&#123; @Override public void draw() &#123; System.out.println(\"这是一个正方形！\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:17 */public class Circle implements Shape&#123; @Override public void draw() &#123; System.out.println(\"这是一个圆形!\"); &#125;&#125; 步骤3为颜色创建一个接口 123456789package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:19 */public interface Color &#123; void fill();&#125; 步骤4创建实现接口的实体类 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:20 */public class Red implements Color&#123; @Override public void fill() &#123; System.out.println(\"红色!\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:21 */public class Blue implements Color&#123; @Override public void fill() &#123; System.out.println(\"蓝色！\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:20 */public class Green implements Color&#123; @Override public void fill() &#123; System.out.println(\"绿色!\"); &#125;&#125; 步骤5为Color和Shape创建抽象工厂来获取工厂 12345678910package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:23 */public abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape);&#125; 步骤6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 123456789101112131415161718192021222324252627package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:25 */public class ShapeFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; return null; &#125; @Override Shape getShape(String shape) &#123; Shape shape1 = null; if (shape.equalsIgnoreCase(\"CIRCLE\"))&#123; shape1 = new Circle(); &#125;else if (shape.equalsIgnoreCase(\"RECT\"))&#123; shape1 = new Rect(); &#125;else if (shape.equalsIgnoreCase(\"SQUARE\"))&#123; shape1 = new Square(); &#125;else &#123; throw new RuntimeException(\"非法参数1!\"); &#125; return shape1; &#125;&#125; 123456789101112131415161718192021222324252627package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:29 */public class ColorFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; Color color1 = null; if (color.equalsIgnoreCase(\"RED\"))&#123; color1 = new Red(); &#125;else if (color.equalsIgnoreCase(\"GREEN\"))&#123; color1 = new Green(); &#125;else if (color.equalsIgnoreCase(\"BLUE\"))&#123; color1 = new Blue(); &#125;else &#123; throw new RuntimeException(\"非法参数!\"); &#125; return color1; &#125; @Override Shape getShape(String shape) &#123; return null; &#125;&#125; 步骤7创建一个工厂创建器，通过传递形状或颜色信息来获取工厂 1234567891011121314151617181920package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:33 */public class FactoryProducer &#123; public static AbstractFactory getFactory(String type)&#123; AbstractFactory factory = null; if (type.equalsIgnoreCase(\"SHAPE\"))&#123; factory = new ShapeFactory(); &#125;else if (type.equalsIgnoreCase(\"COLOR\"))&#123; factory = new ColorFactory(); &#125;else &#123; throw new RuntimeException(\"非法参数!\"); &#125; return factory; &#125;&#125; 步骤8测试 12345678910111213141516171819202122package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:36 */public class Test &#123; @org.junit.Test public void test()&#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(\"Shape\"); //获取形状为circle的对象 Shape circle = shapeFactory.getShape(\"CIRCLE\"); circle.draw(); AbstractFactory colorFactory = FactoryProducer.getFactory(\"Color\"); Color red = colorFactory.getColor(\"RED\"); red.fill(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java静态工厂模式","slug":"Java静态工厂","date":"2020-07-24T13:04:20.000Z","updated":"2020-07-25T01:27:45.612Z","comments":true,"path":"2020/07/24/Java静态工厂/","link":"","permalink":"http://yoursite.com/2020/07/24/Java%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82/","excerpt":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。","text":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现步骤一创建一个Shape父类 123456789101112131415161718192021222324package class类;/** * @author zhang * @date 2020/7/23 14:30 *///形状类public class Shape &#123; /** * 得到周长 * @return */ public double getPerimeter()&#123; return 0.0; &#125; /** * 获得面积 * @return */ public double getArea()&#123; return 0.0; &#125;&#125; 步骤二创建圆形子类继承Shape类 123456789101112131415161718192021222324252627282930313233343536373839404142package class类;/** * @author zhang * @date 2020/7/24 14:56 *///圆形public class Circle extends Shape&#123; private double radius; public Circle() &#123; &#125; public Circle(double radius) &#123; this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double radius) &#123; this.radius = radius; &#125; @Override public String toString() &#123; return \"Circle&#123;\" + \"radius=\" + radius + '&#125;'; &#125; @Override public double getArea() &#123; return Math.pow(radius,2) * Math.PI; &#125; @Override public double getPerimeter() &#123; return 2 * Math.PI * radius; &#125;&#125; 创建矩形子类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package class类;/** * @author zhang * @date 2020/7/24 14:52 *///矩形public class Rect extends Shape&#123; private double length;//长 private double width;//宽 public Rect() &#123; &#125; public Rect(double length, double width) &#123; this.length = length; this.width = width; &#125; public double getLength() &#123; return length; &#125; public void setLength(double length) &#123; this.length = length; &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this.width = width; &#125; @Override public String toString() &#123; return \"Rect&#123;\" + \"length=\" + length + \", width=\" + width + '&#125;'; &#125; @Override public double getPerimeter() &#123; return 2 * (width + length); &#125; @Override public double getArea() &#123; return width * length; &#125;&#125; 创建正方形子类，间接继承Shape类 1234567891011121314151617package class类;/** * @author zhang * @date 2020/7/24 14:56 */public class Square extends Rect&#123; private int bianchang; public Square(int bianchang) &#123; super(bianchang,bianchang); &#125; public Square()&#123; &#125;&#125; 步骤三创建一个工厂，生成基于给定信息的实体类的对象。 12345678910111213141516171819202122232425262728293031package class类.foactorydemo;import class类.Circle;import class类.Rect;import class类.Shape;import class类.Square;/** * @author zhang * @date 2020/7/24 14:48 */public class ShapeFactory &#123; public static final int CIRCLE = 1; public static final int RECT = 2; public static final int SQUARE = 3; public static Shape getInstance(int i)&#123; Shape shape = null; if (i == CIRCLE)&#123; shape = new Circle(); &#125;else if (i == RECT)&#123; shape = new Rect(); &#125;else if (i == SQUARE)&#123; shape = new Square(); &#125;else &#123; throw new RuntimeException(\"参数有误！\"); &#125; return shape; &#125;&#125; 步骤四使用该工厂，通过传递类型信息来获取实体类的对象。 12345678910111213141516package class类.foactorydemo;import class类.Circle;import class类.Shape;/** * @author zhang * @date 2020/7/24 14:59 */public class TestFactory &#123; public static void main(String[] args) &#123; Shape shape = ShapeFactory.getInstance(ShapeFactory.CIRCLE); System.out.println(shape instanceof Circle); &#125;&#125; 返回结果为true 更优雅的实现，将该类的所以静态资源导入 12345678910111213141516package class类.foactorydemo;import class类.Circle;import class类.Shape;import static class类.foactorydemo.ShapeFactory.*;/** * @author zhang * @date 2020/7/24 14:59 */public class TestFactory &#123; public static void main(String[] args) &#123; Shape shape = getInstance(CIRCLE); System.out.println(shape instanceof Circle); &#125;&#125; 特点1 它是一个具体的类，非接口 抽象类。有一个重要的getInstance()方法，利用if或者 switch创建产品并返回。 2 getInstance()方法通常是静态的，所以也称之为静态工厂。 缺点1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法） 2 不同的产品需要不同额外参数的时候 不支持。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java单例模式","slug":"Java单例模式","date":"2020-07-23T09:43:05.000Z","updated":"2020-07-25T00:25:58.221Z","comments":true,"path":"2020/07/23/Java单例模式/","link":"","permalink":"http://yoursite.com/2020/07/23/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"单例模式","text":"单例模式 概述单例模式的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。属于设计模式三大类中的创建型模式。单例模式具有典型的三个特点： 只有一个实例。 自我实例化。 提供全局访问点。 其UML结构图非常简单，就只有一个类，如下图： 优缺点 优点：由于单例模式只生成一个实例，所以能够节省系统资源，减少性能开销，提高系统效率，同时也能够严格的控制客户对他的访问。 缺点：也正是因为系统只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责”的原则，同时也没有抽象类，这样扩展起来有一定的困难。 实现方式 饿汉式：线程安全，调用效率高，但是不能延迟加载。 123456789101112131415161718package class类;/** * @author zhang * @date 2020/7/23 18:02 */public class SingletonDemo1 &#123; //线程安全，类初始化立即加载这个对象 private static SingletonDemo1 singletonDemo1 = new SingletonDemo1(); //私有构造方法--&gt;外界不能通过new来创建对象 private SingletonDemo1()&#123;&#125; //提供一个公开的静态方法来创建当前类的对象 public static SingletonDemo1 getInstance()&#123; return singletonDemo1; &#125;&#125; 由于该模式类加载的时候对象就已创建了，所以加载类的速度比较慢，但是获取对象的速度比较块，且是线程安全 的。 懒汉式：线程不安全 123456789101112131415161718192021package class类;import javax.crypto.spec.PSource;/** * @author zhang * @date 2020/7/23 18:09 */public class SingletonDemo2 &#123; private static SingletonDemo2 singletonDemo2; //提供私有的构造方法 private SingletonDemo2()&#123;&#125; public static SingletonDemo2 getInstance()&#123; if (singletonDemo2 == null)&#123; singletonDemo2 = new SingletonDemo2(); &#125; return singletonDemo2; &#125;&#125; 由于该模式是在运行时加载对象的，所以加载类比较快，但是对象的获取速度相对较慢，且线程不安全。如果想要线程安全的话可以加上synchronized关键字，但是这样会付出惨重的效率代价 懒汉式(双重同步锁) 12345678910111213141516171819202122232425package class类;/** * @author zhang * @date 2020/7/23 18:19 */public class SingletonDemo3 &#123; //使用双重锁机制 private static volatile SingletonDemo3 singletonDemo3; //提供私有的构造方法 private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; if (singletonDemo3 == null)&#123; //线程同步加锁 synchronized (SingletonDemo3.class)&#123; if (singletonDemo3 == null)&#123; singletonDemo3 = new SingletonDemo3(); &#125; &#125; &#125; return singletonDemo3; &#125;&#125; 优点：线程安全，缺点：每次获取实例都要加锁，耗费资源，其实只要实例已经生成，以后获取就不需要再锁了 常见应用场景 网站计数器。 项目中用于读取配置文件的类。 数据库连接池。因为数据库连接池是一种数据库资源。 Spring中，每个Bean默认都是单例的，这样便于Spring容器进行管理。 Servlet中Application Windows中任务管理器，回收站。 等等。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java的堆区、栈区和方法区简单分析","slug":"Java的堆区、栈区和方法区简单分析","date":"2020-07-21T13:28:27.000Z","updated":"2020-07-21T13:40:19.472Z","comments":true,"path":"2020/07/21/Java的堆区、栈区和方法区简单分析/","link":"","permalink":"http://yoursite.com/2020/07/21/Java%E7%9A%84%E5%A0%86%E5%8C%BA%E3%80%81%E6%A0%88%E5%8C%BA%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/","excerpt":"Java的堆区、栈区和方法区简单分析","text":"Java的堆区、栈区和方法区简单分析 堆：**堆主要存放Java在运行过程中new出来的对象，凡是通过new生成的对象都存放在堆中，对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。类的非静态成员变量也放在堆区，其中基本数据类型是直接保存值，而复杂类型是保存指向对象的引用，非静态成员变量在类的实例化时开辟空间并且初始化。所以你要知道类的几个时机，加载-连接-初始化-实例化。** 栈：**栈主要存放在运行期间用到的一些局部变量（基本数据类型的变量）或者是指向其他对象的一些引用，因为方法执行时，被分配的内存就在栈中，所以当然存储的局部变量就在栈中咯。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；** 常量池：**常量池是方法区的一部分内存。常量池在编译期间就将一部分数据存放于该区域，包含基本数据类型如int、long等以final声明的常量值，和String字符串、特别注意的是对于方法运行期位于栈中的局部变量String常量的值可以通过 String.intern()方法将该值置入到常量池中。** 静态域：**位于方法区的一块内存。存放类中以static声明的静态成员变量。** 方法区：**是各个线程共享的内存区域，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。它有个名字叫做Non-Heap(非堆)，目的是与Java堆区分开。** 需要特别注意的是： 方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待 ！ 最后总结起来就是： 栈：**为即时调用的方法开辟空间，存储局部变量值(基本数据类型)，局部变量引用。注意：局部变量必须手动初始化。**堆：**存放引用类型的对象，即new出来的对象、数组值、类的非静态成员变量值(基本数据类型)、非静态成员变量引用。其中非静态成员变量在实例化时开辟空间初始化值。更具体点，个人感觉非静态成员变量是放在堆的对象中。**方法区：**存放class二进制文件。包含类信息、静态变量，常量池（String字符串和final修饰的常量值等），类的版本号等基本信息。因为是共享的区域，所以如果静态成员变量的值或者常量值(String类型的值能够非修改，具体请查看博客)被修改了直接就会反应到其它类的对象中。**","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java类加载机制","slug":"Java类加载机制","date":"2020-07-19T07:24:30.000Z","updated":"2020-07-19T07:34:40.860Z","comments":true,"path":"2020/07/19/Java类加载机制/","link":"","permalink":"http://yoursite.com/2020/07/19/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"Java类加载机制","text":"Java类加载机制 1、什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在java堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class 对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 2、 类的加载过程JVM 将类的加载过程分为三个大的步骤：加载(loading)，链接(link)，初始化(initialize)。其中链接又分为三个步骤：验证，准备，解析。 (1) 加载：查找并加载类的二进制数据加载是类加载过程中的第一个阶段，加载过程虚拟机需要完成以下三件事情： 1) 通过一个类的全限定名来获取其定义的二进制字节流； 2) 将这个字节流所代表的静态存储结构转为方法区的运行时数据结构； 3) 在Java 堆中生成一个代表这个类的java.lang.Class 对象，作为方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据 (2) 链接：① 验证：确保被加载类的正确性； 主要是为了安全考虑，为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 ② 准备：为类的静态变量分配内存，并将其初始化为默认值； 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 1)、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2)、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为：public static int value = 3； 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 ③ 解析：把类中的符号引用转换为直接引用； 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 (3) 初始化：为类的静态变量赋予正确的初始值为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ① 声明类变量是指定初始值； ② 使用静态代码块为类变量指定初始值； ③ JVM初始化步骤 1)、假如这个类还没有被加载和连接，则程序先加载并连接该类 2)、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3)、假如类中有初始化语句，则系统依次执行这些初始化语句 ④ 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： – 创建类的实例，也就是new的方式 – 访问某个类或接口的静态变量，或者对该静态变量赋值 – 调用类的静态方法 – 反射（如Class.forName(“com.shengsiyuan.Test”)） – 初始化某个类的子类，则其父类也会被初始化 – Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 (4) 结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 – 执行了System.exit()方法 – 程序正常执行结束 – 程序在执行过程中遇到了异常或错误而异常终止 – 由于操作系统出现错误而导致Java虚拟机进程终止 3、类加载器JVM 类加载器作用，将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。 类加载器是通过ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述： (1) Bootstrap ClassLoader 引导类加载器 负责加载Java核心库$JAVA_HOME中的jre/lib/rt.jar 里所有的class，由c++实现，不是ClassLoader子类。 (2) Extension ClassLoader 扩展类加载器 负责加载Java 平台中扩展功能的一些jar包，包括$JAVA_HOME中的jre/lib/ext/*.jar 或 -D java.ext.dirs指定目录下的jar包。 (3) App ClassLoader 负责加载classpath 中指定的jar包及目录中class (4) Custom ClassLoader 应用程序根据自身需要自定义的ClassLoader，如tomcat，jboss 都会根据j2ee规范自行实现ClassLoader，加载过程中会先检查是否已被加载，检查顺序是自底向上，从Custom ClassLoader 到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类在所有ClassLoader 只加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 4、JVM 三种预定义加载器JVM预定义有三种类加载器，当一个 JVM启动的时候，Java 默认开始使用如下三种类加载器： (1) 引导类加载器（Bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。它负责将/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 (2) 扩展类加载器（Extensions class loader）：该类加载器在此目录里面查找并加载 Java 类。扩展类加载器是由Sun的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量-Djava.ext.dirs指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 (3) 系统类加载器（System class loader）：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 5、类加载器 “双亲委派” 机制(1) 双亲委派机制介绍 在这里需要着重说明，JVM在加载类时默认采用的是双亲委派机制。所谓的双亲委派机制，就是某个特定的类加载器在接到类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和标准扩展类加载器为例作简单分析。 双亲委派机制是为了保证Java核心库的类型安全。**这种机制能保证不会出现用户自己能定义java.lang.Object类的情况，因为即使定义了，也加载不了。**","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java位运算符","slug":"Java位运算符","date":"2020-07-16T09:56:31.000Z","updated":"2020-07-16T11:07:49.491Z","comments":true,"path":"2020/07/16/Java位运算符/","link":"","permalink":"http://yoursite.com/2020/07/16/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"位运算符","text":"位运算符 位运算符关于位运算符无非也就 与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;) 位运算其实就是二进制的运算，加减乘除适用于十进制，而位运算就是二进制的运算,但是由于我们的运算都是基于十进制来说的，所以会有点绕，略微有点难懂，接下来言归正传 与运算符(&amp;)4&amp;7 我们需要把两个二进制转换成十进制 4：0000 0100 7：0000 0111 这里提到一点：1表示true，0表示false 而与运算的时候相同位之间其实就是两个Boolean的运算 ​ 全true(1),即为true(1) ​ 全false(0),即为false(0) ​ 一false(0)一true(1),还是false(0) 或运算符(|) 以 5|9 为例 5 ： 0000 0101 9 ： 0000 1001 在做与运算的时候 ​ 遇true(1)就是true(1), ​ 无true(1)就是false(0) 异或运算符(^) 以 7^15 为例 7： 0000 0111 15： 0000 1111 在异或的时候 ​ 只要相同都是false(0) ​ 只有不同才是true(1) 一个数连续异或同一个数两次,结果是它本身 取反运算符(~)例： ~15 同样的先变成二进制：15：0000 1111 这个其实挺简单的，就是把1变0，0变1 注意：二进制中，最高位是符号位 1表示负数，0表示正数 左移运算(&lt;&lt;) 左移就是把所有位向左移动几位 如： 12 &lt;&lt; 2 意思就是12向左移动两位 ​ 12的二进制是： 0000 1100 通过这个图我们可以看出来，所有的位全都向左移动两位，然后把右边空的两个位用0补上，最左边多出的两个位去掉，最后得到的结果就是00110000 结果就是48 我们用同样的办法算 12&lt;&lt;3 结果是 96 ​ 8&lt;&lt;4 结果是 128 由此我们得出一个快速的算法 M &lt;&lt; n 其实可以这么算 M &lt;&lt; n = M * 2n 右移运算符(&gt;&gt;)这个跟左移运算大体是一样的 例： 12 &gt;&gt; 2 我们可以看出来右移和左移其实是一样的，但是还是有点不同的，不同点在于对于正数和负数补位的时候补的不一样，负数补1，正数补0 如我们再做一个 –8 的 -8&gt;&gt;2 这里总结一下，关于负数或者正数来说，移位的时候是一样的，但是在补位的时候，如果最高位是0就补0，如果最高位是1就补1 由此我们得出一个快速的算法 M &gt;&gt; n 其实可以这么算 M &gt;&gt; n = M / 2^n 无符号右移(&gt;&gt;&gt;)无符号右移(&gt;&gt;&gt;)只对32位和64位有意义 在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"SpringMVC笔记(五)","slug":"SpringMVC笔记-五","date":"2020-07-03T12:24:42.000Z","updated":"2020-07-03T12:30:41.135Z","comments":true,"path":"2020/07/03/SpringMVC笔记-五/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%94/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 重点@ResponseBody阻止视图解析器的效果，会直接返回一个字符串 Json交互处理 什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 123&#123;\"name\": \"QinJiang\"&#125;&#123;\"age\": \"3\"&#125;&#123;\"sex\": \"男\"&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: 'Hello', b: 'World'&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse('&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;');//结果是 &#123;a: 'Hello', b: 'World'&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;);//结果是 '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;' Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617@Controllerpublic class UserController &#123; @RequestMapping(\"/json1\") @ResponseBody//阻止视图解析器的效果，会直接返回一个字符串 public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 1234567891011121314151617@RestControllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 1234567891011121314151617181920@RequestMapping(\"/json2\")public String json2() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;&#125; 运行结果 : 十分完美，没有任何问题！","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(四)","slug":"SpringMVC笔记-四","date":"2020-07-03T12:04:50.000Z","updated":"2020-07-03T12:15:01.862Z","comments":true,"path":"2020/07/03/SpringMVC笔记-四/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E5%9B%9B/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 结果跳转方式ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; ServletAPI通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 123456789101112131415161718192021@Controllerpublic class ResultGo &#123; @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.getWriter().println(\"Hello,Spring BY servlet API\"); &#125; @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(\"/index.jsp\"); &#125; @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); &#125;&#125; SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 1234567891011121314151617181920@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(\"/rsm/t1\") public String test1()&#123; //转发 return \"/index.jsp\"; &#125; @RequestMapping(\"/rsm/t2\") public String test2()&#123; //转发二 return \"forward:/index.jsp\"; &#125; @RequestMapping(\"/rsm/t3\") public String test3()&#123; //重定向 return \"redirect:/index.jsp\"; &#125;&#125; 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 12345678910111213141516@Controllerpublic class ResultSpringMVC2 &#123; @RequestMapping(\"/rsm2/t1\") public String test1()&#123; //转发 return \"test\"; &#125; @RequestMapping(\"/rsm2/t2\") public String test2()&#123; //重定向 return \"redirect:/index.jsp\"; //return \"redirect:hello.do\"; //hello.do为另一个请求/ &#125;&#125; 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=zhangsan 处理方法 : 12345@RequestMapping(\"/hello\")public String hello(String name)&#123; System.out.println(name); return \"hello\";&#125; 后台输出 : zhangsan 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=zhangsan 处理方法 : 123456//@RequestParam(\"username\") : username提交的域的名称 .@RequestMapping(\"/hello\")public String hello(@RequestParam(\"username\") String name)&#123; System.out.println(name); return \"hello\";&#125; 后台输出 : zhangsan 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 12345678public class User &#123; private int id; private String name; private int age; //构造 //get/set //tostring()&#125; 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 3、处理方法 : 12345@RequestMapping(&quot;&#x2F;user&quot;)public String user(User user)&#123; System.out.println(user); return &quot;hello&quot;;&#125; 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 第二种 : 通过ModelMap ModelMap 12345678@RequestMapping(\"/hello\")public String hello(@RequestParam(\"username\") String name, ModelMap model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\";&#125; 第三种 : 通过Model Model 12345678@RequestMapping(\"/ct2/hello\")public String hello(@RequestParam(\"username\") String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\";&#125; 对比就对于新手而言简单来说使用区别就是： 12345Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题测试步骤： 1、我们可以在首页编写一个提交的表单 1234&lt;form action=\"/e/t\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 2、后台编写对应的处理类 12345678@Controllerpublic class Encoding &#123; @RequestMapping(\"/e/t\") public String test(Model model,String name)&#123; model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 &#125;&#125; 3、输入中文测试，发现乱码 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(三)","slug":"SpringMVC笔记-三","date":"2020-07-03T11:50:18.000Z","updated":"2020-07-03T12:04:29.119Z","comments":true,"path":"2020/07/03/SpringMVC笔记-三/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 RestFul和控制器控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 123456789101112//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; 增加一个ControllerTest2类，使用注解实现； 1234567891011121314//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2&#123; //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; &#125;&#125; 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping@RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(\"/admin\")public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController 123@Controllerpublic class RestFulController &#123;&#125; 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 12345678910111213141516@Controllerpublic class RestFulController &#123; //映射访问路径 @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\") public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; &#125; &#125; 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 123456//映射访问路径,必须是POST请求@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.POST&#125;)public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\";&#125; 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； 123456//映射访问路径,必须是Get请求@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.GET&#125;)public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\";&#125; 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(二)","slug":"SpringMVC笔记-二","date":"2020-07-03T08:06:21.000Z","updated":"2020-07-03T11:49:00.095Z","comments":true,"path":"2020/07/03/SpringMVC笔记-二/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%8C/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 第一个SpringMVC程序配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， 注册DispatcherServlet 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 5、添加 处理映射器 1&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 6、添加 处理器适配器 1&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 7、添加 视图解析器 1234567&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 123456789101112131415161718import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author zhang * @date 2020/7/2 19:46 */public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"HelloSpringMVC!!!\"); //视图跳转 mv.setViewName(\"test\"); return mv; &#125;&#125; 9、将自己的类交给SpringIOC容器，注册bean 12&lt;!--Handler--&gt;&lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 注意点： / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 123456789101112131415161718192021222324252627282930314. 1. 在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 2. - 让IOC的注解生效 - 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ..... - MVC的注解驱动 - 配置视图解析器1. **6、创建Controller**2. 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范3. &#96;&#96;&#96;java import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; &#x2F;** * @author zhang * @date 2020&#x2F;7&#x2F;2 20:20 *&#x2F; @Controller @RequestMapping(&quot;&#x2F;hello&quot;) public class HelloController &#123; @RequestMapping(&quot;&#x2F;h1&quot;) public String hello(Model model)&#123; &#x2F;&#x2F;封装数据 model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVCAnnotation!&quot;); return &quot;hello&quot;; &#125; &#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(一)","slug":"SpringMVC笔记-一","date":"2020-06-23T11:12:16.000Z","updated":"2020-06-23T11:14:33.387Z","comments":true,"path":"2020/06/23/SpringMVC笔记-一/","link":"","permalink":"http://yoursite.com/2020/06/23/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 SpringMVCssm:mybats+Spring+SpringMVC MVC三层架构 回顾MVC1.1什么是MVC? MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.2Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.3Model2时代Model2把一个项目分成三部分，包括视图、控制、模型 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 什么是SpringMVC2.1概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 2.2、中心控制器​ Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 2.3、SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"注解和反射","slug":"注解和反射","date":"2020-06-12T10:43:27.000Z","updated":"2020-06-12T10:45:22.336Z","comments":true,"path":"2020/06/12/注解和反射/","link":"","permalink":"http://yoursite.com/2020/06/12/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"注解和反射笔记","text":"注解和反射笔记 注解什么是注解java.Annotation包 Annotation是从JDK5.0开始引入的新技术 Annotation的作用： 不是程序本事，可以对程序做出解释（这一点和注释comment没什么区别） 可以被其他程序（比如编译器）读取 Annotation的格式 注解是以”@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=”unchecked”) Annotation在哪里使用? 可以附加在package，class，method，filed等上面， 相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解@Override：定义在java.lang.Override中，此注解只适合用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明@Deprecated：定义在java.lang.Deprecated中，此注解可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为他们很危险或者存在更好的选择 @SuppressWarnings:定义在java.lang.SuppressWarning中，用来抑制编译时的警告信息。 元注解 元注解的作用就是负责注解其他注解，java定义了4个标准的meta-annotation类型，他们被用来提供给对其他annotation类型做说明 @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 （SOURCE&lt;CLASS&lt;RUNTIME） @Document：说明该注解将被包含在javadoc中 Inherited：说明子类可以继承父类中的该注解 自定义注解使用@interface自定义注解时，自动继承了java.lang.anntation.Anntation接口 分析： @interface用来声明一个注解，格式：public @interface 注解名 {定义内容} 其中每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值的类型就是参数的类型（返回值只能是基本类型，Class，String，enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须有值，我们定义注解元素时，经常使用空字符串，0作为默认值 12345678910111213141516171819/** * @author zhang * @date 2020/6/10 19:05 */public class Demo3 &#123; @MyAnnotation2(name = \"张三\",schools = &#123;\"黑龙江八一农垦大学\"&#125;) public void test()&#123;&#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2&#123; //注解的参数 String name() default \"\"; int age() default 0; int id() default 1; String[] schools() default &#123;\"清华大学\"&#125;;&#125; 反射反射概述 Reflection(反射)时Java被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法 Class c = Class.forName(&quot;java.lang.String&quot;) 加载完类之后，在堆内存的方法去中就产生了一个class类型的对象(一个类只有一个class对象)，这个对象就包含了完整的类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射 Java反射的优缺点 优点：可以实现动态创建对象和编译，体现出很大的灵活性 缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么兵器它满足我们的需求。这类操作总是慢于直接执行相同的操作。 获得反射对象Class类 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定的某个结构(class/interface/enum/annotation/primitive type/void[])的有关信息。 Class本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，支队任何你想动态加载、运行的类，唯有先获得相应的Class对象 Class的常用方法 方法名 功能说明 static ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回一个Class对象的实例 getName() 返回此Class对象表示的实体(类、接口、数组类或void)的名称 Class getSuperClass 返回当前Class对象的父类Class对象 Class[] getinterfaces 返回当前Class对象的接口 ClassLoader getClassLoader 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Method getMethod(String name,Class.. T) 返回一个Method对象，此对象的参数类型为paramType Field[] getDeclaredFields() 返回Field对象的一个数组 Java内存分析 类的加载过程 当程序主动使用某个类时，如果该类未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时的数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将java类的二进制文件合并到JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用(常量名)替换为直接引用（地址）的过程 初始化： 执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法由编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器时构造类信息的，不是构造该类对象的构造器） 当初始化一个类的时候，如果发现器父类没有进行初始化，则需要先触发器父类的初始化 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。 什么时候会发生类的初始化？ 类的主动引用（一定会发生类的初始化） 当虚拟机启动时，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就已经存入调用类的常量池了） 类加载器类加载器的作用：将class文件的字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口， 类缓存：标准的javaSE类可以按照要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 获取运行时类的完整结构通过反射获取运行时类的完整结构 Field、Method、Constructor、Superclass、Interface、Annotation 实现类的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * @author zhang * @date 2020/6/12 15:59 */public class Demo6 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class&lt;?&gt; c1 = Class.forName(\"reflect.User\"); //获得类的名字 System.out.println(c1.getName()); System.out.println(c1.getSimpleName()); //获得类的属性 Field[] fields = c1.getFields();//只能获得public修饰的 for (Field field : fields) &#123; System.out.println(field); &#125; Field[] fields1 = c1.getDeclaredFields(); for (Field field : fields1) &#123; System.out.println(field); &#125; //获得类的方法 Method[] methods = c1.getMethods();//获得本类机器父类的全部public方法 for (Method method : methods) &#123; System.out.println(method); &#125; //获得构造器 Constructor&lt;?&gt;[] constructors = c1.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) &#123; System.out.println(constructor); &#125; //获得指定的构造器 Constructor&lt;?&gt; constructor = c1.getConstructor(String.class,int.class,int.class); System.out.println(constructor); &#125;&#125; 有了class对象，能做什么？创建类的对象：调用Class对象的newInstance()方法 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 调用指定的方法 通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod(String name,Class..parameterTypes)方法取得一个Method对象，并设置此方法操作是锁需要的参数类型 之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。 Object invoke(Object obj,Object...args) Object对应原方法的返回值，若方法无返回值，此时返回null 若原方法为静态方法，此时形参Object obj可为null 若原方法参数列表为空，则Object[] args为null 若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(四)","slug":"Spring学习笔记-四","date":"2020-06-10T03:45:44.000Z","updated":"2020-06-10T03:48:29.516Z","comments":true,"path":"2020/06/10/Spring学习笔记-四/","link":"","permalink":"http://yoursite.com/2020/06/10/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/","excerpt":"Spring学习笔记","text":"Spring学习笔记 整合MyBatis步骤： 导入相关jar包 junit mybatis mysql数据库 spring相关的 aop植入 mybatis-spring【new】 编写配置文件 测试 回忆MyBatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 Mybatis-SpringMyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。 要使用 MyBatis-Spring 模块，只需要在类路径下包含 mybatis-spring-2.0.5.jar 文件和相关依赖即可。如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt;&lt;/dependency&gt; 步骤： 编写数据源 sqlSessionfactory sqlSessionTemplate 需要接口加实现类 将自己写的实现类注入到spring中测试使用 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--DataSource:使用Spring的数据源替换Mybatis的配置--&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\"/&gt; &lt;!--绑定MyBatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/demo/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionTemplate就是我们使用的sqlSession--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--只能使用构造器注入 没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"teacherMapper\" class=\"com.demo.mapper.TeacherMapperImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt;&lt;/beans&gt; TeacherMapperImpl.java 123456789101112131415161718/** * @author zhang * @date 2020/6/7 18:42 */public class TeacherMapperImpl implements TeacherMapper&#123; //我们的所有操作都需要SqlSession来执行，现在使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;Teacher&gt; selectTeacher() &#123; TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); return mapper.selectTeacher(); &#125;&#125; SqlSessionDaoSupportSqlSessionDaoSupport 是一个抽象的支持类，用来为你提供 SqlSession。调用 getSqlSession() 方法你会得到一个 SqlSessionTemplate，之后可以用于执行 SQL 方法，就像下面这样: 12345public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; public User getUser(String userId) &#123; return getSqlSession().selectOne(\"org.mybatis.spring.sample.mapper.UserMapper.getUser\", userId); &#125;&#125; 在这个类里面，通常更倾向于使用 MapperFactoryBean，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。 SqlSessionDaoSupport 需要通过属性设置一个 sqlSessionFactory 或 SqlSessionTemplate。如果两个属性都被设置了，那么 SqlSessionFactory 将被忽略。 假设类 UserMapperImpl 是 SqlSessionDaoSupport 的子类，可以编写如下的 Spring 配置来执行设置： 123&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;&lt;&#x2F;bean&gt; 声明式事务回顾事务 把一组业务当成一个业务来做，要么都成功，要么都失败 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎 确保完整性和一致性 事务的ACID原则： 原子性 一致性 隔离性 持久性 Spring中事务管理 声明式事务：AOP 编程式事务：需要在代码中，进行事务的管理 一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。 一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。 事务配置好了以后，MyBatis-Spring 将会透明地管理事务。这样在你的 DAO 类中就不需要额外的代码了。 标准配置要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象： 1234567&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"dataSource\" /&gt;&lt;/bean&gt;@Beanpublic DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource());&#125; 传入的 DataSource 可以是任何能够与 Spring 兼容的 JDBC DataSource。包括连接池和通过 JNDI 查找获得的 DataSource。 注意：为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的是同一个数据源，否则事务管理器就无法工作了。 1234567891011121314151617181920&lt;!--配置声明式事务--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"datasource\"/&gt; &lt;/bean&gt; &lt;!--结合AOP实现事务的织入--&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\"/&gt; &lt;tx:method name=\"update\"/&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.demospring.Mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt; &lt;/aop:config&gt; 为什么需要事务？ 如果不配置事务，可能存在数据提交不一致情况 如果我们不在Spring中去配置声明事务，我们就需要在代码中手动配置事务 事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不能马虎","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(三)","slug":"Spring学习笔记-三","date":"2020-06-06T10:40:01.000Z","updated":"2020-06-06T10:41:47.579Z","comments":true,"path":"2020/06/06/Spring学习笔记-三/","link":"","permalink":"http://yoursite.com/2020/06/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"Spring学习笔记","text":"Spring学习笔记 AOP什么是AOP？AOP(Aspect Oriented Programming)意为：面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发的一个热点，也是Spring框架的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP在Spring中的作用提供声明式事务；允许用户自定义切面 连接点(Joinpoint)： 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点，也可以理解连接点为：目标类上哪些有可能被增强的方法。 切点（Pointcut）：可以理解为查询条件。一个target（目标类）的所有方法都是连接点，切点可以通过查询条件定位特定的连接点。 增强（Advice）：织入目标类连接点上的一段程序代码。既包含连接点上的执行逻辑（横切逻辑、增强逻辑）又包含定位连接点的方位信息，before、after、around等。增强默认织入目标类的所有方法中。 目标对象（Target）：增强逻辑织入的目标类。 代理（Proxy）：一个类被AOP植入增强后，被产生一个结果代理类。 织入(Weaving)：将通知（增强）应用到连接点上，生成代理的过程。 切面（Aspect)：由切点和增强组成。 引介（Introduction):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice： 前置增强 BeforeAdvice 代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。后置增强 AfterAdvice 代表后增强，表示目标方法在执行后实施增强环绕增强 MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强异常抛出增强 ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强引介增强 IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性 及AOP在不改变原来代码的情况下，去增加新的功能。 使用Spring实现AOP使用AOP，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt; 方式一：使用Spring的API接口 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 注册bean--&gt; &lt;bean id=\"userService\" class=\"com.demo.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.demo.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.demo.log.AfterLog\"/&gt; &lt;!-- 配置aop--&gt; &lt;aop:config&gt; &lt;!-- 切入点 expression:表达式，execution（要执行的位置）--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/&gt; &lt;!-- 执行软绕增强--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567891011121314/** * @author zhang * @date 2020/6/6 16:15 */public class Log implements MethodBeforeAdvice &#123; //method:要执行的目标对象的方法 //args:参数 //o:目标对象 public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(o.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); &#125;&#125; 测试方法 123456789101112/** * @author zhang * @date 2020/6/6 16:36 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //动态代理的式接口 UserService userService = (UserService) context.getBean(\"userService\"); userService.delete(); &#125;&#125; 方式二：自定义来实现AOP【主要是切面定义】 DiyPointCut.java 12345678910111213/** * @author zhang * @date 2020/6/6 17:48 */public class DiyPointCut &#123; public void before()&#123; System.out.println(\"==========方法执行前\"); &#125; public void after()&#123; System.out.println(\"==========方法执行后\"); &#125;&#125; xml 12345678910&lt;bean id=\"diy\" class=\"com.demo.diy.DiyPointCut\"/&gt; &lt;aop:config&gt; &lt;!-- 自定义切面 ref引用类--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方式三：使用注解实现 12345678910111213141516/** * @author zhang * @date 2020/6/6 18:04 */@Aspect//标注这个类是一个切面public class AnnotationPointCut &#123; @Before(\"execution(* com.demo.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"----------方法执行前\"); &#125; @After(\"execution(* com.demo.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"---------方法执行后\"); &#125;&#125; 需要开启注解支持 12&lt;!--开启注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt;","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(二)","slug":"Spring学习笔记-二","date":"2020-06-03T12:01:23.000Z","updated":"2020-06-06T10:39:17.475Z","comments":true,"path":"2020/06/03/Spring学习笔记-二/","link":"","permalink":"http://yoursite.com/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/","excerpt":"Spring学习笔记","text":"Spring学习笔记 Spring配置别名12&lt;!-- 别名，如果添加了别名，我们也可以使用别名获取到对象--&gt;&lt;alias name=\"user\" alias=\"USER\"/&gt; Bean的配置12345678&lt;!-- id：Bean的唯一标识符，也就是相当于我们的对象名 class:对象对应的全限定名 name：也是别名 --&gt; &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt; &lt;property name=\"name\" value=\"Java\"/&gt; &lt;/bean&gt; import这个import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。 DI依赖注入构造器注入Set方式注入【重点】实体类属性 12345678private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private Properties info; private String wife; xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=\"student\" class=\"com.demospring.pojo.Student\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;property name=\"address\" ref=\"address\"&gt;&lt;/property&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;打篮球&lt;/value&gt; &lt;value&gt;敲代码&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"身份证\" value=\"123456789\"/&gt; &lt;entry key=\"银行卡\" value=\"987654321\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;CS&lt;/value&gt; &lt;value&gt;PUBG&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;2019052531&lt;/prop&gt; &lt;prop key=\"性别\"&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 拓展方式注入P命名空间注入需要添加xml约束 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 12&lt;!-- p命名空间注入，可以直接注入属性的值:property--&gt;&lt;bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\"/&gt; C命名空间注入需要添加xml约束 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 12&lt;!-- c命名空间注入，通过构造器注入：construct-args--&gt;&lt;bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\"/&gt; Bean的作用域 Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 1.单例模式(Spring默认机制) 1&lt;bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\" scope=\"singleton\"/&gt; 2.原型模式：每次从容器get的时候，都会产生一个新对象！ 1&lt;bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\" scope=\"prototype\"/&gt; 3.其余的request，session，application这些只能在web开发中用到 Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显式的配置 在java中显式的配置 隐式的自动装配bean【重要】 ByName自动装配123&lt;bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;/bean&gt; autowire=&quot;byName&quot; ByName：会自动在容器上下文中查找，和自己对象set方法后面的值对象的beanid！ Bytype自动装配123&lt;bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt;&lt;/bean&gt; autowire=&quot;byType&quot; ByType：会自动在容器上下文中查找，和自己对象属性类型相同的bean 小结： byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！ bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一样 使用注解实现自动装配1.导入约束：context约束 2.配置注解的支持：context:annotation-config/ 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！也可以在set方法上使用 12345@Autowired private Dog dog; @Autowired private Cat cat; private String name; 使用Autowird我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC容器存在 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value=”xxxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！ 使用注解开发在Spring4之后，需要使用注解开发，必须要保证aop的包导入了 使用注解需要导入context约束，增加注解的支持 12&lt;!-- 指定要扫描的包，这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=\"com.demospring\"/&gt; @Component:组件，放在类上，说明这个类被Spring管理了，就是Bean！ 注入属性 123456789101112/** * @author zhang * @date 2020/6/4 16:00 *///等价于 &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt;&lt;/bean&gt;@Componentpublic class User &#123; //相当于&lt;property name=\"name\" value=\"张三\"/&gt; @Value(\"张三\") public String name ;&#125; 衍生的注解 @Component有几个衍生注解，我们在web开发中，会按照MVC三成架构分层 dao【@Repository】 service【@Service】 controller【@Controller】 这四个注解的功能都是一样的，都是代表将某个类注册到Spring容器中装配 作用域 1@Scope(\"prototype\") 使用Java的方式配置Spring12345678910111213141516171819202122package com.demospring.config;import com.demospring.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author zhang * @date 2020/6/4 17:42 *///这个也会被Spring容器托管，注册到容器中，因为它本来就是一个@Component//@Configuration代表这是一个配置类，就和我们之前看的bean.xml@Configurationpublic class MyConfig &#123; //注册一个Bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bena标签的class属性 @Bean public User getUser()&#123; return new User();//就是返回要注入到bean的对象！ &#125;&#125;","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(一)","slug":"Spring学习笔记-一","date":"2020-06-03T11:57:29.000Z","updated":"2020-06-03T12:00:30.325Z","comments":true,"path":"2020/06/03/Spring学习笔记-一/","link":"","permalink":"http://yoursite.com/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"Spring学习笔记","text":"Spring学习笔记 简介 简介：Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从 Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合现有的技术框架！ SSM：SpringMvc + Spring + Mybatis！ 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 优点： Spring是一个开源的免费的框架(容器)！ Spring一个轻量级的、非入侵式的框架 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理,对框架整合的支持 总结：Spring就是一个轻量级的控制反转(IOC)和切面编程的框架！ 组成 核心容器（Spring Core） 核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。 应用上下文（Spring Context） Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring面向切面编程（Spring AOP） 通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 JDBC和DAO模块（Spring DAO） JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。 对象实体映射（Spring ORM） Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。 Web模块（Spring Web） Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 MVC模块（Spring Web MVC） MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。 IOC理论控制反转Ioc(Inversion of Control)，是一种设计思想，DI(依赖注入)式实现IoC的一种方法，也有人认为Di只是Ioc的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象创建转移给第三方，个人认为所谓的控制反转就是：获得依赖对象的方式反转了 采用XML配置Bean的时候，Bean的定义信息是和实现分离的，而采用注入的方式可以把二者和为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到零配置的目的 控制反转是一种通过描述(XML或注解)并通过第三方去生产或者获取特定对象的方式。在Spring中实现控制反转的是Ioc容器，其实现方法是依赖注入(Dependency Injection,DI) 由容器动态地将某种依赖关系注入到组件之间。控制反转也称为”依赖注入“（Dependency Injection DI) IoC/DI示例：依赖注入是Java编程思想中”面向接口编程“的体现，因此在设计程序是，对于程序所依赖的组件往往以忌口的形式出现，而不直接使用具体的实现类 第一个Spring程序 besns.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt; &lt;property name=\"name\" value=\"Java\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码 123456789101112131415import com.demospring.pojo.User;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author zhang * @date 2020/6/2 17:05 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); user.show(); &#125;&#125; 实体类 12345678910111213141516171819202122232425262728package com.demospring.pojo;/** * @author zhang * @date 2020/6/2 17:03 */public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"name---&gt;\"+name); &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 总结：在配置文件加载的时候，容器中的管理对象就已经初始化了！","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2020-05-31T08:08:51.000Z","updated":"2020-05-31T08:20:14.776Z","comments":true,"path":"2020/05/31/Java多线程/","link":"","permalink":"http://yoursite.com/2020/05/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"Java多线程笔记","text":"Java多线程笔记 多线程 说起进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念 而进程则是执行程序的一次执行过程，它是一个动态概念。是系统资源分配的单位 通常一个进程可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。 本章核心概念 线程就是独立的执行路径 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程mian，gc线程 main()称为主线程，为系统入口，用于执行整个程序 在一个线程中，如果开辟了多个线程，线程的运行有调度器安排调度，调度器是与操作系统机密相关的，先后顺序是不能认为的干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制 线程会带来额外的开销，如cpu调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 线程创建三种创建方式： 继承Thread类(重点) 实现Runnable接口(重点) 实现Callable(了解) Thread类1.自定义线程类继承Thread类 2.重写run()方法，编写线程执行体 3.创建线程对象，调用start()方法启动线程 1234567891011121314151617181920212223package thread;public class TestThread extends Thread&#123; @Override public void run() &#123; super.run(); for (int i=0;i&lt;20;i++)&#123; System.out.println(\"run方法\"+i); &#125; &#125; public static void main(String[] args) &#123; //main线程，主线程 //创建一个线程对象，调用start方法开启线程 TestThread testThread = new TestThread(); testThread.start(); for (int i = 0; i &lt; 200; i++) &#123; System.out.println(\"主线程\"+i); &#125; &#125;&#125; 多线程实现网图下载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package thread;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;//联系Thread，实现多线程同步下载public class TestThread2 extends Thread&#123; private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name)&#123; this.url = url; this.name = name; &#125; //下载图片的线程执行体 @Override public void run() &#123; WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载了文件名为：\"+name); &#125; public static void main(String[] args) &#123; TestThread2 testThread1 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%911.png\",\"D:/a_test/1.jpg\"); TestThread2 testThread2 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%912.png\",\"D:/a_test/2.jpg\"); TestThread2 testThread3 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%913.png\",\"D:/a_test/3.jpg\"); testThread1.start(); testThread2.start(); testThread3.start(); &#125;&#125;//下载器class WebDownloader&#123; //下载方法 public void downloader(String url,String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url),new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Runnable接口1.实现MyRunnable类实现Runnable接口 2.实现run()方法，编写线程执行体 3.创建线程对象，调用start()方法启动线程 123456789101112131415161718192021222324package thread;public class TestThread3 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"run方法\"+i); &#125; &#125; public static void main(String[] args) &#123; //创建runnable接口的实现类 TestThread3 testThread3 = new TestThread3(); //创建线程对象，通过线程对象开启线程，代理 Thread thread = new Thread(testThread3); thread.start(); //new Thread(new TestThread3()).start(); for (int i = 0; i &lt; 200; i++) &#123; System.out.println(\"主线程\"+i); &#125; &#125;&#125; 小结 继承Thread类 子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 实现Runnable接口 实现Runnable具有多线程能力 线程启动：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 初识并发问题123456789101112131415161718192021222324252627282930313233package thread;/** * 多个线程操作一个对象 * 买火车票 */public class TestThread4 implements Runnable&#123; //票数 private int ticketNums = 10; @Override public void run() &#123; while (true)&#123; if (ticketNums&lt;=0)&#123; break; &#125; //模拟延迟 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"----&gt;拿到了第\"+ticketNums--+\"张票\"); &#125; &#125; public static void main(String[] args) &#123; TestThread4 t4 = new TestThread4(); new Thread(t4,\"小明\").start(); new Thread(t4,\"老师\").start(); new Thread(t4,\"黄牛\").start(); &#125;&#125; 发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 线程状态 Thread.State NEW ​ 尚未启动的线程处于此状态 RUNNABLE ​ 在Java虚拟机中执行的线程处于此状态 BLOCKED ​ 阻塞等待监视器锁定的线程处于此状态 WAITTING ​ 正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WATTING ​ 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED ​ 已退出的线程处于此状态 线程优先级Java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级来决定应该调度哪个线程先执行 线程的优先级用数字表示,范围1~10 Thread.MIN_PRIORITY = 1; Thread.MAX_PRIORITY = 10; Thread.NORM_PRIORITY = 5; 使用以下方式改变和获取优先级 getPriority() setPriority(int xxx) 注意：优先级低只是意味这获得调度的概率低，并不是优先级低就不会被调用了，这都看cpu的调度 线程方法 方法 说明 setPriority(int newPriority) 更改线程的优先级 static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠 void join() 等待该线程终止 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 void interrupt() 中断线程，别用这个方式 boolean isAlive() 测试线程是否处于活动状态 停止线程 不推荐使用JDK提供的stop()、destory()方法。【已废弃】 推荐线程自己停下来 建议用一个标志位进行终止变量，放flag = false，则终止线程运行 12345678910111213141516171819202122232425262728293031323334353637383940package thread;/** * 测试stop * 建议线程正常停止--&gt;利用次数，不建议死循环 * 建议使用标志位--&gt;设置一个标志位 * 不用使用stop或者destory等过时或者JDK不建议使用的方法 */public class TestThread5 implements Runnable&#123; //设置一个标志位 private boolean flag = true; @Override public void run() &#123; int i = 0; while (flag)&#123; System.out.println(\"run....Thread\"+i++); &#125; &#125; //设置一个公开的方法停止线程，转换标志位 public void stop()&#123; this.flag = false; &#125; public static void main(String[] args) &#123; TestThread5 thread5 = new TestThread5(); new Thread(thread5).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"main\"+i); if (i == 900)&#123; //调用stop方法切换标志位，让线程停止 thread5.stop(); System.out.println(\"线程该停止了\"); &#125; &#125; &#125;&#125; 线程休眠 sleep(时间)指定当前路线阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 线程礼让 线程礼让，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功！看CPU心情 1234567891011121314151617181920package thread;public class TestYield &#123; public static void main(String[] args) &#123; MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"线程开始执行\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行\"); &#125;&#125; join Join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞 可以想象成插队 守护线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕，如后台记录操作日志，监控内存，垃圾回收等等。 线程同步(重点)并发：多个线程操作同一个资源 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程池使用完毕，下一个线程再使用 由于同一进程的多个线程共享同一块存储空间，在带了方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入了锁机制synchronized,当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可，存在一下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题 由于我们可以通private关键字来保证数据对象只能被方法访问，所有我们只需要对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块 同步方法：public synchronized void method(int args){} synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。 缺陷：若将一个大的方法申明为synchronized将会影响效率 同步块synchronized(obj){ } Obj称为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。 同步监视器的执行过程 1.第一个线程访问，锁定同步监视器，执行其中代码 2.第二个线程访问，发现同步监视器被锁定，无法访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问 死锁多个线程各自占有一些资源，并且相互等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情况。某一个同步块同时拥有“两个以上对象的锁”时就可能会发生“死锁问题”。 死锁避免的方法产生死锁的四个必要条件 1.互斥条件：一个资源每次只能被一个进程使用 2.请求与保持条件：一个进程因请求资源时而被阻塞，对己获得的资源保持不放 3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 4.循环等待条件：若干进程之间实现了一种头尾相接的循环等待资源关系 上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或者多个条件就可以避免死锁发生 Lock(锁) 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口时控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比价常用的是ReentrantLock，可以显式加锁，释放锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package thread;import java.util.concurrent.locks.ReentrantLock;/** * @author zhang * @date 2020/5/31 10:24 */public class TestLock &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,\"小明\").start(); new Thread(buyTicket,\"小红\").start(); new Thread(buyTicket,\"黄牛\").start(); &#125;&#125;class BuyTicket implements Runnable&#123; int ticketNum = 10; //定义Lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try &#123; lock.lock();//加锁 if (ticketNum&gt;0)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"买到了\"+ticketNum--); &#125;else &#123; break; &#125; &#125;finally &#123; //解锁 lock.unlock(); &#125; &#125; &#125;&#125; synchronized与Lock的对比 Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了作用域会自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类) 优先使用顺序 Lock&gt;同步代码块(已经进入了方法体，分配相应资源)&gt;同步方法(在方法体之外) 线程通信Java提供了几个方法解决线程之间的通信问题 方法名 作用 wait() 表示线程一直等待，知道线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个正处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常lllegalMonitorStateException 线程池背景：经常创建和销毁使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁的创建和销毁、实现重复利用。类似生活中的交通工具 好处： 提高相应速度(减少了创建新线程的时间) 降低资源消耗(重复利用线程池中的线程，不需要每次创建) 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后终止 使用线程池JDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExector void execute(Runnnable command):执行任务/命令，没有返回值，一般用于执行Runnable Future submit(Callable task):执行任务，有返回值，一般用于执行Callable void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 123456789101112131415161718192021222324252627282930313233package thread;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author zhang * @date 2020/5/31 14:58 * 测试线程池 */public class TestPool &#123; public static void main(String[] args) &#123; //创建线程池 ExecutorService service = Executors.newFixedThreadPool(10); //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //关闭连接 service.shutdown(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"mybatis框架(四)","slug":"mybatis框架-四","date":"2020-05-27T07:10:29.000Z","updated":"2020-05-31T08:32:57.008Z","comments":true,"path":"2020/05/27/mybatis框架-四/","link":"","permalink":"http://yoursite.com/2020/05/27/mybatis%E6%A1%86%E6%9E%B6-%E5%9B%9B/","excerpt":"mybatis笔记(四)","text":"mybatis笔记(四) 动态SQL什么是动态SQL：根据不同的条件生成不同的SQL 所谓的动态SQl，本质还是SQL语句，只是我么可以在SQl层面，去执行一个逻辑代码 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach ifBlogMapper.xml代码 123456789&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog where 1 = 1 &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/select&gt; choose、when、otherwise有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。 12345678910111213141516&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title!=null\"&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author!=null\"&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 只会选择其中一个条件实现，前面的实现后面的就不看了 trim、where、setwhere 如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样： 12SELECT * FROM BLOGWHERE 这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样: 123SELECT * FROM BLOGWHEREAND title like ‘someTitle’ 这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。 MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动： where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 set 用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。 set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 123456789101112&lt;update id=\"updateBlogSet\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"titlt != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; SQL片段有的时候，我们可能将一些功能的部分抽取出来，方便复用 1.使用sql标签抽取公共部分 2.在需要使用的的地方使用include标签引用即可 注意事项： 1.最好基于单表来定义SQL！ 2.不要存在where foreachforeach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ 提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 123456789&lt;select id=\"queryForeach\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;foreach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 缓存简介1.什么是缓存？ 存在内存的临时数据 将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 2.为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 3.什么样的数据能使用缓存 经常查询并且不经常改变的数据 MyBatis缓存 MyBatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率 MyBatis系统中定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称本地缓存) 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中哪，没必要在去查询数据库 缓存失效的情况： 1.查询不同的东西 2.增删改操作，可能会改变原来的数据，所有必定会刷新缓存！ 3.查询不同Mapper.xml 4.手动清理缓存 小结 一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个去加段！ 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名门空间对应一个二级缓存 工作机制： 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据会放在自己对应的缓存中 步骤： 1.开启全局缓存 12&lt;!-- 开启全局缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 2.在要使用二级缓存的Mapper中开启","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mybatis框架(三)","slug":"mybatis框架-三","date":"2020-05-24T11:41:01.000Z","updated":"2020-05-27T00:25:40.396Z","comments":true,"path":"2020/05/24/mybatis框架-三/","link":"","permalink":"http://yoursite.com/2020/05/24/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%89/","excerpt":"mybatis笔记(三)","text":"mybatis笔记(三) 注解开发1.注解在接口上使用 12@Select(\"select * from student\") List&lt;Student&gt; getStudents(); 2.需要在核心配置文件中绑定接口 12345&lt;mappers&gt;&lt;!-- &lt;mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/&gt;--&gt;&lt;!-- &lt;mapper class=\"cn.demomybatis.dao.StudentDao\"/&gt;--&gt; &lt;package name=\"cn.demomybatis.dao\"/&gt; &lt;/mappers&gt; 本质：反射机制实现 底层：动态代理！ MyBatis详细执行流程 CRUD我们可以在创建工具类的时候实现自动提交事务！ 123public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 编写接口，增加注释 12345678910//方法存在多个参数，所有参数前面必须加上@Param注解 @Select(\"select * from student where id = #&#123;id&#125;\") Student getStudentById1(@Param(\"id\") int id); @Insert(\"insert into student(id,name,age,phone) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;phone&#125;)\") int addStudent1(Student student); @Update(\"update student set name=#&#123;name&#125;,age=#&#123;age&#125;,phone=#&#123;phone&#125; where id = #&#123;id&#125;\") int updateStudent1(Student student); 关于@Param注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名！ Lombok使用步骤： 1.在IDEA中安装Lombok插件 2.在项目导入Lombok的jar包 3. 123@Data：生成无参构造，get，set，toString，hashcode，equals@AllArgsConstructor 有参构造方法@NoArgsConstructor 无参构造方法 多对一处理按照插叙嵌套处理1234567891011121314151617181920&lt;!-- 思路： 1.查询所有的学生信息 2.根据查询出来的tid，寻找对应的老师！ 子查询--&gt; &lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student &lt;/select&gt; &lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt; 按照结果嵌套处理12345678910&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id; &lt;/select&gt; &lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多处理同理 小结1.关联 - association 【多对一】 2.集合 - collection 【一对多】 3.javaTape：用来指定实体类中属性的类型 4.ofType：用来指定映射到List或者集合中的实体类类型，泛型中的约束类型","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"mybatis框架(二)","slug":"mybatis框架-二","date":"2020-05-22T11:08:13.000Z","updated":"2020-05-23T10:34:51.915Z","comments":true,"path":"2020/05/22/mybatis框架-二/","link":"","permalink":"http://yoursite.com/2020/05/22/mybatis%E6%A1%86%E6%9E%B6-%E4%BA%8C/","excerpt":"mybatis笔记(二)","text":"mybatis笔记(二) 配置解析核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 环境配置MyBatis可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例智能选择一种环境。 Mybatis默认的事务管理器就是JDBC，连接池POOLED 属性(properties)我们可以通过properties属性实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 编写一个配置文件:db.properties 1234driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?serverTimezone=UTCusername=rootpassword=root 在核心配置文件中引入 12&lt;!-- 引入外部配置文件--&gt; &lt;properties resource=\"db.properties\"/&gt; 类型别名类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。 1234&lt;!-- 可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"cn.demomybatis.domain.Student\" alias=\"Student\"/&gt; &lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，他的默认别名就为这个类的类名首字母小写 设置 设置名 描述 有效值 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true|False false 映射器MapperRegistry:注册绑定我们的Mapper文件 方式一： 1234&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/&gt;&lt;/mappers&gt; 方式二： 1234&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=\"cn.demomybatis.dao.StudentDao\"/&gt;&lt;/mappers&gt; 方式三： 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"cn.demomybatis.dao\"/&gt;&lt;/mappers&gt; 生命周期和作用域生命周期和作用域是只管重要的，因为错误的使用会导致非常严重的并发问题 解决属性名和字段名不一致问题resultMap结果集映射 12345&lt;!-- 结果集映射--&gt; &lt;resultMap id=\"StudentMap\" type=\"Student\"&gt; &lt;!-- column是数据库中的字段，property是实体类中的字段--&gt; &lt;result column=\"u_id\" property=\"id\"&gt;&lt;/result&gt; &lt;/resultMap&gt; resultMap元素是MyBatis中最重要最强大的元素 ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，对于复杂一点的语句只需要猫叔他们的关系就行了 ResultMap最优秀的地方在于，虽然你已经对他相当了解了，但根本不需要显式的用到他们。 日志日志工厂如果一个数据库操作出现了异常，我们需要排错。日志就是最好的帮手！ 设置名 描述 有效值 默认值 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J，LOG4J，LOG4J2，JDK_LOGGING，COMMONS_LOGGING，STDOUT_LOGGING，NO_LOGGING 未设置 1234&lt;settings&gt; &lt;!-- 标准的日志实现--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; LOG4J什么式log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 1.先导入LOG4J的jar包 2.log4j.properties配置文件 12345678910111213141516171819202122232425262728293031############################################### Log4J 配置文件############################################### 定义缺省的日志级别和输出对象log4j.rootLogger=DEBUG,INFO, logfile,console# 设定控制台输出模式log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%d&#123;MM/dd HH:mm:ss&#125;] [%-3p] %c&#123;1&#125;: %m%n# 针对package定义日志级别log4j.logger.org.apache=WARNlog4j.logger.com.paic.pafademo=DEBUG# 设定日志文件的输出模式log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.logfile.DatePattern=yyyyMMdd# $&#123;pafa.log.home&#125;通过参数-D指定，比如启动WebLogic时加入参数-Dpafa.log.home=c:/log4j.appender.logfile.File=$&#123;log.home&#125;/appdemo/pafa.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d&#123;MM/dd HH:mm:ss&#125; [%-3p] %c&#123;1&#125;: %m%n# 如果要查看iBATIS的SQL日志信息，确保有下面配置log4j.logger.com.ibatis=DEBUGlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 3.配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; 简单使用1.在要使用的Log4j的类中，导入import org.apache.log4j.Logger; 2.日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(mybatistest.class); 分页使用limit分类使用MyBatis实现分页，核心SQL 1.接口 12//分页 List&lt;Student&gt; getStudentByLimit(Map&lt;String,Integer&gt; map); 2.StudentDao.xml 123&lt;select id=\"getStudentByLimit\" resultType=\"Student\" parameterType=\"map\"&gt; select * from student limit #&#123;startIndex&#125;,#&#123;pageSize&#125; &lt;/select&gt; 3.测试 12345678910111213@Test public void getStudentByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); StudentDao studentDao = sqlSession.getMapper(StudentDao.class); Map&lt;String,Integer&gt; map = new HashMap(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List&lt;Student&gt; studentList = studentDao.getStudentByLimit(map); for (Student student : studentList) &#123; System.out.println(student); &#125; sqlSession.close(); &#125; RowBounds分页","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"ngork内网穿透","slug":"ngork内网穿透","date":"2020-05-22T01:11:58.000Z","updated":"2020-05-22T01:30:42.390Z","comments":true,"path":"2020/05/22/ngork内网穿透/","link":"","permalink":"http://yoursite.com/2020/05/22/ngork%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"将本地的项目运行在公网上","text":"将本地的项目运行在公网上 1.进入ngrok官网（http://www.ngrok.cc/），注册ngrok账号2.登录–&gt;隧道管理–&gt;开通隧道找到免费的 隧道名称和前置域名随便填就行了 端口填自己tomcat的端口 点击客户端下载 下载完成之后点击启动工具 输入隧道id 显示这个就已经成功了 可以通过上边哪个域名访问自己本地的项目了","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"PicGo+GitHub图床，让Markdown飞","slug":"PicGo-GitHub图床，让Markdown飞","date":"2020-05-21T11:19:47.000Z","updated":"2020-05-23T10:56:51.923Z","comments":true,"path":"2020/05/21/PicGo-GitHub图床，让Markdown飞/","link":"","permalink":"http://yoursite.com/2020/05/21/PicGo-GitHub%E5%9B%BE%E5%BA%8A%EF%BC%8C%E8%AE%A9Markdown%E9%A3%9E/","excerpt":"PicGo+GitHub图床","text":"PicGo+GitHub图床 一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种“轻量级标记语言”。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：Typora和马克飞象。 目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都近乎完美但是却又不能达到完美。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是将截图存放在本机电脑上，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。 这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：PicGo+GitHub图床 注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户） PicGo介绍这是一款图片上传的工具，目前支持微博图床，七牛图床，腾讯云，又拍云，GitHub等图床，未来将支持更多图床。 所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。 Pic Go支持的图床 在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。 创建自己的GitHub图床1. 创建GitHub图床之前，需要注册/登陆GitHub账号 申请GitHub账号很简单，我就不演示了 2. 创建Repository 点击”New repository”按钮 我已经建立过一个同名的repository的，所以第一步会显示红色 第三步，为repository初始化一个README.md文件可以根据需求选择，非必选 3.生成一个Token用于操作GitHub repository 回到主页，点击”Settings”按钮 进入页面后，点击”Developer settings”按钮 点击”Personal access tokens”按钮 创建新的Token 填写描述，选择”repo”,然后点击”Generate token”按钮 注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存 配置PicGo1. 下载运行PicGo 推荐下载exe可执行文件 2. 配置图床 如图配置 设定仓库名的时候，是按照“账户名/仓库名的格式填写” 分支名统一填写“master” 将之前的Token黏贴在这里 存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹 自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/用户名/RepositoryName/分支名，，自定义域名需要按照这样去填写 总结将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下ctrl+shift+c，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！。 自己在本地用确实没有什么问题，但是提交到博客上发现图片加载失败，或者加载异常慢，于是我发现了一种加速的方法 CDN 简介 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。—— Wikipedia 简而言之就是让服务器距离大陆较远的 GitHub ，将托管在那里的静态资源缓存到一个近一点的服务器，从而加快访问。 看了这样的解释你应该能够理解，CDN 虽然能缓解互联压力，可也是要耗费一定的资源的，从而市面上的 CDN 大多是收费的。Cloudflare 虽然有免费 CDN ，可是国内节点致开放给专业版用户使用，价格偏高，而海外的节点又类似负优化，可能还会降低速度。 jsDelivrjsDelivr是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。 有搜索引擎，支持一键复制文件 URL 和标签，支持分发 NPM、GitHub、WordPress SVN 的文件 基础使用可能看起来，官方的使用方法十分复杂，但其实就一句话：把仓库链接的域名替换成 jsDelivr 的域名。 如托管在 GitHub 的仓库链接都是 https://github.com/username/repo/branch/file 的形式，而我们就可以将前面的 github.com 改成 jsDelivr 提供加速 GitHub 仓库的域名 cdn.jsdelivr.net/gh 。 嗯，兴冲冲配置一发，发现什么都没有？其实还是有一点点小差别的。比如分支那里，jsDelivr 默认要直接在仓库名后面 @ ，所以真正其实是 https://cdn.jsdelivr.net/gh/username/repo@branch/file 的形式。当然，如果你放在仓库的默认分支，还可以直接将 branch 这个关键字直接删了，变成 https://cdn.jsdelivr.net/gh/username/repo/file 一样能获取到！ 另外，如果是一些比较稳定的文件，后面不会频繁地改动，还可以发布成一个版本，然后在 repo 后 @version 就可以引用对应的版本。 加速图床如果你还记得笔者之前写的 PicGo + GitHub 搭建免费图床 的话，不难发现 jsDelivr 也是能加速这个图床（本质不还是一个 GitHub 仓库嘛）的。我们只需要在 GitHub 图床设置 中将链接设置为 https://cdn.jsdelivr.net/gh/username/repo 即可！前提是你上传到默认分支。","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"mybatis框架(一)","slug":"mybatis框架-一","date":"2020-05-19T11:04:42.000Z","updated":"2020-05-22T11:12:13.440Z","comments":true,"path":"2020/05/19/mybatis框架-一/","link":"","permalink":"http://yoursite.com/2020/05/19/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%80/","excerpt":"mybatis笔记(一)","text":"mybatis笔记(一) mybatis概述mybatis是一个持久层框架，用java编写，封装了很多jdbc细节，开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程，它使用了ORM思想，实现了结果集的封装。 ORM：Object Relational Mappging 对象关系映射简单的说：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类及实现操作数据库 mybatis环境搭建 1.创建maven工程并导入坐标12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.18&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2.创建实体类和dao接口 3.创建mybatis的主配置文件SqlMapConfig.xml 4.创建映射配置文件注意事项 1.包在创建时 com.demomybatis.dao他是三级目录结构 2.mybatis的映射配置文件位置必须和dao接口的包结构相同 3.映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定而类名 4.映射配置文件的擦偶哦配置(select) id的取值必须是dao接口的方法名 当我们遵从2，3，4点之后，我们开发中就无需再写dao的实现类 SqlMapConfig.xml代码1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default&#x3D;&quot;mysql&quot;&gt; &lt;environment id&#x3D;&quot;mysql&quot;&gt; &lt;!--使用jdbc事务管理 --&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;!-- 数据库连接池(数据源) --&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!-- 引入映射配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;cn&#x2F;demomybatis&#x2F;dao&#x2F;StudentDao.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; StudentDao.xml代码123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace：命名空间，用于隔离sql--&gt;&lt;mapper namespace&#x3D;&quot;cn.demomybatis.dao.StudentDao&quot;&gt; &lt;!-- 配置查询所有 id为dao的方法名--&gt; &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;cn.demomybatis.domain.Student&quot; parameterType&#x3D;&quot;cn.demomybatis.domain.Student&quot;&gt; select * from student &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; mybatis入门案例： 1.读取配置文件 2.创建SqlSessionFactory工厂 3.创建SqlSession 4.创建Dao接口的代理 5.执行Dao中的方法 6.释放资源 注意：需要在映射配置中告知mybatis要封装到哪个实体类中，配置的方式：指定实体类的全类名 增删改需要提交事务 sqlSession.commit() 测试代码1234567891011121314151617181920212223242526272829303132333435363738package cn.demomybatis.test;import cn.demomybatis.dao.StudentDao;import cn.demomybatis.domain.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;&#x2F;** * mybatis入门 *&#x2F;public class mybatistest &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;读取配置文件 InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); &#x2F;&#x2F;创建工厂 SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder(); SqlSessionFactory factory &#x3D; builder.build(in); &#x2F;&#x2F;使用工厂生产SqlSession对象 SqlSession sqlSession &#x3D; factory.openSession(); &#x2F;&#x2F;创建Dao接口的代理对象 StudentDao studentDao &#x3D; sqlSession.getMapper(StudentDao.class); &#x2F;&#x2F;使用代理对象执行方法 List&lt;Student&gt; list &#x3D; studentDao.findAll(); for (Student student:list)&#123; System.out.println(student); &#125; &#x2F;&#x2F;释放资源 sqlSession.close(); in.close(); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"抽取Servlet","slug":"抽取Servlet","date":"2020-05-13T09:15:56.000Z","updated":"2020-05-17T07:41:58.636Z","comments":true,"path":"2020/05/13/抽取Servlet/","link":"","permalink":"http://yoursite.com/2020/05/13/%E6%8A%BD%E5%8F%96Servlet/","excerpt":"BaseServlet代码","text":"BaseServlet代码 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.travel.web.servlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;完成方法的分发 &#x2F;&#x2F;获取请求路径 String uri &#x3D; req.getRequestURI(); System.out.println(&quot;请求uri:&quot;+uri); &#x2F;&#x2F;获取方法对象 String methodName &#x3D; uri.substring(uri.lastIndexOf(&quot;&#x2F;&quot;)+1); System.out.println(&quot;方法名称：&quot;+methodName); &#x2F;&#x2F;获取方法对象Method try &#123; Method method &#x3D; this.getClass().getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class); &#x2F;&#x2F;暴力反射 &#x2F;&#x2F;method.setAccessible(true); &#x2F;&#x2F;执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; UserServlet代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198package cn.travel.web.servlet;import cn.travel.damain.ResultInfo;import cn.travel.damain.User;import cn.travel.service.UserService;import cn.travel.service.impl.UserServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;&#x2F;user&#x2F;*&quot;)public class UserServlet extends BaseServlet &#123; &#x2F;** * 注册功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void regist(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;验证码校验 String checkcode &#x3D; request.getParameter(&quot;checkcode&quot;); String checkcode_session &#x3D; (String) request.getSession().getAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;防止验证码复用 保证验证码只能使用一次 request.getSession().removeAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;比较 if (checkcode_session &#x3D;&#x3D; null || !checkcode_session.equalsIgnoreCase(checkcode)) &#123; ResultInfo info &#x3D; new ResultInfo(); info.setFlag(false); info.setErrorMsg(&quot;验证码错误&quot;); &#x2F;&#x2F;将info对象序列化为json ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(info); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); return; &#125; &#x2F;&#x2F;获取数据 String username &#x3D; request.getParameter(&quot;username&quot;); String password &#x3D; request.getParameter(&quot;password&quot;); String name &#x3D; request.getParameter(&quot;name&quot;); String birthday &#x3D; request.getParameter(&quot;birthday&quot;); String email &#x3D; request.getParameter(&quot;email&quot;); &#x2F;&#x2F;封装对象 User user &#x3D; new User(); user.setUsername(username); user.setPassword(password); user.setName(name); user.setBirthday(birthday); user.setEmail(email); &#x2F;&#x2F;调用service完成注册 UserService service &#x3D; new UserServiceImpl(); boolean flag &#x3D; service.regist(user); &#x2F;&#x2F;响应结果 ResultInfo resultInfo &#x3D; new ResultInfo(); if (flag) &#123; &#x2F;&#x2F;注册成功 resultInfo.setFlag(true); &#125; else &#123; &#x2F;&#x2F;注册失败 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;注册失败！&quot;); &#125; &#x2F;&#x2F;将resultInfo对象序列化为JSON，并写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); &#x2F;&#x2F;将json数据写回客户端 &#x2F;&#x2F;设置content-type response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 登录功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取用户名和密码数据 Map&lt;String, String[]&gt; map &#x3D; request.getParameterMap(); &#x2F;&#x2F;分装user对象 User user &#x3D; new User(); try &#123; BeanUtils.populate(user, map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;调用service查询 UserService service &#x3D; new UserServiceImpl(); User u &#x3D; service.login(user); &#x2F;&#x2F;判断 ResultInfo resultInfo &#x3D; new ResultInfo(); if (u &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;用户名密码错误 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;用户名或密码错误!&quot;); &#125; &#x2F;&#x2F;判断用户是否激活 if (u !&#x3D; null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;用户尚未激活 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;您尚未激活，请前往邮箱激活!&quot;); &#125; &#x2F;&#x2F;登录成功的判断 if (u !&#x3D; null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;登录成功 resultInfo.setFlag(true); &#125; request.getSession().setAttribute(&quot;user&quot;, u); &#x2F;&#x2F;响应数据 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 查找单个对象 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); &#x2F;&#x2F;将user写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); mapper.writeValue(response.getOutputStream(), user); &#125; &#x2F;** * 退出 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void exit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;销毁session request.getSession().invalidate(); &#x2F;&#x2F;跳转页面 重定向 response.sendRedirect(request.getContextPath() + &quot;&#x2F;login.html&quot;); &#125; &#x2F;** * 激活 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void active(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取激活码 String code &#x3D; request.getParameter(&quot;code&quot;); if (code !&#x3D; null) &#123; &#x2F;&#x2F;调用service完成激活 UserService service &#x3D; new UserServiceImpl(); Boolean flag &#x3D; service.active(code); &#x2F;&#x2F;判断标记 String msg &#x3D; null; if (flag) &#123; &#x2F;&#x2F;激活成功 msg &#x3D; &quot;激活成功，请&lt;a href&#x3D;&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;; &#125; else &#123; &#x2F;&#x2F;激活失败 msg &#x3D; &quot;激活失败，联系管理员&quot;; &#125; response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); response.getWriter().write(msg); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"redis数据库","slug":"redis数据库","date":"2020-05-01T04:10:36.000Z","updated":"2020-10-24T07:12:54.071Z","comments":true,"path":"2020/05/01/redis数据库/","link":"","permalink":"http://yoursite.com/2020/05/01/redis%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"Redis","text":"Redis 下载：百度云下载 提取码：o1ui Github下载 概念：一款高性能的NOSQL系列的非关系型数据库命令：redis存储的是：key，value格式的数据，其中key都是字符串，value有5中不同的数据结构 value的数据结构 1.字符串类型 string 2.哈希类型 hash ：相当于map集合 3.列表集合 list ：linkedlist格式 4.集合类型 set 5.有序集合类型 sortedset字符串类型string1.存储 set key value 2.获取 get key 3.删除 del key 哈希类型 hash1.存储 hset key field value 2.获取 hget key field hgetall key 获取所有的键和值 3.删除 hdel key field 列表类型 list1.lpush key value 将元素加入列表左边 2.rpush key value 将元素加入列表右边 3.lrange key start end 获取范围 4.lpop key 删除列表最左边的元素，并将元素返回 5.rpop key 删除列表最右边的元素 集合类型 set1.存储：sadd key value 2.获取：smembers key ：获取集合中所有元素 3.删除：srem key value ：删除集合的某个元素 有序集合类型 sortedset1.存储：zadd key score value 2.获取：zrange key start end 3.删除：zrem key value 通用命令：1.keys * ：查询所有的键 2.type key：获取键对应的value的类型 3.del key：删除指定的key value 持久化存储 1.redis是一个内存数据库，东redis服务器重启后，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘中 2.redis持久化机制 1.RDB：默认方式。 在一定的间隔时间中，检测key的变化情况，然后去持久化数据 2.AOF：日志记录的方式，可以检测每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windows.conf文件 appendonly no 给成yes Java客户端JedisJedis是一款java操作redis数据库的工具Jedis连接池：JedisPool1.创建JedisPool连接池对象 2.调用getResource()方法获取Jedis的连接工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142package cn.jedis.utlis;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;&#x2F;*JedisPool工具类加载配置文件，配置连接池参数提供获取连接的方法 *&#x2F;public class JedisPoolUtils &#123; private static JedisPool jedisPool; static &#123; &#x2F;&#x2F;读取配置文件 InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); &#x2F;&#x2F;创建一个Properties对象 Properties pro &#x3D; new Properties(); &#x2F;&#x2F;关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中 JedisPoolConfig config &#x3D; new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); &#x2F;&#x2F;初始化JedisPool jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; &#x2F;&#x2F;获取连接 public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; SpringBoot整合Redis 导入Redis启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在配置文件中配置Redis参数，默认存在，不配也可 12345# 配置redis数据库spring: redis: host: localhost port: 6379 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.gem;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.StringRedisTemplate;import java.util.List;import java.util.Set;/** * @author zhang * @date 2020/10/24 10:10 */@SpringBootTestpublic class RedisTest &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test public void test1()&#123; //String字符串 key相同会覆盖掉 //stringRedisTemplate.opsForValue().set(\"name\",\"tom\"); //System.out.println(\"str = \" + stringRedisTemplate.opsForValue().get(\"name\")); //hash散列 相当于map stringRedisTemplate.boundHashOps(\"h_key\").put(\"name\",\"张三\"); stringRedisTemplate.boundHashOps(\"h_key\").put(\"age\",\"12\"); //获取所有域 Set set = stringRedisTemplate.boundHashOps(\"h_key\").keys(); System.out.println(set); //获取所有值 List list = stringRedisTemplate.boundHashOps(\"h_key\").values(); System.out.println(list); //list列表 stringRedisTemplate.boundListOps(\"l_key\").leftPush(\"c\"); stringRedisTemplate.boundListOps(\"l_key\").leftPush(\"b\"); stringRedisTemplate.boundListOps(\"l_key\").leftPush(\"a\"); //获取所有元素 List l_key = stringRedisTemplate.boundListOps(\"l_key\").range(0,-1); System.out.println(l_key); //set集合 stringRedisTemplate.boundSetOps(\"s_key\").add(\"a\",\"b\",\"c\"); Set s_key = stringRedisTemplate.boundSetOps(\"s_key\").members(); System.out.println(s_key); //sorted set 有序集合 需要天机成绩 用于排序 stringRedisTemplate.boundZSetOps(\"z_key\").add(\"a\",10); stringRedisTemplate.boundZSetOps(\"z_key\").add(\"b\",40); stringRedisTemplate.boundZSetOps(\"z_key\").add(\"c\",30); System.out.println(stringRedisTemplate.boundZSetOps(\"z_key\").range(0,-1)); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"AJAX和JSON","slug":"ajax和JSON","date":"2020-04-28T11:12:12.000Z","updated":"2020-05-17T07:39:30.306Z","comments":true,"path":"2020/04/28/ajax和JSON/","link":"","permalink":"http://yoursite.com/2020/04/28/ajax%E5%92%8CJSON/","excerpt":"AJAX","text":"AJAX 概念：ASynchronous JavaScript And XML 异步的javascript和xml实现方式: 1.原生的JS实现方式 2.JQuery实现方式 1.$.ajax()} $.ajax({键值对}); 2.$.get() 3.$.post() JOSN概念：JavaScript Object Notation JavaScript对象表示法基本规则：获取数据:json对象.键名 json对象[“键名”] 数组对象[索引] 遍历JSON123for (var key in person)&#123; alert(key+&quot;:&quot;+person[key])&#125; JSON数据和Java对象的相互转换1.JSON转为Java 1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 12345678String json &#x3D; &quot;&#123;\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:20,\\&quot;gender\\&quot;:\\&quot;男\\&quot;&#125;&quot;;&#x2F;&#x2F;创建ObjectMappperObjectMapper mapper &#x3D; new ObjectMapper();mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);&#x2F;&#x2F;转换为Java的对象Person person &#x3D; mapper.readValue(json,Person.class);System.out.println(person); 2.Java转为JSON1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 123456789101112131415161718192021public void test1() throws Exception &#123; Person p &#x3D; new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGendeer(&quot;男&quot;); &#x2F;&#x2F;创建Jackson的核心对象 ObjectMapper ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;调用方法 转换 String JSON &#x3D; mapper.writeValueAsString(p); System.out.println(JSON); &#x2F;&#x2F;wirterValue 将数据写入到D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt中 &#x2F;&#x2F;mapper.writeValue(new File(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt&quot;),p); &#x2F;&#x2F;writeValue将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;b.txt&quot;),p);&#125; 注解：1.@JsonIgnore:排除属性 2.@JsonFormat:属性值格式化案例校验用户是否存在 html代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;注册&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;JS&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F;页面加载完成后 给文本框绑定离开焦点事件 $(function () &#123; $(&quot;#username&quot;).blur(function () &#123; &#x2F;&#x2F;获取username获取文本输入框的值 var username &#x3D; $(this).val(); &#x2F;&#x2F;发送ajax请求 $.get(&quot;findUserServlet&quot;,&#123;username:username&#125;,function (data) &#123; var span &#x3D; $(&quot;#s_username&quot;) if (data.userExsit)&#123; &#x2F;&#x2F;用户名存在 span.css(&quot;color&quot;,&quot;red&quot;) span.html(data.msg) &#125;else &#123; &#x2F;&#x2F;用户名不存在 span.css(&quot;color&quot;,&quot;green&quot;) span.html(data.msg) &#125; &#125;,&quot;json&quot;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form&gt; &lt;input id&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt; &lt;span id&#x3D;&quot;s_username&quot;&gt;&lt;&#x2F;span&gt;&lt;br&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;注册&quot;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Servlet代码 123456789101112131415161718192021222324252627282930313233343536373839package cn.test.web.servlet;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;&#x2F;findUserServlet&quot;)public class findUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username &#x3D; request.getParameter(&quot;username&quot;); &#x2F;&#x2F;设置响应数据为JSON response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); if (&quot;Tom&quot;.equals(username))&#123; &#x2F;&#x2F;存在 map.put(&quot;userExsit&quot;,true); map.put(&quot;msg&quot;,&quot;用户名已经存在&quot;); &#125;else &#123; &#x2F;&#x2F;不存在 map.put(&quot;userExsit&quot;,false); map.put(&quot;msg&quot;,&quot;用户名可用&quot;); &#125; &#x2F;&#x2F;将map转为json，并且传递给客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); mapper.writeValue(response.getWriter(),map); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JQuery笔记","slug":"JQuery笔记","date":"2020-04-26T08:04:39.000Z","updated":"2020-05-17T07:43:32.163Z","comments":true,"path":"2020/04/26/JQuery笔记/","link":"","permalink":"http://yoursite.com/2020/04/26/JQuery%E7%AC%94%E8%AE%B0/","excerpt":"JQuery笔记","text":"JQuery笔记 概念：一个JavaScript框架，简化JS开发 使用步骤： 1.下载JQuery 2.导入JQuery的js文件 导入min.js 3.使用 JQuery对象和JS对象的区别 方法不互通 转换： jq -&gt; js : jq对象[索引] 或者 jp对象.get(索引) js -&gt; jq : $(js对象)选择器：筛选具有相似特征的元素(标签)1.基本选择器 1.标签选择器(元素选择器) `$(&quot;html标签名&quot;)` 获得所有匹配标签名称的元素 2.id选择器 `$(&quot;#id的属性值&quot;)` 获得与指定id值匹配的元素 3.类选择器 `$(&quot;.class的属性&quot;)` 获得与指定的class属性值相匹配的元素2.层级选择器 1.后代选择器： `$(&quot;A B&quot;)` 选择A元素所有内部的B元素 2.子选择器 `$(&quot;A &gt; B&quot;)` 选择A元素内部的所有B子元素 3.属性选择器 1.属性名称选择器 $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2.属性选择器 $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3.符合属性选择器 $(&quot;A[属性名=&apos;值&apos;][ ]...&quot;) 包含多个属性条件的选择器 4.过滤选择器 1.首元素选择器 :first 获得选择的元素中第一个元素 2.尾元素选择器 :last 获得选择的元素中最后一个元素 3.非元素选择器 not(.selector) 不包括指定内容的元素 4.偶数选择器 even 偶数，从0开始计数 5.奇数选择器 odd 奇数 ，从0开始 6.等于索引选择器 eq(index) 指定索引元素 7.大于索引选择器 gt(index) 大于指定索引选择器 8.小于索引选择器 lt(index) 小于指定索引选择器 9.标题选择器 header 获得标题(h1-h6)元素，固定写法 5.表单过滤选择器 1.可用元素选择器 :enabled 获得可用元素 2.不可以用元素选择器 :disabled 获得不可用元素 3.选中选择器 :checked 获得单选，复选框中的元素 4.选中选择器 :selected 获得下拉框中选中的元素 DOM操作1.内容操作 1.html() ： 获取/设置元素的标签体内容， 内容 –&gt; 内容 2.text() ： 获取/设置元素标签体纯文本内容 内容 –&gt; 内容 3.val() : 获取/设置元素的属性值 2.属性操作 1.通用属性操作 1.attr() 获取/设置元素的属性 2.removeAttr() 删除属性 3.prop() 获取/设置元素的属性 4.removeProp() 删除属性 *attr和prop的区别 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素的自定义属性，则建议是attr 2.对class属性操作 1.addClass() 添加class属性值 2.removeClass() 删除class属性值 3.toggleClass() 切换class属性值 3.CRUD操作 1.append(): 父元素将子元素追加到末尾 - 对象1.append(对象2)：将对象2添加到对象1元素内部，并且在末尾 2.prepend():父元素将子元素追加到开头 -对象1.prepend(对象2)：将对象2添加到对象1元素内部，并且在开头 3.appendto(): 4.prependto(): 5.after():添加元素到元素后边 6.before()：将元素添加到元素前边 7.insertAfter(): 8.insertBrfore(): 9.remove()：删除元素 10.empty()：清空元素的所有后代元素JQuery高级1.动画 1.三种方式显示和隐藏元素 1.show([speed,[easing],[fn]]) 2.hide([speed,[easing],[fn]]) 3.toggle([speed],[easing],[fn]) 2.滑动显示和隐藏方式 1.slideDown([speed],[easing],[fn]) 2.slideUp([speed,[easing],[fn]]) 3.slieToggle([speed],[easing],[fn]) 3.淡入淡出的显示和隐藏方式 1.fadeIn([speed],[easing],[fn]) 2.fadeOut([speed],[easing],[fn]) 3.fadeToggle([speed,[easing],[fn]])2.遍历 1.jq对象.each(callback) 2.$.each(object,[callback]) 3.for..of: 3.事件绑定 1.jquery标准的绑定方式 jq对象.事件方法(回调函数) 2.on绑定事件/off绑定事件 jq对象.on(&quot;事件名称&quot;,回调函数) jq对象.off(&quot;事件名称&quot;) 3.事件切换 jq对象.toggle(fn1,fn2...) 案例需求：1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;*需求： 1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失 分析： 1.使用定时器来完成。setTimeout(执行一次) 2.JQuery的动画效果就是控制display属性 *&#x2F; &#x2F;&#x2F;入口函数，在页面加载完成后定义定时器，调用这两个方法 $(function () &#123; &#x2F;&#x2F;定时器 调用adShow()方法 setTimeout(adShow,3000); setTimeout(adHide,8000); &#125;) &#x2F;&#x2F;显示广告方法 function adShow() &#123; &#x2F;&#x2F;获取广告div 调用show方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; &#x2F;&#x2F;隐藏广告方法 function adHide() &#123; $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt; &lt;div id&#x3D;&quot;ad&quot; style&#x3D;&quot;display: none;&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;广告.jpg&quot;&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;content&quot;&gt; 正文部分 &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 需求：抽奖案例 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;抽奖&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;* 分析： 1.给开始按钮绑定单击事件 1.1定义循环定时器 1.2切换小相框的src属性 定义一个数组，存放图片资源的路径 生成随机数 数组索引 2.给结束按钮绑定单击事件 2.1停止定时器 2.2给大相框设置src属性 *&#x2F; var imgs &#x3D; [&quot;..&#x2F;img&#x2F;1.jpg&quot;,&quot;..&#x2F;img&#x2F;2.jpg&quot;,&quot;..&#x2F;img&#x2F;3.jpg&quot;,&quot;..&#x2F;img&#x2F;4.jpg&quot;,&quot;..&#x2F;img&#x2F;5.jpg&quot;,&quot;..&#x2F;img&#x2F;6.jpg&quot;,&quot;..&#x2F;img&#x2F;0.jpg&quot;] var startId;&#x2F;&#x2F;开始定时器的一个Id var index; $(function () &#123; &#x2F;&#x2F;开始按钮 $(&quot;#startID&quot;).click(function () &#123; startId &#x3D; setInterval(function () &#123; &#x2F;&#x2F;生成随机角标 index &#x3D; Math.floor(Math.random() * 7) &#x2F;&#x2F;设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20) &#125;) &#x2F;&#x2F;结束按钮 $(&quot;#stopID&quot;).click(function () &#123; $(&quot;#stopID&quot;).click(function () &#123; &#x2F;&#x2F;停止定时器 clearInterval(startId) $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--小相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;width: 160px;height: 100px;&quot;&gt; &lt;img id&#x3D;&quot;img1ID&quot; style&#x3D;&quot;width: 160px;height: 100px&quot; src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot;&gt;&lt;&#x2F;div&gt;&lt;!--大相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;height: 500px;position: absolute;left: 500px;top: 10px&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot; id&#x3D;&quot;img2ID&quot; width&#x3D;&quot;800px&quot;height&#x3D;&quot;600px&quot;&gt;&lt;&#x2F;div&gt;&lt;!--开始按钮--&gt;&lt;input id&#x3D;&quot;startID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击开始&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;!--停止按钮--&gt;&lt;input id&#x3D;&quot;stopID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击停止&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Filter过滤器","slug":"Filter过滤器","date":"2020-04-23T06:49:44.000Z","updated":"2020-05-17T07:42:52.842Z","comments":true,"path":"2020/04/23/Filter过滤器/","link":"","permalink":"http://yoursite.com/2020/04/23/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"Filter：过滤器","text":"Filter：过滤器 步骤： 1.定义一个类，实现Filter 2.复写方法 3.配置拦截路径 web.xml的配置12345678&lt;filter&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;cn.filter.demo1&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&#x2F;&#x2F;拦截路径&lt;&#x2F;filter-mapping&gt; 过滤器的生命周期 1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次用于加载资源 2.doFilter:每次拦截资源时被执行，执行很多次。 3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。执行一次，用于释放资源。 拦截路径的配置 1.具体的资源路径:/index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2.目录拦截: /user/* 访问/user下的所有资源时，过滤器都会被执行 3.后缀名拦截： *.jsp 访问所有后缀名为jsp的资源时，过滤器都会被执行 4.拦截所有资源： /* 访问所有资源时，过滤器都会被执行 拦截方式的配置注解配置： 1.REQUEST:默认值 浏览器直接请求资源 2.FORWARD:转发访问资源 3.INCLUDE:包含访问资源 4.ERROR:错误跳转 5.ASYNC:异步访问资源 过滤器先后顺序问题1.注解配置:按照类名的字符串比较规则比较，值小的先执行 2.web.xml配置:&lt;filter-mappping&gt;谁定义在前面，谁先执行登录案例判断是否登录分析1.判断是否是登录的相关资源 * 是 直接放行 * 不是 判断是否登录 2.判断当前用户是否登录，判断Session是否有user * 有 已经登录 放行 * 没有 没有登录 跳转到登录页面代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;&#x2F;** * 登录验证的过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class loginFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;0.强制转换 HttpServletRequest request &#x3D; (HttpServletRequest) req; &#x2F;&#x2F;1.获取请求资源的路径 String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F;2.判断是否包含登录相关的路径 if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;&#x2F;loginServlet&quot;) || uri.contains(&quot;&#x2F;checkcodeServlet&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;))&#123; &#x2F;&#x2F;放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;不包含 需要验证用户是否登录 &#x2F;&#x2F;从Session获取user Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); if (user!&#x3D;null)&#123; &#x2F;&#x2F;登录了 放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;没有登录 跳转登录页面 request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp); &#125; &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 敏感词汇过滤分析1.对request对象进行增强。增强获取参数相关方法 2.放行。爨地代理对象增强对象的功能设计模式：一些通用的解决固定问题的方式 * 1.装饰模式 * 2.代理模式 实现步骤： - 1.代理对象和真实对象实现相同的接口 - 2.代理对象 = Proxy.newProxyInstance(); - 3.使用代理对象调用方法 - 4.增强方法 增强方式： - 1.增强参数列表 - 2.增强返回值类型 - 3.增强方法体执行逻辑代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.*;&#x2F;** * 敏感词汇过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class sensitiveWordsFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;创建代理对象，增强getParameter方法 ServletRequest proxy_req &#x3D; (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; &#x2F;&#x2F;判断是否是getParameter if (method.getName().equals(&quot;getParameter&quot;))&#123; &#x2F;&#x2F;增强返回值 &#x2F;&#x2F;获取返回值 String value &#x3D; (String) method.invoke(req,args); if (value !&#x3D; null)&#123; for (String str:list)&#123; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); &#125; &#125; &#125; return value; &#125; &#x2F;&#x2F;判断是否是getParameterMap if (method.getName().equals(&quot;getParameterMap&quot;))&#123; &#x2F;&#x2F;由request得到的原数组不可改变，他是被锁住的，所以这里创建一个新数组来复制原数组，返回新的数组 &#x2F;&#x2F;其实想法很想简单，既然传递进来的映射不可改变，那么自己new一个出来不就行了 Map&lt;String,String[]&gt; map1 &#x3D; new HashMap&lt;&gt;(); Map&lt;String,String[]&gt; map &#x3D; (Map&lt;String, String[]&gt;) method.invoke(req,args); Set&lt;String&gt; keySet &#x3D; map.keySet(); if (keySet !&#x3D; null)&#123; for (String str:list)&#123; for (String key:keySet)&#123; String[] values &#x3D; map.get(key); for (int i&#x3D;0;i&lt;values.length;i++)&#123; String value &#x3D; values[i]; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); values[i] &#x3D; value; &#125; &#125;map1.put(key,values); &#125; &#125; &#125; return map1; &#125; return method.invoke(req,args); &#125; &#125;); &#x2F;&#x2F;放行 chain.doFilter(proxy_req, resp); &#125; private List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F;敏感词汇 public void init(FilterConfig config) throws ServletException &#123; try &#123; &#x2F;&#x2F;获取文件真实路径 ServletContext context &#x3D; config.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;敏感词汇.txt&quot;); &#x2F;&#x2F;读取文件 BufferedReader br &#x3D; new BufferedReader(new FileReader(realPath)); &#x2F;&#x2F;将文件的每一行数据添加到list集合中 String line &#x3D; null; while ((line&#x3D;br.readLine())!&#x3D;null)&#123; list.add(line); &#125; br.close();&#x2F;&#x2F;释放资源 System.out.println(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Jetbrains系列产品2020.1最新激活方法","slug":"Jetbrains系列产品2020-1最新激活方法","date":"2020-04-15T03:56:11.000Z","updated":"2020-05-17T07:43:23.388Z","comments":true,"path":"2020/04/15/Jetbrains系列产品2020-1最新激活方法/","link":"","permalink":"http://yoursite.com/2020/04/15/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812020-1%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/","excerpt":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。","text":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。 大家熟知Jetbrains的话应该知道：他们家的所有产品升级到2018.2.1及以上版本后，先前可用的注册服务器都失效了，无法激活升级到最新版本体验最新黑科技。 这次要送的这份礼就是： Jetbrains全系列产品2020.1及以下版本（理论上适用于目前所有新老版本）最新注册服务器（License Server）的破解，可使用它来激活你手头上的Jetbrains IDE，具体支持产品和版本见下文的列表。 传送门: 百度云下载 提取码：w26y 使用方法: 0.先下载压缩包解压后得到jetbrains-agent.jar。 1.启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。 2.将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。（事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题） 3.在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。 4.重启IDE，搞定。 x. 支持两种注册方式：License server 和 Activation code: 1). 选择License server方式，地址填入：https://fls.jetbrains-agent.com （HTTP也可用，网络不佳用第2种方式） 2). 选择Activation code方式离线激活，请使用：ACTIVATION_CODE.txt 内的注册码激活 License key is in legacy format == Key invalid，表示agent配置未生效。 如果你需要自定义License name，请访问：https://zhile.io/custom-license.html 3). 现在你可以使用jetbrains-agent + activation code/license server激活jetbrains平台的付费插件了！ 现有Jetbrains付费插件Activation code: https://zhile.io/jetbrains-paid-plugins-license.html 现在有这些付费插件：https://plugins.jetbrains.com/search?isPaid=true 本项目在最新2020.1上测试通过。理论上适用于目前Jetbrains全系列所有新老版本。IDE升级会从旧版本导入以上设置，导入配置后可能提示未注册（因为刚导入的vmoptions未生效），直接重启IDE即可，无需其他操作。 本项目只做学习研究之用，不得用于商业用途！","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"BeanUtils工具类的使用","slug":"BeanUtils工具类的使用","date":"2020-04-11T07:17:27.000Z","updated":"2020-07-19T07:33:52.661Z","comments":true,"path":"2020/04/11/BeanUtils工具类的使用/","link":"","permalink":"http://yoursite.com/2020/04/11/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"BeanUtils工具类，简化数据封装","text":"BeanUtils工具类，简化数据封装 用于封装JavaBean的JavaBean：标准Java类要求： 1.类必须被public修饰 2.必须提供空参的构造器 3.成员变量必须使用private修饰 4.提供公共的setter和getter方法功能：封装数据下载点解链接下载 BeanUtils工具常用工具类有两个：BeanUtils、ConvertUtils。BeanUtils用于封装数据 方法 描述 BeanUtils对象 populate(Object bean, Map&lt;String,String[]&gt;properties) 将Map数据封装到指定Javabean中，一般用于将表单的所有数据封装到javabean setProperty(Object obj,String name,Object value) 设置属性值 getProperty(Object obj,String name) 获得属性值 代码123456789101112&#x2F;&#x2F;获取所有请求参数 Map&lt;String,String[]&gt; map &#x3D; req.getParameterMap (); &#x2F;&#x2F;创建User对象 User loginuser &#x3D; new User(); &#x2F;&#x2F;使用BeanUtils try &#123; BeanUtils.populate(loginuser,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"http的request对象和response对象","slug":"http","date":"2020-04-10T04:53:03.000Z","updated":"2020-07-19T07:34:01.435Z","comments":true,"path":"2020/04/10/http/","link":"","permalink":"http://yoursite.com/2020/04/10/http/","excerpt":"http的request对象和response对象","text":"http的request对象和response对象 概念：Hyper Text Transfer Protocol 超文本传输协议特点： 1.基于TCP/IP的高级协议 2.默认端口号8080 3.基于请求/相应模型：一次请求对应一次相应 4.无状态的：每次请求直接相互独立 请求消息的数据格式 1.请求行 请求方式 请求url 请求协议/版本 请求方式： GET 1.请求参数在请求行中，在url后面 2.请求url的长度有限 3.不太安全 POST 1.请求参数在请求体中 2.请求url长度没有限制 3.相对安全 2.请求头 3.请求空行 4.请求体 请求消息数据格式Request request和response对象的原理 1.request和response对象由服务器创建，我蛮来使用他们 2.request对象是来获取请求消息，response是来设置相应消息 request获取请求消息 获取请求行的数据 GET /test/demo1?name=zhangsan HTTP/1.1 1.获取请求方式 GET String getMethod() 2.获取虚拟目录 /test String getContextPath() 3.获取Servlet路径 /demo1 String getServletPath() 4.获取get方式请求传参 name=zhangsan String getQueryString() 5.获取URI /test/demo1 String getRequestURI() 6.获取协议及版本 HTTP/1.1 String getProtocol() 7.获取客户机的ip地址 String getRemoteAddr() 获取请求头的方法 String getHeader(String name)通过获取请求头的名称，获取请求头的值 获取请求体数据 只有post请求方式，才有请求体，在请求体中封装了post请求的请求参数 步骤： 1.获取流对象 BufferedReader getReader():获取字符输入流 ServletInputStream getInputStream():获取字节输入流 2.再从流对象中拿数据 获取请求参数的通用方法 1.String getParameter(String name):根据参数名称获取参数值 2.String[] getParameterValues(String name):根据参数名称获取参数值的数组 3.Enumeration&lt;String&gt; getParameterNames():获取所有请参数的名称 4.Map&lt;String,String[]&gt; getParameterMap():获取参数的所有Map集合12&#x2F;&#x2F;设置流的编码 防止乱码 req.setCharacterEncoding(&quot;utf-8&quot;); 请求转发：一种在服务器内部资源的跳转方式 步骤： 1.通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2.使用RequestDispatcher对象进行转发，forword(ServletRequest req,ServletRespnonse resp) 特点： 1.浏览器地址栏不发生变化 2.只能转发到当前服务器内部资源中 3.转发是一次请求 数据共享域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用域请求转发的多个资源中共享数据 方法： 1.void setAttribute(String name,Object obj):存储数据 2.Object getAttribute(String name):通过键获取值 3.void removeAttribute(String name):通过键来移除键值对获取ServletContext对象ServletContext getServletContext()响应消息相应消息的数据格式 1.相应行 组成：协议/版本 相应状态码 状态码描述 状态码分类： 1.1XX:服务器接收客户端消息，但没有接收完全，等待一段时间后，发送1XX 2.2XX:成功。200 3.3XX:重定向 302(重定向) 304(访问缓存) 4.4XX:客户端错误 404(请求路径没有对应的资源) 405(请求方式没有对应的doXXX方法) 5.5XX:服务器端错误 500(服务器内部出现异常) 2.相应头 1.格式:头名称:值 2.常见的相应头: 1.Content-Type:服务器告诉客户端本次相应体数据格式以及编码格式 2.Content-disposition:服务器告诉客户端以什么格式打开相应数据 3.相应空行 4.相应体 Response对象功能:设置相应消息 设置相应行 设置状态码:setStatus(int sc) 设置相应头 setHeader(String name,string value) 设置相应体 使用步骤: 1.获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 2.使用输出流，将数据输出到客户端浏览器 完成重定向代码实现 12&#x2F;&#x2F;简单的重定向的方法 resp.sendRedirect(&quot;&#x2F;ReaponseDemo_war_exploded&#x2F;responseDemo2&quot;); 特点: 1.地址栏发生变化 2.重定向可以访问其他站点 3.重定向是两次请求，不能使用request对象来共享数据 路径的写法 相对路径:不可以确定唯一资源 规则:.开头 找到当前资源和目标资源之间的相对位置关系 据对路径:可以确定唯一资源 服务器输出字符数据到浏览器步骤: 1.获取字符输出流 2.输出数据防止乱码 1234resp.setHeader(&quot;content-type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);&#x2F;&#x2F;简单的形式设计编码 resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); ServletContext对象1.概念:代表整个web应用，可以和程序的容器(服务器)通信 2.获取: 1.通过request对象获取request.getServletContext() 2.通过HttpServlet获取this.getServletContext 3.功能: 1.获取MIME类型 MIME类型:在互联网通信过程中定义的一种文件类型 格式:大类型/小类型 text/html 获取: `String getMineType(String file)` 代码示例 12345678ServletContext context &#x3D; this.getServletContext(); &#x2F;&#x2F;定义文件名称String filename &#x3D; &quot;a.jpg&quot;; &#x2F;&#x2F;获取MIME类型String MimeType &#x3D; context.getMimeType(filename);System.out.println(MimeType); 2.域对象:共享数据 1.setAttribute(String name,String value) 2.getAttribute(String name) 3.removeAttribute(String name) ServletContext对象范围:所有用户请求的数据 3.获取文件的真实服务器路径 1.方法:String getRealPath() 案例文件下载需求: 1.页面显示超链接 2.点击链接后弹出下载提示框 3.完成图片文件下载123456789101112131415161718192021222324@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;获取请求参数 文件名称 String filename &#x3D; req.getParameter(&quot;filename&quot;); &#x2F;&#x2F;使用字节输入流，加载文件进内存 ServletContext context &#x3D; this.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;img&#x2F;&quot;+filename);&#x2F;&#x2F;获取文件真实路径 FileInputStream fis &#x3D; new FileInputStream(realPath); &#x2F;&#x2F;设置Response的相应头 String mineType &#x3D; context.getMimeType(filename);&#x2F;&#x2F;获取文件的MIME类型 resp.setHeader(&quot;content-type&quot;,mineType); resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename); &#x2F;&#x2F;将输入流的数据写出到输出流 ServletOutputStream sos &#x3D; resp.getOutputStream(); byte[] bytes &#x3D; new byte[1024]; int len &#x3D; 0; while ((len&#x3D;fis.read(bytes))!&#x3D;-1)&#123; sos.write(bytes,0,len); &#125; fis.close(); &#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"tomcat及Servlet","slug":"tomcat及Servlet","date":"2020-04-08T06:47:13.000Z","updated":"2020-07-19T07:35:33.300Z","comments":true,"path":"2020/04/08/tomcat及Servlet/","link":"","permalink":"http://yoursite.com/2020/04/08/tomcat%E5%8F%8AServlet/","excerpt":"Tomcat","text":"Tomcat 安装tomcat进入官网，个人推荐下载解压版，方便快捷 解压到工作目录后就可以使用了 进入bin目录 双击startup.bat linux打开.sh 可能遇到的两个问题 双击之后没有启动tomcat 黑窗口秒关闭—-JAVA_HOME的环境变量没有没配置好 运行日志乱码—-打开cd到tomcat/conf/目录下修改logging.properties找到 java.util.logging.ConsoleHandler.encoding = utf-8 这行将utf-8改为GBK 部署项目 1.直接将项目放到webapps目录下即可 /hello :项目访问的路径—-&gt;虚拟目录将项目打包成一个war包，再将war包放到webapps目录下 war包会自动解压 2.配置conf/server.xml 在标签体中配置 docBase：项目存放的路径 path:虚拟目录 3.在conf\\Catalina\\localhost创建任意名称的xml文件，在文件中编写 `&lt;Context docBase=&quot;D:\\hello&quot;&gt;` 虚拟目录就是文件的名称 静态项目和动态项目：目录结构： --项目的根目录 --WEB-INF目录 --web.xml:web项目的核心配置文件 --classes目录：放置字节码文件的目录 --lib目录：防止依赖的jar包Servlet 概念：server applet 运行在服务器端的小程序 servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则步骤：1.创建javaEE项目 2.定义一个类，实现Servlet接口 3.实现接口中的抽象方法 4.配置 Servlet---- 在web.xml中配置 配置代码12345678&lt;servlet&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;servlet-class&gt;cn.test.web.Servlet.ServletDemo1&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 执行原理 1.当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的Servlet的资源路径 2.查找web.xml文件，是否有对应的标签体内容 3.如果有，则再找到对应的全类名 4.tomcat会将字节码文件加载进内存，并创建其对象 5.调用方法Servlet的生命周期 1.被创建：执行init方法，只执行一次 2.提供服务：执行servlet方法，执行多次 3.被销毁：执行destroy方法，执行一次 Servlet3.0支持注解文件配置，可以不需要web.xml 步骤： 1.创建javaEE的项目，选择Servlet的版本 3.0以上，可以不勾选web.xml 2.定义一个类，实现Servlet接口 3.重写方法 4.在类上使用一个注解 @WebServlet(&quot;资源路径&quot;)Servlet的体系结构 Servlet 接口 GenericServlet 抽象类 将Servlet接口的其他方法做了默认实现，只将service()方法作为抽象 HttpServlet 抽象类 对HTPP协议的一种封装，简化操作 1.定义类继承HttpServlet 2.复写doGet/doPost方法 Servlet相关配置 1.urlpartten：Servlet访问的路径 1.一个Servlet可以定义多个访问路径:WebServlet({&quot;/d4&quot;,&quot;Demo4&quot;}) 2.路径的定义规则：/XXX，/XXX，*.do","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"XML解析器","slug":"XML解析器","date":"2020-04-07T11:24:23.000Z","updated":"2020-07-19T07:35:41.363Z","comments":true,"path":"2020/04/07/XML解析器/","link":"","permalink":"http://yoursite.com/2020/04/07/XML%E8%A7%A3%E6%9E%90%E5%99%A8/","excerpt":"解析：操作xml文档，将文档中的数据读取到内存中","text":"解析：操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式： DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树* 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 SAX：逐行读取，基于事件驱动的。* 优点：不占内存。 * 缺点：只能读取，不能增删改 xml常见的解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。快速入门：步骤： 1.导入jar包—-链接：https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw提取码：6sg6 下载完成后解压，将jsoup-1.11.2.jar 和 JsoupXpath-0.3.2.jar(后面Jsoup_Xpath查询会用到，现在一块导入) ，压缩包包括jsoup-1.11.2-javadoc、jsoup-1.11.2.jar、jsoup-1.11.2-javadoc.jar、jsoup-1.11.2-sources.jar、JsoupXpath-0.3.2.jar 2 获取Document对象 3.获取对应的标签Element对象 4.获取数据 代码 123456789101112131415161718192021222324import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;public class Demo1 &#123; public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F;获取Document对象，根据XML文档获取 &#x2F;&#x2F;获取student.xml的path String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); &#x2F;&#x2F;获取元素对象 Element Elements elements &#x3D; document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); &#x2F;&#x2F;获取第一个name的Element对象 Element element &#x3D; elements.get(0); &#x2F;&#x2F;获取数据 String name &#x3D; element.text(); System.out.println(name); &#125;&#125; studen.xml文件中的代码 version123456789101112&lt;users&gt; &lt;user id&#x3D;&#39;1&#39;&gt; &lt;name id&#x3D;&quot;0001&quot;&gt;张三&lt;&#x2F;name&gt; &lt;age&gt;23&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt; &lt;user id&#x3D;&#39;2&#39;&gt; &lt;name&gt;李四&lt;&#x2F;name&gt; &lt;age&gt;30&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt;&lt;&#x2F;users&gt; 对象的使用：1. Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。 parse​(String html)：解析xml或html字符串 parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList来使用4. Element：元素对象 1.获取子元素对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式： selector:选择器 使用的方法：Elements select​(String cssQuery)cssQuery按照以前css选择器名字来做 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 示例代码： 1234567891011121314151617181920212223242526272829package Jsoup;import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;import cn.wanghaomiao.xpath.model.JXDocument;import cn.wanghaomiao.xpath.model.JXNode;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;import java.util.List;public class Demo5 &#123; public static void main(String[] args) throws IOException, XpathSyntaxErrorException &#123; String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); JXDocument jxDocument &#x3D; new JXDocument(document);&#x2F;&#x2F; List&lt;JXNode&gt; users &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;);&#x2F;&#x2F; for (JXNode j:users)&#123;&#x2F;&#x2F; System.out.println(j);&#x2F;&#x2F; &#125; List&lt;JXNode&gt; list &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;); for (JXNode jxNode:list)&#123; System.out.println(jxNode); &#125; &#125;&#125; ```","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"python爬虫","slug":"python爬虫","date":"2020-04-06T10:21:00.000Z","updated":"2020-05-17T07:43:40.587Z","comments":true,"path":"2020/04/06/python爬虫/","link":"","permalink":"http://yoursite.com/2020/04/06/python%E7%88%AC%E8%99%AB/","excerpt":"scrapy爬虫框架的安装","text":"scrapy爬虫框架的安装 用pip install scrapy命令安装会提示失败，是因为缺少twisted程序进入官网 按住ctrl+f 查找关键字下载好与python版本配对的文件用命令安装下载好的文件 注意路径最好不要太长 否则容易报错安装好插件以后用命令pip install scrapy安装框架安装好以后用命令’scrapy’查看版本出现以上代码说明安装成功","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"搭建个人博客及其部署","slug":"安装Hexo环境","date":"2020-04-06T08:17:01.000Z","updated":"2020-05-18T12:17:57.429Z","comments":true,"path":"2020/04/06/安装Hexo环境/","link":"","permalink":"http://yoursite.com/2020/04/06/%E5%AE%89%E8%A3%85Hexo%E7%8E%AF%E5%A2%83/","excerpt":"特别鸣up主CodeSheep","text":"特别鸣up主CodeSheep 基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。安装Node.js官网建议下载第一个安装步骤非常简单，一直next，下一步就可以了，默认安装就行。 安装git官网然后我们选择windows版本的下载安装也是一直点下一步，安装官方默认的来就行，安装完了，在开始菜单可以看到 安装hexo创建一个工作目录 比如在c盘建一个blog文件夹用管理员属性打开cmd cd到工作目录使用npm 安装hexonpm install -g hexo-cli输入hexo -v判断hexo是否安装成功输入hexo init初始化一个博客这里是hexo常用的命令 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 输入hexo s之后可以进入http://localhost:4000/这个地址查看我们的博客 部署服务器这里我们选用的部署到github上面首先新建一个github的仓库这里的name一定要填自己的用户名.github.io 不然会出问题去工作目录找到_config.yml这个文件 双击打开 我这里使用vscode打开的 用notepad++ 文本打开都可以红线换成自己的github用户名就行了 其他两行按照这个填写安装 hexo-deployer-git。npm install hexo-deployer-git --save部署一下就好了 123hexo cleanhexo ghexo d 这样你就可以通过自己的git仓库的域名访问你自己的博客了同样还可以部署在码云和coding上这个可以加快访问的速度 开启github pages服务，绑定域名如果你觉域名比较难记，可以自己去申请一个域名 这里我们以腾讯云为例，前提是我已经申请好了点击解析域名最好添加一个主机记录为@记录类型为CNAME类型，记录值写自己github仓库的地址名。 接下来配置github的 pages服务 找到博客对应的仓库，点击setting 下滑找到Github Pages，填入自己的域名，点击save保存 这样就可以通过自己的域名访问呢了","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}