{"meta":{"title":"张利源","subtitle":"","description":"但愿日子平静，抬头遇见的都是柔情","author":"张利源","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-17T08:00:27.682Z","updated":"2020-05-17T08:00:27.682Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-05-21T03:07:01.804Z","updated":"2020-05-21T03:07:01.804Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"欢迎添加我的QQ！！！ java小白一枚"},{"title":"我的朋友们","date":"2020-05-17T07:58:54.752Z","updated":"2020-05-17T07:58:54.752Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2020-05-17T07:56:17.193Z","updated":"2020-05-17T07:56:17.193Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Java JavaWeb 软件"},{"title":"所有分类","date":"2020-05-17T07:54:19.336Z","updated":"2020-05-17T07:54:19.336Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringCloud学习笔记","slug":"SpringCloud学习笔记","date":"2021-04-18T11:55:45.000Z","updated":"2021-06-27T10:21:45.003Z","comments":true,"path":"2021/04/18/SpringCloud学习笔记/","link":"","permalink":"http://yoursite.com/2021/04/18/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。","text":"Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 什么是微服务 提出者与时间: Martin Fowler ,Mar 2014 微服务架构是一种架构模式,它提倡单一应用程序划分成一组小的服务,服务之间互相协调,互相配合,为用户提供最终价值.每个微服务运行在其独立的进程中,服务与服务间采用轻量级的通信机制互相协作(通常是基于http协议的restful api).每个服务都围绕着具体业务进行构建,并且能够内独立的部署到生产环境,类生产环境等。 微服务技术栈 微服务条目 微服务落地技术 服务注册中心 Eureka、Zookeeper、Consul、Nacos 服务调用 Ribbon、LoadBalance、Feign、OpenFeign 服务降级 Hystrix、Sentinel、resilience4j 服务网关 Zuul、gateway 服务配置 Config、Nacos 服务总线 Bus、Nacos SpringCloud是分布式微服务架构一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。 EurekaEureka是什么？Eureka 是 Netflix 开发的，一个基于 REST 服务的，服务注册与发现的组件，以实现中间层服务器的负载平衡和故障转移。 它主要包括两个组件：Eureka Server 和 Eureka Client Eureka Client：一个Java客户端，用于简化与 Eureka Server 的交互（通常就是微服务中的客户端和服务端） Eureka Server：提供服务注册和发现的能力（通常就是微服务中的注册中心）。 服务启动后向Eureka注册，Eureka Server会将注册的信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取提供者地址，然会会将服务提供者地址缓存到本地，下次调用时，直接在本地缓存中取，完成一次调用。 当注册中线Eureka Server检测到服务提供者因为宕机、网络原因不可用时，则会在服务中心将服务置为DOWN状态，并把当前服务提供者状态向订阅者发布，订阅过的服务消费者更新本地缓存。 服务提供者在启动后，周期性（默认30秒）向Eureka Server发送心跳，以证明当前服务是可用状态。Eureka Server在一定的时间（默认90秒）未收到客户端的心跳，则认为服务宕机，注销该实例。 Eureka心跳机制在应用启动后，节点们将会向Eureka Server发送心跳,默认周期为30秒，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。 Eureka自我保护模式自我保护机制的工作机制是：如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制，此时会出现以下几种情况： Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。 Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。 Eureka自我保护机制，通过配置 eureka.server.enable-self-preservation 来true打开false禁用自我保护机制，默认打开状态，建议生产环境打开此配置。 Eureka Server高可用集群 相互注册，相互守望 修改host文件 windows目录：C:\\Windows\\System32\\drivers\\etc\\hostslinux目录：/etc/hosts 123# Eureka127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com 建立两个子模块 修改pom文件 启动类添加注解@EnableEurekaServer 修改yml文件 1234567891011server: port: 7002eureka: instance: hostname: eureka7002.com client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/ 在配置文件中相互注册即可。 注：如果要在服务消费者使用RestTemplate调用服务提供者，需要使用@LoadBalanced注解，来为RestTemplate赋予负载均衡的能力。 服务高可用12345678910111213eureka: client: # 注册自己，默认true fetch-registry: true # 是否在eureka抓取已有的注册信息，默认为true register-with-eureka: true service-url:# defaultZone: http://localhost:7001/eureka # 集群模式 defaultZone: http://eureka7001.com:7001/eureka/, http://eureka7002.com:7002/eureka/# instance:# instance-id: payment8002# prefer-ip-address: true # 访问路径显示ip地址 将服务注册到多个Eureka上，多个地址用，隔开就可。 消费者使用RestTemplate进行调用 1234@GetMapping(\"/payment/&#123;id&#125;\")public CommonResult&lt;Payment&gt; getPayment(@PathVariable Long id) &#123; return restTemplate.getForObject(PAYMENT_URL + \"/payment/\" + id, CommonResult.class);&#125; ZookeeperZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。 Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在 某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。基于java开发。 centos上安装zookeeper 官网复制下载地址https://downloads.apache.org/zookeeper/ 下载wget https://downloads.apache.org/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz 解压tar -zxvf apache-zookeeper-3.6.3-bin 进入目录cd apache-zookeeper-3.6.3-bin 创建data目录mkdir data 进入conf目录cd conf 重命名/拷贝zoo_sample.cfg,修改为zoo.cfgmv zoo_sample.cfg zoo.cfg vim进入zookeepervim zoo.cfg 修改zoo.cfg文件,修改datadir为刚才创建的目录 进入bin目录，启动zookeeper./zkServer.sh start 查看状态./zkServer.sh status 启动客户端./zkCli.sh 应用接入引入依赖 12345678910111213141516 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!-- 先排除自带的zookeeper --&gt;&lt;!-- &lt;exclusions&gt;--&gt;&lt;!-- &lt;exclusion&gt;--&gt;&lt;!-- &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;--&gt;&lt;!-- &lt;/exclusion&gt;--&gt;&lt;!-- &lt;/exclusions&gt;--&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;3.5.9&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; 这里要注意版本冲突的问题，如果不能正常启动，需要剔除zookeeper的依赖，添加对应版本的依赖 配置 123456spring: application: name: cloud-provider-payment cloud: zookeeper: connect-string: 192.168.2.104:2181 zookeeper客户端启动./zkCli.sh 查看节点信息 12345678[zk: localhost:2181(CONNECTED) 0] ls /[services, zookeeper][zk: localhost:2181(CONNECTED) 1] ls /services [cloud-provider-payment][zk: localhost:2181(CONNECTED) 2] ls /services/cloud-provider-payment [0b224d33-d04f-4648-8610-6cda0ba11993][zk: localhost:2181(CONNECTED) 3] get /services/cloud-provider-payment/0b224d33-d04f-4648-8610-6cda0ba11993 &#123;\"name\":\"cloud-provider-payment\",\"id\":\"0b224d33-d04f-4648-8610-6cda0ba11993\",\"address\":\"DESKTOP-L79DIJ1\",\"port\":8004,\"sslPort\":null,\"payload\":&#123;\"@class\":\"org.springframework.cloud.zookeeper.discovery.ZookeeperInstance\",\"id\":\"application-1\",\"name\":\"cloud-provider-payment\",\"metadata\":&#123;&#125;&#125;,\"registrationTimeUTC\":1618826887383,\"serviceType\":\"DYNAMIC\",\"uriSpec\":&#123;\"parts\":[&#123;\"value\":\"scheme\",\"variable\":true&#125;,&#123;\"value\":\"://\",\"variable\":false&#125;,&#123;\"value\":\"address\",\"variable\":true&#125;,&#123;\"value\":\":\",\"variable\":false&#125;,&#123;\"value\":\"port\",\"variable\":true&#125;]&#125;&#125; 注意：Zookeeper中的节点是临时的，如果下次没有收到心跳的话就会被移除掉，再次上线的节点的id也会不一样。 CAP理论 C:Consistency，数据一致性A:Availability，可用性，系统响应速度P：Partition tolerance，分区容错性 著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。 Zookeeper保证CP。当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。 Eureka保证AP。Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其它节点中 因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。 ConsulConsul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发。 提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能的每一个都可以根据需要单独使用，也可以一起使用构建全方位的服务网格，总之Consul提供了一套完整的服务网格解决方案。 consul安装与启动直接官网下载即可，解压完是一个exe可执行文件 在解压的文件夹下打开cmd，输入consul即可完成安装 输入consul -v查看consul版本信息。 输入consul agent -dev启动consul，访问localhost:8500。 应用接入引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011server: port: 8006spring: application: name: consul-provider-payment cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; 三个注册中心的异同 组件名 语言 CAP 服务检查检查 对外暴露接口 SpringCloud集成 Eureka Java AP 可配支持 HTTP 已集成 Consul Go CP 支持 HTTP/DNS 已集成 Zookeeper Java CP 支持 客户端 已集成 RibbonSpringCloud Ribbon是基于Netflix Ribbon实现的一套客户端。（负载均衡工具） 简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端主键提供一系列完善的配置项：如连接超时，重试等。简单的说，就是在配置文件中列出Load Blance后面的所有机器，Ribbon会自动帮助你基于某种规则去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。 虽然现在Ribbon已经停止维护，但是还是有不少人使用。 主要的模块有Ribbon-HTTPClient，Ribbon-eureka，Ribbon-Loadbalance Ribbon本地负载均衡 VS Nginx服务端负载均衡 Nginx是服务器负载均衡，客户端所以请求都会交给Nginx，然后由Nginx实现转发请求。即负载均衡是服务端实现的。 Ribbon负载均衡是客户端本地的负载均衡，分为集中式和进程式。 集中式： 在服务的消费方和提供方之间使用独立的负载均衡设施(可以是硬件也可以是软件)，由该设施负责请求访问，通过某种策略转发到服务的提供方。 进程式： 将负载均衡的逻辑集成到消费方，消费方从服务注册中心获取哪些服务可用，然后自己再从这些服务中选择出一个合适的服务器。Ribbon属于进程内负载均衡。他是一个类库，继承消费方进程，消费方通过获取到服务提供方的地址。 Ribbon工作原理： 先选择Eureka Server，他会选择在同一个区域内负载均衡较少的Server。 根据用户指定的策略，从Server取到的服务注册列表中选择一个地址 其中Ribbon提供了多种策略：如果轮询、随机，根据响应时间加权等。 基本使用123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 默认情况下，Eureka-Client依赖中含有Ribbon的依赖，不需要再次引入。 Ribbon的核心组件IRuleIRule是以下七种负载均衡算法的父接口 RoundRobinRule： 默认轮询的方式 RandomRule： 随机方式 WeightedResponseTimeRule： 根据响应时间来分配权重的方式，响应的越快，分配的值越大。 BestAvailableRule： 选择并发量最小的方式 RetryRule： 在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server ZoneAvoidanceRule： 根据性能和可用性来选择。 AvailabilityFilteringRule： 过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值） 修改负载均衡算法 首先增加配置类，需要注意的是，自定义的配置类不能被@ComponentScan注解扫描到，所以自定义的IRule不要放在启动类的子目录，要与启动类隔离开。 目录结构 MySelfRule类 12345678@Configurationpublic class MySelfRule &#123; @Bean public IRule myRule() &#123; return new RandomRule(); &#125;&#125; 在启动类上添加注解@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class) Ribbon负载均衡算法原理轮询方法：rest接口第几次请求数对服务集群总数量取余操作，得到结果就是实际调用服务器的下标，每次服务器重启后rest接口计数从1开始。 例如有两台服务提供者，instances[0] = 127.0.0.1:8001,instances[1] = 127.0.0.1:8002，两台实例作为两台机器，集群总数是2，按照轮询算法原理。 当第1请求时， 1%2 = 1，所以获取服务地址是127.0.0.1:8001； 当第2请求时， 2%2 = 0，所以获取服务地址是127.0.0.1:8002； 当第3请求时， 3%2 = 1，所以获取服务地址是127.0.0.1:8001； 当第4请求时， 4%2 = 0，所以获取服务地址是127.0.0.1:8002； 以此类推… 手写负载轮询算法首先写一个接口 12345678/** * @author liyuan.zhang * @date 2021/4/20 20:41 */public interface LoadBalance &#123; ServiceInstance instance(List&lt;ServiceInstance&gt; serviceInstances);&#125; 接口的实现 123456789101112131415161718192021222324@Componentpublic class MyLB implements LoadBalance &#123; private AtomicInteger atomicInteger = new AtomicInteger(0); public final int getAndIncrement() &#123; int current; int next; do &#123; current = this.atomicInteger.get(); next = current &gt;= Integer.MAX_VALUE ? 0 : current + 1; // 自旋操作 &#125; while (!this.atomicInteger.compareAndSet(current, next)); System.out.println(\"************next:\" + next); return next; &#125; @Override public ServiceInstance instance(List&lt;ServiceInstance&gt; serviceInstances) &#123; int index = getAndIncrement() % serviceInstances.size(); return serviceInstances.get(index); &#125;&#125; 这里使用CAS自旋的操作。 消费者对应的方法 12345678910@GetMapping(\"/lb\")public String getLb() &#123; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\"); if (instances == null || instances.size() &lt;- 0) &#123; return null; &#125; ServiceInstance instance = loadBalance.instance(instances); URI uri = instance.getUri(); return restTemplate.getForObject(uri + \"/payment/lb\", String.class);&#125; OpenFeign简介OpenFeign为微服务架构下服务之间的调用提供了解决方案，OpenFeign是一种声明式、模板化的HTTP客户端。在SpringCloud中使用OpenFeign，可以做到使用HTTP请求访问远程服务，就像调用本地方法一样，开发者完全感知不到这是在调用远程方法，更感知不到在访问HTTP请求。 Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign本身不支持Spring MVC的注解，它有一套自己的注解。OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。 使用OpenFeign实现服务调用引入依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 编写配置文件，正常注册到eureka上就行。 12345678910111213141516server: port: 80spring: application: name: consumer-feign-ordereureka: client: # 注册自己，默认true fetch-registry: true # 是否在eureka抓取已有的注册信息，默认为true register-with-eureka: true service-url: # defaultZone: http://localhost:7001/eureka # 集群模式 defaultZone: http://eureka7001.com:7001/eureka/, http://eureka7002.com:7002/eureka/ 编写启动类，并在启动类上开启OpenFeign的注解EnableFeignClients 编写业务类PaymentFeignService，使用FeignClient注解，value为要调用的微服务名称。 1234567891011/** * @author liyuan.zhang * @date 2021/4/22 9:44 */@Service@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")public interface PaymentFeignService &#123; @GetMapping(\"/payment/&#123;id&#125;\") CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(value = \"id\") Long id);&#125; 这里碰到一个坑，写路径和参事时一定要写全，不然创建bean的时候会失败。 controller正调用即可。 配置服务超时 OpenFeign的默认超时时间为1s 服务提供者的测试方法 12345@GetMapping(value = \"/timeout/&#123;timeout&#125;\")public String testFeignTimeOut(@PathVariable(\"timeout\") Integer timeout) throws InterruptedException &#123; Thread.sleep(timeout * 1000); return \"success\";&#125; 修改默认超时时间 123ribbon: ReadTimeout: 5000 ConnectTimeout: 5000 日志打印功能Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中HTTP请求的细节。 说白了就是对Feign接口的调用情况监控和输出。 支持四个级别 NONE： 默认的，不显示任何日志 BASIC： 仅记录请求方法、URL、响应状态码以及执行时间 HEADERS：除了BASIC 中自定义的信息外，还有请求和响应的信息头 FULL： 除了HEADERS中定义的信息外， 还有请求和响应的正文以及元数据。 创建日志配置类 123456789101112/** * @author liyuan.zhang * @date 2021/4/22 16:55 */@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel() &#123; return Logger.Level.FULL; &#125;&#125; 配置文件修改对应的文件日志打印级别为debug 123logging: level: club.zhangliyuanblog.service.PaymentFeignService: debug 修改成功 Hystrix服务雪崩分布式系统环境下，服务间类似依赖非常常见，一个业务调用通常依赖多个基础服务。如下图，对于同步调用，当库存服务不可用时，商品服务请求线程被阻塞，当有大批量请求调用库存服务时，最终可能导致整个商品服务资源耗尽，无法继续对外提供服务。并且这种不可用可能沿请求调用链向上传递，这种现象被称为雪崩效应。 雪崩效应常见场景 硬件故障：如服务器宕机，机房断电，光纤被挖断等。 流量激增：如异常流量，重试加大流量等。 缓存穿透：一般发生在应用重启，所有缓存失效时，以及短时间内大量缓存失效时。大量的缓存不命中，使请求直击后端服务，造成服务提供者超负荷运行，引起服务不可用。 程序BUG：如程序逻辑导致内存泄漏，JVM长时间FullGC等。 同步等待：服务间采用同步调用模式，同步等待造成的资源耗尽。 雪崩效应应对策略 硬件故障：多机房容灾、异地多活等。 流量激增：服务自动扩容，流量控制等。 缓存穿透：缓存预加载、缓存异步加载等。 程序BUG：修改程序BUG、及时释放资源等。 同步等待：资源隔离、MQ解耦、不可用服务调用快速失败等。资源隔离通常指不同服务调用采用不同的线程池；不可用服务调用快速失败一般通过熔断器模式结合超时机制实现。 综上所述，如果一个应用不能对来自依赖的故障进行隔离，那该应用本身就处在被拖垮的风险中。 因此，为了构建稳定、可靠的分布式系统，我们的服务应当具有自我保护能力，当依赖服务不可用时，当前服务启动自我保护功能，从而避免发生雪崩效应。 Hystrix概念Hystrix [hɪst’rɪks]，中文含义是豪猪，因其背上长满棘刺，从而拥有了自我保护的能力。本文所说的Hystrix是Netflix开源的一款容错框架，同样具有自我保护能力。为了实现容错和自我保护，下面我们看看Hystrix如何设计和实现的。 Hystrix设计目标： 对来自依赖的延迟和故障进行控制和防护–这些依赖通常都是通过网络访问的。 阻止故障的连锁反应 快速失败并迅速恢复 回退并优雅降级 提供近实时的监控与告警 Hystrxi遵循的设计原则 防止任何单独的依赖耗尽资源(线程) 过载立即切断并快速失败，防止排队 尽可能提供回退以保证用户免受故障 使用隔离技术(例如隔板，泳道和断路器模式)来限制任何一个依赖的影响 通过近实时的指标，监控和警告，确保故障被及时发现 通过动态修改配置属性，确保故障及时恢复 防止整个依赖客户端执行失败，而不仅仅是网络通信 Hystrix如何实现这些目标 使用命令模式将所有对外服务的调用包装在HystrixCommand后者HystrixObservableCommand对象中，并将该对象单独放在线程中执行。 每个依赖都维护着一个线程池(或者信号量)，线程池被耗尽则拒绝请求，而不是让请求排队。 记录请求成功，失败和超时和线程拒绝。 服务错误百分比超过阈值，熔断器自动打开，一段时间内停止对该服务的所有请求。 请求失败，被拒绝，超时或者熔断时执行降级逻辑。 服务提供者配置服务降级引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 启动类开启熔断@EnableCircuitBreaker 业务类 123456789101112131415@HystrixCommand(fallbackMethod = \"paymentTimeoutHandle\", commandProperties = &#123; @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"3000\")&#125;)public String timeout(Integer time) &#123; try &#123; Thread.sleep(time * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return \"线程池：\" + Thread.currentThread().getName() + \"timeout_\" + \"耗时\" + time + \"秒钟\";&#125;public String paymentTimeoutHandle(Integer id) &#123; return \"线程池:\" + Thread.currentThread().getName() + \"paymentTimeoutHandler,id:\" + id;&#125; fallbackMethod为发生错误时，调用的方法，这里要注意一下，备用方法的参数要和正常方法的参数对应，不然会报错。 服务消费者配置服务降级在配置文件中开启Feign对Hystrix的支持 123feign: hystrix: enabled: true 启动类开启Hystrix@EnableHystrix 同样在业务类进行配置 1234567891011@GetMapping(value = \"/timeout/&#123;time&#125;\")@HystrixCommand(fallbackMethod = \"OrderTimeoutHandle\", commandProperties = &#123; @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"3000\")&#125;)public String timeout(@PathVariable Integer time)&#123; return paymentHystrixService.timeout(time);&#125;public String OrderTimeoutHandle(Integer time) &#123; return \"我是消费者80，对方支付系统繁忙，请10秒钟之后再试，┭┮﹏┭┮\";&#125; 这里遇到了一个坑，开始只要后端超过1s就会超时，后来配置了ribbon的超时时间也没有生效。 这里关键在于我们开启了feign.hystrix.enable=true,官网解释说这个配置Feign将适应断路器包装所有的方法(类似于在这些方法上加了一个@HystrixCommand)，这些方法会应用一个默认的超时时间1s，所有service超过1s就会报异常，进入备用方法 我们需要修改Hystrix和Ribbon的超时时间 12345678910111213# 配置Ribbon超时ribbon: ReadTimeout: 5000 ConnectTimeout: 5000# 配置Hystrix超时hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 3000 配置了这么多超时时间，我具体也不清楚默认采用哪个，看网上大神说应该是timeoutInMilliseconds 和ribbon的ReadTimeout 以及注解中配置的时间取最低值。 目前问题 每个方法都要配置一个 代码膨胀 和业务逻辑混在一起 混乱 通配服务降级DefaultProperties 在对应类使用@DefaultProperties(defaultFallback = &quot;orderTimeoutHandleGlobal&quot;)注解，defaultFallback指定方法，这里的方法参数不用和正常方法一致。 如果某个方法需要特殊的 备用方法，也可以使用@HystrixCommand进行指定。 同样服务降级FeignFallBack 我们发现备用的方法和正常的方法写在一起，导致代码很混乱，所以我们可以单独的定义一个类负责一个微服务的备用方法。 首先写一个PaymentFallBackService类继承PaymentHystrixService接口，首先对应微服务的所有方法。 然后我们在PaymentHystrixService的@FeignClient注解的fallback属性指定对应的类即可。 模拟服务的提供者宕机。 服务熔断123456789101112131415161718// =============服务熔断@HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\", commandProperties = &#123; @HystrixProperty(name = \"circuitBreaker.enabled\", value = \"true\"),// 是否开启断路器 @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),// 请求次数 @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"10000\"),// 请求时间 @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"60\")// 失败率达到多少后跳闸&#125;)public String paymentCircuitBreaker(Integer id) &#123; if (id &lt; 0) &#123; throw new RuntimeException(\"*******id不能为负数\"); &#125; String serialNum = IdUtil.simpleUUID(); return Thread.currentThread().getName()+\"\\t调用成功，流水号：\"+ serialNum;&#125;public String paymentCircuitBreaker_fallback(Integer id) &#123; return \"id不能为负数，请稍后再试。┭┮﹏┭┮\" + id;&#125; Hystrix断路器使用时最常用的三个重要指标参数 在微服务中使用Hystrix 作为断路器时，通常涉及到以下三个重要的指标参数（这里是写在@HystrixProperties注解中，当然实际项目中可以全局配置在yml或properties中） 1、circuitBreaker.sleepWindowInMilliseconds 断路器的快照时间窗，也叫做窗口期。可以理解为一个触发断路器的周期时间值，默认为10秒（10000）。 2、circuitBreaker.requestVolumeThreshold 断路器的窗口期内触发断路的请求阈值，默认为20。换句话说，假如某个窗口期内的请求总数都不到该配置值，那么断路器连发生的资格都没有。断路器在该窗口期内将不会被打开。 3、circuitBreaker.errorThresholdPercentage 断路器的窗口期内能够容忍的错误百分比阈值，默认为50（也就是说默认容忍50%的错误率）。打个比方，假如一个窗口期内，发生了100次服务请求，其中50次出现了错误。在这样的情况下，断路器将会被打开。在该窗口期结束之前，即使第51次请求没有发生异常，也将被执行fallback逻辑。 综上所述，在以上三个参数缺省的情况下，Hystrix断路器触发的默认策略为： 在10秒内，发生20次以上的请求时，假如错误率达到50%以上，则断路器将被打开。（当一个窗口期过去的时候，断路器将变成半开（HALF-OPEN）状态，如果这时候发生的请求正常，则关闭，否则又打开） Hystrix工作流程 构造一个HystrixCommand或者HystrixObservableCommand对象，用于封装请求，并在构造方法配置请求被执行需要的参数。 执行命令，Hystrix提供了四种执行命令的方法。 判断是否使用缓存响应请求，若启用了缓存，且缓存可用，直接使用缓存响应请求。Hystrix支持请求缓存，但需要用户开启。 判断熔断器是否打开，如果打开，跳到第8步。 判断线程池/队列/信号量是否已满，已满跳到第8步。 执行HystrixObservableCommand.construct()或者HystrixCommand.run()，如果执行失败或者超时跳到第8步，否则跳到第9步。 统计熔断器监控指标 走Fallback备用逻辑。 返回请求响应。 Hystrix图形化监控新建模块，引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 启动类开启监控@EnableHystrixDashboard 需要监控的项目在启动类添加如下代码： 123456789@Beanpublic ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\"/hystrix.stream\"); registrationBean.setName(\"HystrixMetricsStreamServlet\"); return registrationBean;&#125; 访问localhost:9001/hystrix GateWay Spring Cloud Gateway 是Spring官方基于Spring5.0，Spring Boot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。 为什么使用GateWay？ Spring Cloud Gateway 可以看做是一个 Zuul 1.x 的升级版和代替品，比 Zuul 2 更早的使用 Netty 实现异步 IO，从而实现了一个简单、比 Zuul 1.x 更高效的、与 Spring Cloud 紧密配合的 API 网关。Spring Cloud Gateway 里明确的区分了 Router 和 Filter，并且一个很大的特点是内置了非常多的开箱即用功能，并且都可以通过 SpringBoot 配置或者手工编码链式调用来使用。比如内置了 10 种 Router，使得我们可以直接配置一下就可以随心所欲的根据 Header、或者 Path、或者 Host、或者 Query 来做路由。比如区分了一般的 Filter 和全局 Filter，内置了 20 种 Filter 和 9 种全局 Filter，也都可以直接用。当然自定义 Filter 也非常方便。 重要的几个概念 入门配置引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 注意这里不要添加Spring的web依赖和图形化界面依赖 yml文件 12345678910111213141516171819202122232425262728eureka: instance: hostname: cloud-gateway-service client: service-url: defaultZone: http://eureka7001.com:7001/eureka register-with-eureka: true fetch-registry: truespring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_route # 路由的id，没有固定的规则，但要求唯一，建议配合服务名 uri: http://localhost:8001 # 匹配后提供服务的路由地址 predicates: - Path=/payment/** # 断言，路径相匹配进行路由# - id: payment_route2# uri: http://localhost:8001# predicates:# - Path=/payment/lbserver: port: 9527 这里需要注意在配置多个路由的同时格式要对应。 测试访问http://localhost:9527/payment/1 硬编码配置12345678@Beanpublic RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) &#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(\"path_route_liyuan\", r -&gt; r.path(\"/guonei\") .uri(\"http://news.baidu.com/guonei\")).build(); return routes.build();&#125; 配置动态路由默认情况下GateWay会根据注册中心的服务列表，以注册中心上的微服务名为路径创建动态路由进行转发，从而实现动态路由功能。 123456spring: cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 开启从注册中心动态的创建路由 下面的uri要写成lb://服务名的形式,uri: lb://cloud-payment-service # 匹配后提供服务者的路由 这里的lb表示协议的意思，意为启用GateWay的负载均衡功能 Predicate的使用通过请求路径进行匹配123456789101112spring: cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_route # 路由的id，没有固定的规则，但要求唯一，建议配合服务名# uri: http://localhost:8001 # 匹配后提供服务的路由地址 uri: lb://cloud-payment-service # 匹配后提供服务者的路由 predicates: - Path=/payment/** # 断言，路径相匹配进行路由 如果单个参数支持{参数名}的形式。 通过时间匹配Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发。 123456789spring: cloud: gateway: routes: - id: payment_route2 uri: lb://cloud-payment-service # 匹配后提供服务者的路由 predicates: - Path=/payment/lb - After=2021-05-26T17:45:36.022+08:00[Asia/Shanghai] # 什么时间之后生效 Spring 是通过 ZonedDateTime 来对时间进行的对比，ZonedDateTime 是 Java 8 中日期时间功能里，用于表示带时区的日期与时间信息的类，ZonedDateTime 支持通过时区来设置时间，中国的时区是：Asia/Shanghai。 同时GateWay支持使用Before和Between 通过Cookie匹配Cookie Route Predicate 可以接收两个参数，一个是 Cookie name , 一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。 1234567891011121314spring: cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_route # 路由的id，没有固定的规则，但要求唯一，建议配合服务名# uri: http://localhost:8001 # 匹配后提供服务的路由地址 uri: lb://cloud-payment-service # 匹配后提供服务者的路由 predicates: - Path=/payment/** # 断言，路径相匹配进行路由 - After=2021-05-26T17:45:36.022+08:00[Asia/Shanghai] # 什么时间之后生效 - Cookie=username, zzyy # 使用Cookie匹配 使用curl测试 1curl http://localhost:9527/payment/lb --cookie \"username=zzyy\" 通过请求方法匹配可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由。 12345678910111213141516spring: cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_route2 uri: lb://cloud-payment-service # 匹配后提供服务者的路由 # uri: http://localhost:8001 predicates: - Path=/payment/lb - After=2021-05-26T17:45:36.022+08:00[Asia/Shanghai] # 什么时间之后生效# - Cookie=username, [a-zA-Z]+ # cookie# - Header=X-Request-Id, \\d+ #请求头要有X-Request—Id属性并且值为整数的正则表达式 - Method=Get 测试 12curl http://localhost:9527/payment/lbcurl -X post http://localhost:9527/payment/lb 通过请求参数匹配1234567891011121314151617spring: cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_route2 uri: lb://cloud-payment-service # 匹配后提供服务者的路由 # uri: http://localhost:8001 predicates: - Path=/payment/lb - After=2021-05-26T17:45:36.022+08:00[Asia/Shanghai] # 什么时间之后生效# - Cookie=username, [a-zA-Z]+ # cookie# - Header=X-Request-Id, \\d+ #请求头要有X-Request—Id属性并且值为整数的正则表达式 - Method=Get - Query=testParameter # 参数 测试 1curl http://localhost:9527/payment/lb?testParameter=11 通过请求 ip 地址进行匹配Predicate 也支持通过设置某个 ip 区间号段的请求才会路由，RemoteAddr Route Predicate 接受 cidr 符号 (IPv4 或 IPv6) 字符串的列表(最小大小为 1)，例如 192.168.0.1/16 (其中 192.168.0.1 是 IP 地址，16 是子网掩码)。 123456789101112131415161718spring: cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_route2 uri: lb://cloud-payment-service # 匹配后提供服务者的路由 # uri: http://localhost:8001 predicates: - Path=/payment/lb - After=2021-05-26T17:45:36.022+08:00[Asia/Shanghai] # 什么时间之后生效# - Cookie=username, [a-zA-Z]+ # cookie# - Header=X-Request-Id, \\d+ #请求头要有X-Request—Id属性并且值为整数的正则表达式 - Method=Get# - Query=testParameter - RemoteAddr=192.168.1.5 各种 Predicates 同时存在于同一个路由时，请求必须同时满足所有的条件才被这个路由匹配。 一个请求满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发 Filter 自定义Filter我们需要实现GlobalFilter, Ordered两个接口。 需要携带uname参数的情况。 12345678910111213141516171819202122@Slf4j@Componentpublic class MyLogGateWayFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(\"******************Come in MyLogGateWayFilter\" + System.currentTimeMillis()); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname == null) &#123; log.info(\"*********用户名为空！！！\"); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; // 表示加载过滤器的顺序，数字越小优先级越高。 return 0; &#125;&#125; Config 在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。Spring Cloud Config项目是就是这样一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。 入门示例： 在GitHub上新建一个仓库，放三个配置文件，config-dev.yml，config-test.yml，config-prod.yml。 新建server模块引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; yml配置文件 123456789101112131415161718server: port: 3344spring: application: name: cloud-config-center cloud: config: server: git: uri: git@github.com:zhangliyuangit/springcloud-config.git search-paths: - springcloud-config skip-ssl-validation: true # 跳过ssl认证 label: main # 读取分支eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/ 在主启动类上添加@EnableConfigServer注解。 Spring Cloud Config 有它的一套访问规则，我们通过这套规则在浏览器上直接访问就可以。 12345/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties {application} 就是应用名称，对应到配置文件上来，就是配置文件的名称部分，例如我上面创建的配置文件。 {profile} 就是配置文件的版本，我们的项目有开发版本、测试环境版本、生产环境版本，对应到配置文件上来就是以 application-{profile}.yml 加以区分，例如application-dev.yml、application-sit.yml、application-prod.yml。 {label} 表示 git 分支，默认是 master 分支，如果项目是以分支做区分也是可以的，那就可以通过不同的 label 来控制访问不同的配置文件了。 测试curl http://localhost:3344/main/config-test.yml 新建client模块添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 创建一个bootstrap.yml 注意这里的bootstrap.yml代表系统级的配置文件，加载优先于application.yml 1234567891011121314151617server: port: 3355spring: application: name: config-client cloud: # config客户端配置 config: label: main # 分支名 name: config # 配置文件名称 profile: test # 读取后缀名 uri: http://localhost:3344 # 配置中心地址eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/ 测试业务类 1234567891011@RestControllerpublic class ConfigClientController &#123; @Value(\"$&#123;config.info&#125;\") private String configInfo; @GetMapping(value = \"/configInfo\") public String getConfigInfo() &#123; return configInfo; &#125;&#125; 测试curl http://localhost:3355/configInfo 动态更新配置我们修改在GitHub仓库配置文件中的版本信息，server端生效但是client端并没有生效。 在pom中添加actuator依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 修改yml,暴露监控端口 123456# 暴露监控端点management: endpoints: web: exposure: include: \"*\" @RefreshScope修饰控制类 执行curl -X POST &quot;http://localhost:3355/actuator/refresh&quot; Bus Spring cloud bus通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其他的消息指令。Spring bus的一个核心思想是通过分布式的启动器对spring boot应用进行扩展，也可以用来建立一个多个应用之间的通信频道。目前唯一实现的方式是用AMQP消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。 大家可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ。利用bus的机制可以做很多的事情，其中配置中心客户端刷新就是典型的应用场景之一，我们用一张图来描述bus在配置中心使用的机制。 两种方案 提交代码触发post给客户端A发送bus/refresh 提交代码触发post给Server端发送bus/refresh 第一种方案并不合适，原因如下： 打破了微服务的职责单一性。微服务本身是业务模块，它本不应该承担配置刷新的职责。 破坏了微服务各节点的对等性。 如果客户端ip有变化，这时我们就需要修改WebHook的配置。 流程： 这时Spring Cloud Bus做配置更新步骤如下: 提交代码触发post给Server端发送bus/refresh Server端接收到请求并发送给Spring Cloud Bus Spring Cloud bus接到消息并通知给其它客户端 其它客户端接收到通知，请求Server端获取最新配置 全部客户端均获取到最新的配置 配置Bus 使用Docker安装RabbitMQ 1docker run -d --hostname rabbit-host --name rabbitmq -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=root -p 15672:15672 -p 5672:5672 rabbitmq:3-management 服务端模块添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 服务端新增yml配置 123456789101112# mq配置rabbitmq: host: 121.196.147.102 port: 5672 username: root password: root management: endpoints: web: exposure: include: \"bus-refresh\" 注意格式缩进 两个服务端同样添加bus的依赖 服务端yml新增 12345678910111213# mq配置rabbitmq: host: 121.196.147.102 port: 5672 username: root password: root # 暴露断点management: endpoints: web: exposure: include: \"*\" 修改GitHub中对应的版本号。 刷新3344curl -X POST http://localhost:3344/actuator/bus-refresh 实现定点通知curl -X POST http://localhost:3344/actuator/bus-refresh/config-client-3355:3355,这里的config-client-3355为对应的服务名。 Stream基本概念 Spring Cloud Stream官方的说法是一个构建消息驱动微服务的框架。我们可以这么理解，这个Spring Cloud Stream封装了mq的玩法，统一了模型，然后屏蔽各个mq产品中间件不同，降低了我们的学习成本，不过目前只支持kafka与rabbitmq。 我们从上往下看，我们的应用程序，也就是spring core ，通过这个input 与output 这两种channel 与binder 进行交互，binder（绑定器对象）屏蔽了咱们的消息中间件产品的差异。这个input 与output相对于应用程序来说的，这个input对于应用程序就是读，从外面到程序，output就是写，由应用程序写到外面。 组成 说明 Middleware 中间件，目前只支持RabbitMQ和Kafka Binder Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic，RabbitMQ的exchange)，这些都可以通过配置文件来实现 @Input 注解标识输入通道，通过该输入通道接收到的消息进入应用程序 @Output 注解标识输出通道，发布的消息将通过该通道离开应用程序 @StreamListener 监听队列，用于消费者的队列的消息接收 @EnableBinding 指信道channel和exchange绑定在一起 Stream 的消息通信模式遵循了发布-订阅模式，也就是Topic模式。在RabbitMQ中是Exchange交换机，在Kafka是Topic。 术语 Binder绑定器，通过binder可以很方便的连接中间件，屏蔽差异。 Channel通道，是Queue的一种抽象，主要实现存储和转发的媒介。 Source和Sink，简单的理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接收消息就是输入。 快速搭建新建消息的生产者 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011121314151617181920212223242526272829303132server: port: 8801spring: application: name: cloud-stream-provider cloud: stream: binders: defaultRabbit: # 表示定义的名称，用于binding整合 type: rabbit #消息组件类型 environment: # 设置rabbitmq相关环境配置 spring: rabbitmq: host: 121.196.147.102 prot: 5672 username: root password: root bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange的名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置\"text/plain\" binder: defaultRabbit #eureka: client: service-url: defaultZone: http://localhost:7001/eureka instance: lease-expiration-duration-in-seconds: 5 lease-renewal-interval-in-seconds: 2 # 设置心跳时间的间隔，默认是30s instance-id: send-8801.com # 在消息列表时显示的主机名称 prefer-ip-address: true # 访问的路径变为ip地址 这里要注意对齐问题，有爆红可以正常启动。 创建消息通道绑定的接口 12345678910111213141516@Slf4j@EnableBinding(Source.class) // 定义消息的推送管道public class MessageProvider implements IMessageProvider &#123; @Resource private MessageChannel output; // 消息发送管道 @Override public String send() &#123; String serial = UUID.randomUUID().toString(); output.send(MessageBuilder.withPayload(serial).build()); log.info(\"************** serial is &#123;&#125;\", serial); return null; &#125;&#125; controller层直接调用就可以了。 新建消息的消费者 同样引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 1234567891011121314151617181920212223242526272829303132server: port: 8802spring: application: name: cloud-stream-consumer cloud: stream: binders: defaultRabbit: # 表示定义的名称，用于binding整合 type: rabbit #消息组件类型 environment: # 设置rabbitmq相关环境配置 spring: rabbitmq: host: 121.196.147.102 prot: 5672 username: root password: root bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange的名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置\"text/plain\" binder: defaultRabbit #eureka: client: service-url: defaultZone: http://localhost:7001/eureka instance: lease-expiration-duration-in-seconds: 5 lease-renewal-interval-in-seconds: 2 # 设置心跳时间的间隔，默认是30s instance-id: receive-8802.com # 在消息列表时显示的主机名称 prefer-ip-address: true # 访问的路径变为ip地址 消费者业务代码 12345678910111213@Slf4j@Component@EnableBinding(Sink.class)public class ReceiveMessageLinstenerController &#123; @Value(\"$&#123;server.port&#125;\") private String serverPort; @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt; message) &#123; log.info(\"消费者1号，收到的消息：&#123;&#125;, 服务的端口是&#123;&#125;\", message.getPayload(), serverPort); &#125;&#125; 分组在现实的业务场景中，每一个微服务应用为了实现高可用和负载均衡，都会集群部署，按照上面我们启动了两个应用的实例，消息被重复消费了两次。为解决这个问题，Spring Cloud Stream 中提供了消费组，通过配置 spring.cloud.stream.bindings.input.group 属性为应用指定一个组名，下面修改下配置文件，修改如下： 123456bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange的名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置\"text/plain\" binder: defaultRabbit # 设置要绑定的消息服务的具体设置 group: testA # 分组 在MQ的可视化中可以发现当前group下存在两个消费者。 测试即可。 Sleuth在微服务架构中，众多的微服务之间互相调用，如何清晰地记录服务的调用链路是一个需要解决的问题。同时，由于各种原因，跨进程的服务调用失败时，运维人员希望能够通过查看日志和查看服务之间的调用关系来定位问题，而Spring cloud sleuth组件正是为了解决微服务跟踪的组件。单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整的记录下来， Zipkin服务端部署服务端是一个单独的jar包，官网貌似已经下载不了了，去Maven仓库下载即可。 1java -jar zipkin-server-2.12.9-exec.jar 客户端部署 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 123456spring: zipkin: base-url: http://121.196.147.102:9411 sleuth: sampler: percentage: 1.0 # 收集数据百分比，默认 0.1（10%） 访问http://121.196.147.102:9411/即可","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"SpringBoot整合Redis","slug":"SpringBoot整合Redis","date":"2021-03-04T08:05:58.000Z","updated":"2021-03-04T08:08:06.000Z","comments":true,"path":"2021/03/04/SpringBoot整合Redis/","link":"","permalink":"http://yoursite.com/2021/03/04/SpringBoot%E6%95%B4%E5%90%88Redis/","excerpt":"SpringBoot整合Redis","text":"SpringBoot整合Redis 0.一些对象信息 1.JedisPoolConfig(这个是配置连接池) 2.RedisConnectionFactory（这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在SpringD Data Redis方案中提供了一下四种工厂模型） JredisConnectionFactory JedisConnectionFactory LettuceConnectionFactory SrpConnectionFactory 3.RedisTemplate 1.添加启动类1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置连接信息12345678910111213141516# redis索引，默认为0spring.redis.database=1# redis服务地址spring.redis.host=127.0.0.1# 端口spring.redis.port=6379# 连接池最大连接数spring.redis.jedis.pool.max-active=8# 连接池中最大空闲连接数spring.redis.jedis.pool.max-idle=10# 连接池最大阻塞等待时间spring.redis.jedis.pool.max-wait=-1# 连接池最小空闲连接数spring.redis.jedis.pool.min-idle=0# 连接超时时间spring.redis.lettuce.shutdown-timeout=1000 3.测试12345678@Autowiredprivate RedisTemplate&lt;String, String&gt; redisTemplate;@Testpublic void test() &#123; redisTemplate.opsForValue().set(\"mykey\",\"myvalue\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\"));&#125; 4.序列化器这里先说一下Spring提供了那些序列化器（各自作用自行百度，这里不再赘述）Jackson2JsonRedisSerializerJdkSerializationRedisSerializerOxmSerializerStringRedisSerializerGenericToStringRedisSerializerGenericJackson2JsonRedisSerializer 为什么前面的代码没有设置序列化？原因是是因为我们使用了@AutoWired，IOC容器为我们选择了StringRedisTemplate类来注入 这里是RedisTemplate的继承关系图 然后我们跟踪源码可以发现StringRedisTemplate.java 123456public StringRedisTemplate() &#123; setKeySerializer(RedisSerializer.string()); setValueSerializer(RedisSerializer.string()); setHashKeySerializer(RedisSerializer.string()); setHashValueSerializer(RedisSerializer.string());&#125; 那假如我们把Value的类型改为Object呢 12345678@Resourceprivate RedisTemplate&lt;String, Object&gt; redisTemplate;@Testpublic void test() &#123; redisTemplate.opsForValue().set(\"mykey\",\"myvalue\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\"));&#125; 这里继续使用@AutoWired会报错，需要使用@Resource，这两个注解的区别在前者是根据类型后者是根据名字，具体区别自行查资料（这里说一下为什么会报错：@AutoWired找不到该类型&lt;String,Object&gt;的Bean因为根本没有。使用@Resource直接注入的是RedisTemplate） 这是因为没有设置序列化器，RedisTemplate选择了默认的序列化器JdkSerializationRedisSerializer 5.配置序列化器5.1实体类实现序列化接口5.2然后在配置类中设置序列化器12345678910111213141516171819/** * @author liyuan.zhang * @date 2021/3/4 15:49 */@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, User&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, User&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 关联 redisTemplate.setConnectionFactory(factory); // 设置key的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); // 设置value的序列化器 redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;User&gt;(User.class)); return redisTemplate; &#125;&#125; 5.3测试类123456789@Autowiredprivate RedisTemplate&lt;String, User&gt; redisTemplate;@Testpublic void test1() &#123; redisTemplate.opsForValue().set(\"user\", User.builder().name(\"张三\").address(\"上海市\").id(\"1\").birthday(new Date()).build()); User user = redisTemplate.opsForValue().get(\"user\"); System.out.println(user);&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"JWT","slug":"JWT","date":"2021-03-02T07:20:40.000Z","updated":"2021-03-02T07:22:38.644Z","comments":true,"path":"2021/03/02/JWT/","link":"","permalink":"http://yoursite.com/2021/03/02/JWT/","excerpt":"JWT初体验","text":"JWT初体验 1.什么是JWTJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA. ​ —[摘自官网] 123456# 1.翻译- 官网地址: https://jwt.io/introduction/- 翻译: jsonwebtoken（JWT）是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名# 2.通俗解释- JWT简称JSON Web Token,也就是通过JSON形式作为Web应用中的令牌,用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。 2.JWT能做什么12345# 1.授权- 这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。# 2.信息交换- JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。 3.为什么是JWT基于传统的Session认证1234# 1.认证方式- 我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。t# 2.认证流程 123456789# 3.暴露问题- 1.每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大- 2.用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。- 3.因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。- 4.在前后端分离系统中就更加痛苦:如下图所示 也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务 器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻击）攻击，session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是 sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。 不方便集群应用。 基于JWT认证 1234567891011121314151617181920# 1.认证流程- 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。- 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同lll.zzz.xxx的字符串。 token head.payload.singurater- 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。- 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) HEADER- 后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。- 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。# 2.jwt优势- 简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快- 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库- 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。- 不需要在服务端保存会话信息，特别适用于分布式微服务。 4.JWT的结构是什么?1234567token string ====&gt; header.payload.singnature token # 1.令牌组成- 1.标头(Header)- 2.有效载荷(Payload)- 3.签名(Signature)- 因此，JWT通常如下所示:xxxxx.yyyyy.zzzzz Header.Payload.Signature 1234# 2.Header- 标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。它会使用 Base64 编码组成 JWT 结构的第一部分。- 注意:Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。 1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; 12# 3.Payload- 令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64 编码组成 JWT 结构的第二部分 12345&#123; \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true&#125; 123456789101112# 4.Signature- 前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过- 如: HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload),secret);# 签名目的- 最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。# 信息安全问题- 在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？- 是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏 感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第 三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系 统，甚至实现Web应用的单点登录。 123456# 5.放在一起- 输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递这些字符串，与基于XML的标准（例如SAML）相比，它更紧凑。- 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快- 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 5.使用JWT1# 1.引入依赖 123456&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 1# 2.生成token 123456789Calendar instance = Calendar.getInstance();instance.add(Calendar.SECOND, 90);//生成令牌String token = JWT.create() .withClaim(\"username\", \"张三\")//设置自定义用户名 .withExpiresAt(instance.getTime())//设置过期时间 .sign(Algorithm.HMAC256(\"token!Q2W#E$RW\"));//设置签名 保密 复杂//输出令牌System.out.println(token); 12- 生成结果eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsicGhvbmUiLCIxNDMyMzIzNDEzNCJdLCJleHAiOjE1OTU3Mzk0NDIsInVzZXJuYW1lIjoi5byg5LiJIn0.aHmE3RNqvAjFr_dvyn_sD2VJ46P7EGiS5OBMO_TI5jg 1# 3.根据令牌和签名解析数据 1234JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(\"token!Q2W#E$RW\")).build();DecodedJWT decodedJWT = jwtVerifier.verify(token);System.out.println(\"用户名: \" + decodedJWT.getClaim(\"username\").asString());System.out.println(\"过期时间: \"+decodedJWT.getExpiresAt()); 12345# 4.常见异常信息- SignatureVerificationException: 签名不一致异常- TokenExpiredException: 令牌过期异常- AlgorithmMismatchException: 算法不匹配异常- InvalidClaimException: 失效的payload异常 6.封装工具类12345678910111213141516171819202122232425262728293031323334public class JWTUtils &#123; private static String TOKEN = \"token!Q@W3e4r\"; /** * 生成token * @param map //传入payload * @return 返回token */ public static String getToken(Map&lt;String,String&gt; map)&#123; JWTCreator.Builder builder = JWT.create(); map.forEach((k,v)-&gt;&#123; builder.withClaim(k,v); &#125;); Calendar instance = Calendar.getInstance(); instance.add(Calendar.SECOND,7); builder.withExpiresAt(instance.getTime()); return builder.sign(Algorithm.HMAC256(TOKEN)).toString(); &#125; /** * 验证token * @param token * @return */ public static void verify(String token)&#123; JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125; /** * 获取token中payload * @param token * @return */ public static DecodedJWT getToken(String token)&#123; return JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125;&#125; 7.整合springboot123# 0.搭建springboot+mybatis+jwt环境- 引入依赖- 编写配置 12345678910111213141516171819202122232425262728293031323334&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入druid--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.19&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt; 12345678910111213server.port=8989spring.application.name=jwtspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/jwt?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootmybatis.type-aliases-package=com.baizhi.entitymybatis.mapper-locations=classpath:com/baizhi/mapper/*.xmllogging.level.com.baizhi.dao=debug 12# 1.开发数据库- 这里采用最简单的表结构验证JWT使用 1234567DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` varchar(80) DEFAULT NULL COMMENT '用户名', `password` varchar(40) DEFAULT NULL COMMENT '用户密码', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 1# 2.开发entity 1234567@Data@Accessors(chain=true)public class User &#123; private String id; private String name; private String password;&#125; ![image-20200805213539471](C:/Users/49572/Desktop/JWT实战教程资料/笔记/JWT 实战教程.assets/image-20200805213539471.png) 1# 3.开发DAO接口和mapper.xml 1234@Mapperpublic interface UserDAO &#123; User login(User user);&#125; 123456&lt;mapper namespace=\"com.baizhi.dao.UserDAO\"&gt; &lt;!--这里就写的简单点了毕竟不是重点--&gt; &lt;select id=\"login\" parameterType=\"User\" resultType=\"User\"&gt; select * from user where name=#&#123;name&#125; and password = #&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; 1# 4.开发Service 接口以及实现类 123public interface UserService &#123; User login(User user);//登录接口&#125; 123456789101112131415@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; @Autowired private UserDAO userDAO; @Override @Transactional(propagation = Propagation.SUPPORTS) public User login(User user) &#123; User userDB = userDAO.login(user); if(userDB!=null)&#123; return userDB; &#125; throw new RuntimeException(\"登录失败~~\"); &#125;&#125; 1# 5.开发controller 123456789101112131415161718192021222324252627@RestController@Slf4jpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(\"/user/login\") public Map&lt;String,Object&gt; login(User user) &#123; Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); log.info(\"用户名: [&#123;&#125;]\", user.getName()); log.info(\"密码: [&#123;&#125;]\", user.getPassword()); try &#123; User userDB = userService.login(user); Map&lt;String, String&gt; map = new HashMap&lt;&gt;();//用来存放payload map.put(\"id\",userDB.getId()); map.put(\"username\", userDB.getName()); String token = JWTUtils.getToken(map); result.put(\"state\",true); result.put(\"msg\",\"登录成功!!!\"); result.put(\"token\",token); //成功返回token信息 &#125; catch (Exception e) &#123; e.printStackTrace(); result.put(\"state\",\"false\"); result.put(\"msg\",e.getMessage()); &#125; return result; &#125;&#125; 1# 6.数据库添加测试数据启动项目 1# 7.通过postman模拟登录失败 1# 8.通过postman模拟登录成功 1# 9.编写测试接口 1234567891011121314151617181920212223@PostMapping(\"/test/test\")public Map&lt;String, Object&gt; test(String token) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); map.put(\"msg\", \"验证通过~~~\"); map.put(\"state\", true); &#125; catch (TokenExpiredException e) &#123; map.put(\"state\", false); map.put(\"msg\", \"Token已经过期!!!\"); &#125; catch (SignatureVerificationException e)&#123; map.put(\"state\", false); map.put(\"msg\", \"签名错误!!!\"); &#125; catch (AlgorithmMismatchException e)&#123; map.put(\"state\", false); map.put(\"msg\", \"加密算法不匹配!!!\"); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(\"state\", false); map.put(\"msg\", \"无效token~~\"); &#125; return map;&#125; 1# 10.通过postman请求接口 123# 11.问题?- 使用上述方式每次都要传递token数据,每个方法都需要验证token代码冗余,不够灵活? 如何优化- 使用拦截器进行优化 1234567891011121314151617181920212223242526@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getHeader(\"token\"); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); return true; &#125; catch (TokenExpiredException e) &#123; map.put(\"state\", false); map.put(\"msg\", \"Token已经过期!!!\"); &#125; catch (SignatureVerificationException e)&#123; map.put(\"state\", false); map.put(\"msg\", \"签名错误!!!\"); &#125; catch (AlgorithmMismatchException e)&#123; map.put(\"state\", false); map.put(\"msg\", \"加密算法不匹配!!!\"); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(\"state\", false); map.put(\"msg\", \"无效token~~\"); &#125; String json = new ObjectMapper().writeValueAsString(map); response.setContentType(\"application/json;charset=UTF-8\"); response.getWriter().println(json); return false;&#125; 123456789@Componentpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new JwtTokenInterceptor()). excludePathPatterns(\"/user/**\") .addPathPatterns(\"/**\"); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JWT","slug":"JWT","permalink":"http://yoursite.com/tags/JWT/"}]},{"title":"RabbitMQ","slug":"RabbitMQ","date":"2021-01-15T15:10:40.000Z","updated":"2021-01-17T12:21:20.575Z","comments":true,"path":"2021/01/15/RabbitMQ/","link":"","permalink":"http://yoursite.com/2021/01/15/RabbitMQ/","excerpt":"MQ(Message Queue)消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。别名为消息中间件通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。","text":"MQ(Message Queue)消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。别名为消息中间件通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。 MQ引言什么是MQMQ(Message Queue)消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。别名为消息中间件通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。 MQ有哪些当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发RocketMQ等。 不同MQ的特点1234567891011# 1.ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!# 2.Kafka Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。# 3.RocketMQ RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。# 4.RabbitMQ RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在 RabbitMQ比Kafka可靠，Kafka更适合高吞吐的处理，一般应用在大数据日志处理或者对实时性(少量延迟)，可靠性(少量丢数据)要求稍低的场景使用，比如ELK日志收集。 RabbitMQ引言 基于AMQP协议，使用erlang开发，是部署最广泛消息中间件，是最受欢迎的开源消息中间件之一。 12# AMQP 协议 AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型: RabbitMQ支持的消息模型 RabbitMQ配置使用安装包安装12345678910111213141516171819# 1.将rabbitmq安装包上传到linux系统中 erlang-22.0.7-1.el7.x86_64.rpm rabbitmq-server-3.7.18-1.el7.noarch.rpm# 2.安装Erlang依赖包 rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm# 3.安装RabbitMQ安装包(需要联网) yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm 注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要 将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config# 4.复制配置文件 cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config# 5.查看配置文件位置 ls /etc/rabbitmq/rabbitmq.config# 6.修改配置文件(参见下图:) vim /etc/rabbitmq/rabbitmq.config 将上图中配置文件中红色部分去掉%%,以及最后的,逗号 修改为下图: 123456789101112131415161718192021222324252627282930313233343536373839# 7.执行如下命令,启动rabbitmq中的插件管理 rabbitmq-plugins enable rabbitmq_management 出现如下说明: Enabling plugins on node rabbit@localhost: rabbitmq_management The following plugins have been configured: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatch Applying plugin configuration to rabbit@localhost... The following plugins have been enabled: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatch set 3 plugins. Offline change; changes will take effect at broker restart.# 8.启动RabbitMQ的服务 systemctl start rabbitmq-server systemctl restart rabbitmq-server systemctl stop rabbitmq-server # 9.查看服务状态(见下图:) systemctl status rabbitmq-server ● rabbitmq-server.service - RabbitMQ broker Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled) Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago Main PID: 2904 (beam.smp) Status: \"Initialized\" CGroup: /system.slice/rabbitmq-server.service ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf - MBlmbcs... ├─3220 erl_child_setup 32768 ├─3243 inet_gethost 4 └─3244 inet_gethost 4 ......... 12345678# 10.关闭防火墙服务 systemctl disable firewalld Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. systemctl stop firewalld # 11.访问web管理界面 http://10.15.0.8:15672/ 使用Docker启动1docker run -d --hostname rabbit-host --name rabbitmq -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=root -p 15672:15672 -p 5672:5672 rabbitmq:3-management 命令行管理12345678# 1.服务启动相关 systemctl start|restart|stop|status rabbitmq-server# 2.管理命令行 用来在不使用web管理界面情况下命令操作RabbitMQ rabbitmqctl help 可以查看更多命令# 3.插件管理命令行 rabbitmq-plugins enable|list|disable web界面介绍 connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况 channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。 Exchanges：交换机，用来实现消息的路由 Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。 创建虚拟主机12# 虚拟主机 为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。 绑定虚拟主机和用户创建好虚拟主机，我们还要给用户添加访问权限： 点击添加好的虚拟主机： 进入虚拟机设置界面: HelloWord版本引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt;&lt;/dependency&gt; 第一种模型(直连)![image-20191126165840602](C:/Users/49572/Desktop/RibbitMQ 实战教程.assets/image-20191126165840602.png) 在上图的模型中，有以下概念： P：生产者，也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 创建一个生产者123456789101112131415161718192021222324252627282930313233343536public class ProducerDemo &#123; @Test public void test() throws IOException, TimeoutException &#123; //创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); //设置mq主机 connectionFactory.setHost(\"121.196.147.102\"); //设置端口 connectionFactory.setPort(5672); //设置用户名和密码 connectionFactory.setUsername(\"root\"); connectionFactory.setPassword(\"root\"); //设置连接那个虚拟主机 connectionFactory.setVirtualHost(\"/zhang\"); //获取连接对象 Connection connection = connectionFactory.newConnection(); //获取连接中的通道 Channel channel = connection.createChannel(); //参数1：是否持久化 参数2：是否独占队列 参数3：是否自动删除 参数4：其他属性 channel.queueDeclare(\"hello\",false,false,false,null); /* 发布消息 参数1 交换机名称 参数2 队列名称 参数3 传递额外消息设置 参数4 消息的具体内容 */ channel.basicPublish(\"\",\"hello\",null,\"hello world\".getBytes()); channel.close(); connection.close(); &#125;&#125; 创建一个消费者这里我们使用main方法来进行测试，因为如果我们使用junit进行测试的话，可能接收不到消息。(因为可能我们的测试线程退出之前我们并没有拿到队列中的消息) 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ConsumerDemo &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"121.196.147.102\"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(\"/zhang\"); connectionFactory.setUsername(\"root\"); connectionFactory.setPassword(\"root\"); Connection connection = connectionFactory.newConnection(); //创建通道 Channel channel = connection.createChannel(); //通道绑定队列 channel.queueDeclare(\"hello\",false,false,false,null); //消费消息 /* 参数1 队列的名称 参数2 开启消息的自动确认机制 参数3 消费消息时的回调接口 */ channel.basicConsume(\"hello\",true,new DefaultConsumer(channel)&#123; /** * @param consumerTag * @param envelope * @param properties * @param body 消息队列中取出的消息 * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(new String(body)); &#125; &#125;); //channel.close(); //connection.close(); &#125;&#125; 参数说明1channel.queueDeclare(\"aaa\",true,false,false,null); 第一个参数队列名称 第二个参数通道是否持久化 开启之后 重启rabbitmq服务 hello通道会丢失，而aaa通道不会丢失(但是消息会丢失)。 想让消息不丢失可以在channel.basicPublish(&quot;&quot;,&quot;aaa&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN,&quot;hello world&quot;.getBytes());添加MessageProperties.PERSISTENT_TEXT_PLAIN，这样rabbitmq在服务关闭时就会把消息特通道持久化到硬盘中，重启时会把消息和队列进行恢复。 第三个参数表示是否独占队列 如果设置为true， 队列只能被当前通道所绑定，不能被其他通道绑定。如果有其他通道绑定会抛出错误。 第四个参数表示是否自动删除 被消费完后，队列没有其他消息是否自动删除。 WorkQueue版本Work queues，也被称为（Task queues），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。 角色： P：生产者：任务的发布者 C1：消费者-1，领取任务并且完成任务，假设完成速度较慢 C2：消费者-2：领取任务并完成任务，假设完成速度快 开发生产者1234567//通过通道声明队列channel.queueDeclare(\"work\", true, false, false, null);//生产消息for (int i = 0; i &lt; 10; i++) &#123; channel.basicPublish(\"\",\"work\",null,\"hello workqueue\".getBytes());&#125; 开发消费者(两个)12345678910Channel channel = connection.createChannel();channel.queueDeclare(\"work\",true,false,false,null);channel.basicConsume(\"work\",true,new DefaultConsumer(channel) &#123; @lombok.SneakyThrows @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"消费者-1：\" + new String(body)); Thread.sleep(1000); &#125;&#125;); 测试结果 总结：RabbitMQ默认情况下，会轮询消息给每个消费者，每个消费者都会收到相同数量的消息。 但是这并不是我们想要的，我们需要处理快的消费者多处理消息。 消息自动确认 Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We’ll also lose all the messages that were dispatched to this particular worker but were not yet handled. But we don’t want to lose any tasks. If a worker dies, we’d like the task to be delivered to another worker. 123456789channel.basicQos(1);//一次只接受一条未确认的消息//参数2:关闭自动确认消息channel.basicConsume(\"hello\",false,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"消费者1: \"+new String(body)); channel.basicAck(envelope.getDeliveryTag(),false);//手动确认消息 &#125;&#125;); 设置通道一次只能消费一个消息 关闭消息的自动确认,开启手动确认消息 Fanout版本fanout 扇出 也称为广播 ![image-20191126213115873](C:/Users/49572/Desktop/RibbitMQ 实战教程.assets/image-20191126213115873.png) 在广播模式下，消息发送流程是这样的： 可以有多个消费者 每个消费者有自己的queue（队列） 每个队列都要绑定到Exchange（交换机） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 交换机把消息发送给绑定过的所有队列 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 开发生产者1234//声明交换机channel.exchangeDeclare(\"logs\",\"fanout\");//广播 一条消息多个消费者同时消费//发布消息channel.basicPublish(\"logs\",\"\",null,\"hello\".getBytes()); 开发消费者-112345678910111213//绑定交换机channel.exchangeDeclare(\"logs\",\"fanout\");//创建临时队列String queue = channel.queueDeclare().getQueue();//将临时队列绑定exchangechannel.queueBind(queue,\"logs\",\"\");//处理消息channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"消费者1: \"+new String(body)); &#125;&#125;); 我们同时开发三个消费者。代码相同 测试结果 我们可以看到三个消费者都接收到了消息。 Routing版本 在Fanout模式中，一条消息，会被所有订阅者队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列所消费。这是我们就要用到Direct类型的交换机。 在Direct模型下： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息 图解： P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 1.开发生产者12345//声明交换机 参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发channel.exchangeDeclare(\"logs_direct\",\"direct\");String key = \"\";//发布消息channel.basicPublish(\"logs_direct\",key,null,(\"指定的route key\"+key+\"的消息\").getBytes()); 2.开发消费者-112345678910111213141516 //声明交换机channel.exchangeDeclare(\"logs_direct\",\"direct\");//创建临时队列String queue = channel.queueDeclare().getQueue();//绑定队列和交换机channel.queueBind(queue,\"logs_direct\",\"error\");channel.queueBind(queue,\"logs_direct\",\"info\");channel.queueBind(queue,\"logs_direct\",\"warn\");//消费消息channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"消费者1: \"+new String(body)); &#125;&#125;); 3.开发消费者-212345678910111213//声明交换机channel.exchangeDeclare(\"logs_direct\",\"direct\");//创建临时队列String queue = channel.queueDeclare().getQueue();//绑定队列和交换机channel.queueBind(queue,\"logs_direct\",\"error\");//消费消息channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"消费者2: \"+new String(body)); &#125;&#125;); 4.测试生产者发送Route key为error的消息时 5.测试生产者发送Route key为info的消息时 Topic版本Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！这种模型Routingkey 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 123456# 统配符 * (star) can substitute for exactly one word. 匹配不多不少恰好1个词 # (hash) can substitute for zero or more words. 匹配一个或多个词# 如: audit.# 匹配audit.irs.corporate或者 audit.irs 等 audit.* 只能匹配 audit.irs 1.开发生产者12345//生命交换机和交换机类型 topic 使用动态路由(通配符方式)channel.exchangeDeclare(\"topics\",\"topic\");String routekey = \"user.save\";//动态路由key//发布消息channel.basicPublish(\"topics\",routekey,null,(\"这是路由中的动态订阅模型,route key: [\"+routekey+\"]\").getBytes()); 2.开发消费者-1Routing Key中使用*通配符方式 1234567891011121314 //声明交换机channel.exchangeDeclare(\"topics\",\"topic\");//创建临时队列String queue = channel.queueDeclare().getQueue();//绑定队列与交换机并设置获取交换机中动态路由channel.queueBind(queue,\"topics\",\"user.*\");//消费消息channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"消费者1: \"+new String(body)); &#125;&#125;); 3.开发消费者-2Routing Key中使用#通配符方式 1234567891011121314//声明交换机channel.exchangeDeclare(\"topics\",\"topic\");//创建临时队列String queue = channel.queueDeclare().getQueue();//绑定队列与交换机并设置获取交换机中动态路由channel.queueBind(queue,\"topics\",\"user.#\");//消费消息channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"消费者2: \"+new String(body)); &#125;&#125;); SpringBoot整合RabbitMQHelloWorld0.依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1.编写配置文件123456789spring: application: name: rabbitmq-springboot rabbitmq: host: 121.196.147.102 port: 5672 username: root password: root virtual-host: /zhang 2.编写生产者123456789101112131415/** * @author liyuan.zhang * @date 2021/1/17 10:00 */@SpringBootTestpublic class RabbitMQTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void test()&#123; rabbitTemplate.convertAndSend(\"hello\",\"hello rabbitmq\"); &#125;&#125; RabbitTemplate 用来简化操作 使用时候直接在项目中注入即可使用，使用convertAndSend方法直接发送消息。 3.编写消费者1234567891011121314/** * @author liyuan.zhang * @date 2021/1/17 10:02 */@Component//默认 持久化 非独占 不自动删除队列@RabbitListener(queuesToDeclare = @Queue(value = \"hello\",declare = \"true\"))public class HelloCustomer &#123; @RabbitHandler public void receivel(String message)&#123; System.out.println(\"message=\" + message); &#125;&#125; @Queue注解可以指定队列的属性，默认持久化，非独占队列，不自动删除队列 WorkQueue1.编写生产者123456@Test public void testWork()&#123; for (int i = 0; i &lt; 10; i++) &#123; rabbitTemplate.convertAndSend(\"work\",\"hello rabbitmq - work\" + i); &#125; &#125; 2.编写消费者1234567891011121314151617@Componentpublic class WorkCustomer &#123; /** * 消费者1 * @param message */ @RabbitListener(queuesToDeclare = @Queue(value = \"work\")) public void receivel1(String message)&#123; System.out.println(\"messgae1:\" + message ); &#125; @RabbitListener(queuesToDeclare = @Queue(value = \"work\")) public void receivel2(String message)&#123; System.out.println(\"message2:\" + message); &#125;&#125; 说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置 Fanout1.开发生产者12345//广播模式@Testpublic void testFanout()&#123; rabbitTemplate.convertAndSend(\"logs\",\"\",\"hello rabbitmq - fanout\");&#125; 2.开发消费者123456789101112131415161718192021222324252627/** * @author liyuan.zhang * @date 2021/1/17 10:50 */@Componentpublic class FanoutCustomer &#123; @RabbitListener(bindings = &#123; @QueueBinding( value = @Queue,//不指定名称为创建临时队列 exchange = @Exchange(value = \"logs\",type = \"fanout\")//绑定交换机 ) &#125;) public void receive1(String message)&#123; System.out.println(\"message1 : \" + message); &#125; @RabbitListener(bindings = &#123; @QueueBinding( value = @Queue,//不指定名称为创建临时队列 exchange = @Exchange(value = \"logs\",type = \"fanout\")//绑定交换机 ) &#125;) public void receive2(String message)&#123; System.out.println(\"message2 : \" + message); &#125;&#125; Route1.开发生产者12345//路由模式@Testpublic void testRoute()&#123; rabbitTemplate.convertAndSend(\"directs\",\"info\",\"hello rabbitmq - direct\");&#125; 2.开发消费者1234567891011121314151617181920212223242526272829/** * @author liyuan.zhang * @date 2021/1/17 11:00 */@Componentpublic class RouteCustomer &#123; @RabbitListener(bindings = &#123; @QueueBinding( value = @Queue,//声明临时队列 exchange = @Exchange(value = \"directs\",type = \"direct\"), key = &#123;\"error\",\"info\",\"warning\"&#125; ) &#125;) public void receive1(String message)&#123; System.out.println(\"message1 : \" + message); &#125; @RabbitListener(bindings = &#123; @QueueBinding( value = @Queue, exchange = @Exchange(value = \"directs\",type = \"direct\"), key = &#123;\"error\"&#125; ) &#125;) public void receive2(String message)&#123; System.out.println(\"message2 :\" + message); &#125;&#125; Topic动态路由 1.开发生产者123456//topic 动态路由 订阅模式@Testpublic void testTopic()&#123; String routeKey = \"product.save\"; rabbitTemplate.convertAndSend(\"topics\",routeKey,\"要执行的业务是 : \" + routeKey);&#125; 2.开发消费者123456789101112131415161718192021222324252627282930/** * @author liyuan.zhang * @date 2021/1/17 11:18 */@Componentpublic class TopicCustomer &#123; @RabbitListener(bindings = &#123; @QueueBinding( value = @Queue, exchange = @Exchange(value = \"topics\",type = \"topic\"), key = &#123;\"user.#\"&#125; ) &#125;) public void receive1(String message)&#123; System.out.println(\"message1 :\" + message); &#125; @RabbitListener(bindings = &#123; @QueueBinding( value = @Queue, exchange = @Exchange(value = \"topics\",type = \"topic\"), key = &#123;\"product.*\",\"user.*\"&#125; ) &#125;) public void receive2(String message)&#123; System.out.println(\"message2 :\" + message); &#125;&#125; RabbitMQ的使用场景异步处理场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式 串行方式: 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. 并行方式:将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 消息队列:假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回. 消息队列: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。 应用解耦场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. 这种做法有一个缺点: 当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合. 引入消息队列 订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。 库存系统:订阅下单的消息,获取下单消息,进行库操作。 就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失. 流量削峰场景: 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。 作用: ​ 1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) ​ 2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) 1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面. 2.秒杀业务根据消息队列中的请求信息，再做后续处理.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"}]},{"title":"数据结构学习笔记","slug":"数据结构学习笔记","date":"2020-12-27T13:39:08.000Z","updated":"2020-12-27T13:40:56.258Z","comments":true,"path":"2020/12/27/数据结构学习笔记/","link":"","permalink":"http://yoursite.com/2020/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"数据结构学习笔记【持续更新。。】","text":"数据结构学习笔记【持续更新。。】 队列 队列是一个有序列表，可以用数组或者链表实现。(数组实现是顺序存储，链表实现是链式存储)。 遵循先入先出的原则，及现存如的数据，要先取出。后存入的数据要后取出。 数组模拟队列 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package day1队列;/** * @author zhang * @date 2020/12/15 20:55 */public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; ArrayQueue queue = new ArrayQueue(3); queue.addQueue(1); queue.addQueue(2); queue.addQueue(3); System.out.println(queue.headQueue()); //queue.showQueue(); int i = queue.getQueue(); //queue.showQueue(); System.out.println(queue.headQueue()); &#125;&#125;class ArrayQueue&#123; private int maxSize;//最大容量 private int front;//队列头 private int rear;//队列尾 private int[] arr;//该数组用于存放数据，模拟队列 public ArrayQueue(int maxSize)&#123; this.maxSize = maxSize; this.arr = new int[maxSize]; front = -1;//指向队列头部，分析出front是指向队列头的前一个位置 rear = -1; &#125; //判断队列是否满 public boolean isFull()&#123; return rear == maxSize - 1; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到队列 public void addQueue(int n)&#123; //判断队列是否满了 if (isFull())&#123; System.out.println(\"队列已经满了\"); return; &#125; rear++; arr[rear] = n; &#125; //数据取出队列，出队列 public int getQueue()&#123; //判断数组是否为空 if (isEmpty())&#123; //抛出异常 throw new RuntimeException(\"队列为空，不能取数据\"); &#125; front++; return arr[front]; &#125; //显示队列的所有数据 public void showQueue()&#123; if (isEmpty())&#123; System.out.println(\"队列为空，没有数据\"); return; &#125; //Arrays.toString(arr); for (int i = front + 1; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; //显示对头数据 public int headQueue()&#123; if (isEmpty())&#123; throw new RuntimeException(\"队列空的，没有数据\"); &#125; return arr[front + 1]; &#125;&#125; 数据不能重复使用。 数组模拟环形队列 思路调整 front变量的含义做一个调整:front就是指向队列的第一个元素，front的初始值为0。 rear变量的含义做一个调整:rear指向队列的最后元素的后一个位置，rear的初始值为0。 当队列满时，条件是(rear + 1) % maxSize = front 队列为空时，条件是rear == front 队列中有效数据的个数(rear + maxSize - front) % maxSize 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package day1队列;/** * @author zhang * @date 2020/12/15 22:23 */public class CircleArrayQueueDemo &#123; public static void main(String[] args) &#123; CircleArrayQueue queue = new CircleArrayQueue(4);//有效数据最大是3 queue.addQueue(1); queue.addQueue(2); queue.addQueue(3); int i = queue.getQueue(); int i2 = queue.getQueue(); queue.showQueue(); System.out.println(queue.size()); System.out.println(queue.headQueue()); &#125;&#125;class CircleArrayQueue&#123; private int maxSize;//最大容量 private int front;//队列头 private int rear;//队列尾 private int[] arr;//该数组用于存放数据，模拟队列 public CircleArrayQueue(int maxSize)&#123; this.maxSize = maxSize; this.arr = new int[maxSize]; front = 0;//指向队列头部，分析出front是指向队列头的前一个位置 rear = 0; &#125; //判断队列是否满 public boolean isFull()&#123; return (rear + 1) % maxSize == front; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return rear == front; &#125; //添加数据到队列 public void addQueue(int n)&#123; //判断队列是否满了 if (isFull())&#123; System.out.println(\"队列已经满了\"); return; &#125; arr[rear] = n; //将rear后移 rear = (rear + 1) % maxSize; &#125; //数据取出队列，出队列 public int getQueue()&#123; //判断数组是否为空 if (isEmpty())&#123; //抛出异常 throw new RuntimeException(\"队列为空，不能取数据\"); &#125; int val = arr[front]; //front后移 front = (front + 1) % maxSize; return val; &#125; //显示队列的所有数据 public void showQueue()&#123; if (isEmpty())&#123; System.out.println(\"队列为空，没有数据\"); return; &#125; //Arrays.toString(arr); for (int i = front ; i &lt; front + size(); i++) &#123; System.out.printf(\"arr[%d]=%d\\n\",i % maxSize,arr[i % maxSize]); &#125; &#125; //显示对头数据 public int headQueue()&#123; if (isEmpty())&#123; throw new RuntimeException(\"队列空的，没有数据\"); &#125; return arr[front]; &#125; //求出当前队列有效数据的个数 public int size()&#123; return (rear + maxSize - front) % maxSize; &#125;&#125; 链表![链表物理结构示意图](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/未命名文件 (1).png) ![逻辑结构示意图](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/未命名文件 (2).png) 链表以节点的方式来存储，是链式存储。 每个节点包含data域，next域(指向下一个节点)。 内内地址不一定连续。 链表分为带头结点的链表和不带头节点的链表。 单链表的实际应用 使用带头结点的单链表实现-水浒英雄排行榜管理 1）完成对英雄人物的增删改查 2）第一种方式在添加英雄时，根据排名将英雄插入到链表的尾部 3）第二种方式在添加英雄时，根据排名将英雄插入到指定位置 ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/未命名文件 (3).png) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package day2链表;/** * @author zhang * @date 2020/12/16 22:33 */public class SingleLinkedListDemo &#123; public static void main(String[] args) &#123; SingleLinkedList singleLinkedList = new SingleLinkedList(); singleLinkedList.add(new HeroNode(1,\"松江\",\"及时雨\")); singleLinkedList.add(new HeroNode(2,\"卢俊义\",\"玉麒麟\")); singleLinkedList.add(new HeroNode(3,\"吴用\",\"智多星\")); singleLinkedList.add(new HeroNode(4,\"林冲\",\"豹子头\")); singleLinkedList.list(); &#125;&#125;/** * 定义一个SingleLinedList管理我们的英雄 */class SingleLinkedList&#123; //初始化一个头节点 private HeroNode head = new HeroNode(0,\"\",\"\"); /** * 添加节点到单链表 * 1.找到当前链表的的最后节点(next为空) * 2.将最后节点的next指向新的节点 */ public void add(HeroNode heroNode)&#123; HeroNode temp = head; while (temp.next != null)&#123; //后移 temp = temp.next; &#125; temp.next = heroNode; &#125; public void list()&#123; //判断链表是否为空 if (head.next == null)&#123; System.out.println(\"链表为空\"); return; &#125; //头节点不能动，需要一个辅助变量来遍历 HeroNode temp = head; while (temp.next != null)&#123; System.out.println(temp.next); //将next后移 temp = temp.next; &#125; &#125;&#125;/** * 每一个英雄都是一个节点 */class HeroNode&#123; public int no; public String name; public String nickName; public HeroNode next;//指向下一个节点 public HeroNode(int no,String name,String nickName)&#123; this.no = no; this.name = name; this.nickName = nickName; &#125; @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + \", nickName='\" + nickName + '\\'' + '&#125;'; &#125;&#125; 第二种方式在添加英雄时，根据排名将英雄插入到指定位置 123456789101112131415161718192021222324252627282930313233/** * 第二种方式在添加英雄时，根据排名将英雄插入到指定位置 */public void addByOrder(HeroNode heroNode)&#123; HeroNode temp = head; boolean flag = false;//表示添加的编号是否存在默认为false while (true)&#123; if (temp.next == null)&#123; //说明temp已经在链表的最后面了 break; &#125; if (temp.next.no &gt; heroNode.no)&#123; //位置找到，就在temp的后面插入 break; &#125; else if (temp.next.no == heroNode.no)&#123; //说明要添加的编号已经存在了 flag = true; break; &#125; //后移，遍历链表 temp = temp.next; &#125; if (flag == true)&#123; System.out.printf(\"待插入的英雄的编号[%d]已经存在了，不能加入\\n\",heroNode.no); &#125;else &#123; //新的节点的next指向temp.next //temp.next等于新的节点 heroNode.next = temp.next; temp.next = heroNode; &#125;&#125; 删除节点 思路： 首先找到要删除节点的前一个节点temp temp.next = temp.next.next 被删除的节点，没有任何引用指向它，将会被GC回收 代码实现 1234567891011121314151617181920212223public void delete(int no)&#123; HeroNode temp = head; boolean flag = false;//表示是否找到待删除节点 while (true)&#123; if (temp.next == null)&#123; //已经到链表的最后了 break; &#125; if (temp.next.no == no)&#123; //说明找到了待删除节点的前一个节点temp flag = true; break; &#125; temp = temp.next; &#125; if (flag)&#123; //找到 temp.next = temp.next.next; &#125;else &#123; System.out.printf(\"没有找到待删除的节点[%d]\\n\",no); &#125;&#125; 单链表常见面试题1.单链表的反转 思路： 先定义一个节点reverseHead = new Node(); 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新链表reverseHead的最前端 原来的链表的head.next = reverseHead.next 双向链表 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package day3双向列表;/** * @author zhang * @date 2020/12/27 17:17 */public class DoubleLinkedListDemo &#123; public static void main(String[] args) &#123; DoubleLindedList doubleLindedList = new DoubleLindedList(); doubleLindedList.add(new Node(1,\"宋江\")); doubleLindedList.add(new Node(2,\"卢俊义\")); doubleLindedList.add(new Node(3,\"吴用\")); doubleLindedList.add(new Node(4,\"林冲\")); doubleLindedList.list(); doubleLindedList.update(new Node(3,\"公孙胜\")); doubleLindedList.list(); doubleLindedList.delete(2); doubleLindedList.list(); &#125;&#125;//创建一个双向链表的类class DoubleLindedList&#123; private Node head = new Node(0,\"\"); //返回头节点 public Node getHead()&#123; return head; &#125; //遍历双向链表的一个方法 public void list()&#123; //判断链表是否为空 if (head.next == null)&#123; System.out.println(\"链表为空\"); return; &#125; Node temp = head.next; while (true)&#123; //判断链表是否到最后 if (temp.next == null)&#123; break; &#125; //输出节点信息 System.out.println(temp); //节点后移 temp = temp.next; &#125; &#125; //添加一个节点到双向链表的最后 public void add(Node node)&#123; Node temp = head; //遍历节点，找到最后 while (true)&#123; //找到链表最后 if (temp.next == null)&#123; break; &#125; temp = temp.next; &#125; //形成一个双向链表 temp.next = node; node.pre = temp; &#125; //修改一个节点的内容 public void update(Node node)&#123; //判断是否为空 if (head.next == null)&#123; System.out.println(\"链表为空\"); return; &#125; Node temp = head; boolean flag = false;//表示是否找到该节点 while (true)&#123; if (temp == null)&#123; break; &#125; if (temp.no == node.no)&#123; flag = true; break; &#125; temp = temp.next; &#125; if (flag)&#123; temp.name = node.name; &#125;else &#123; System.out.printf(\"没有找到编号为[%d]的节点\",node.no); &#125; &#125; /** * 删除一个节点 * 对于双向链表，我们直接找到要删除的节点，找到后自我删除即可 */ public void delete(int no)&#123; //判断当前链表是否为空 if (head.next == null)&#123; System.out.println(\"链表为空,无法删除\"); return; &#125; Node temp = head.next; boolean flag = false; while (true)&#123; if (temp == null)&#123; //已经到链表的最后节点的next break; &#125; if (temp.no == no)&#123; //找到待删除的节点 flag = true; break; &#125; //temp后移 temp = temp.next; &#125; if (flag)&#123; //删除 temp.pre.next = temp.next; //这样有风险，如果是最后一个节点，就不需要执行，否则空指针异常 if (temp.next != null)&#123; temp.next.pre = temp.pre; &#125; &#125; &#125;&#125;class Node&#123; public int no; public String name; public Node next;//指向下一个节点,默认为null public Node pre;//指向前一个节点，默认为null public Node(int no, String name) &#123; this.no = no; this.name = name; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 单向环形链表 约瑟夫问题 约瑟夫环是一个数学的应用问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。 假设n=5，即有5个人。 k=1，从第一个人开始报数 m=2，数两下 构建一个单向循环链表的的思路(curNode的next指向新的元素，新的元素的next指向first，curNode后移) 先构建第一个节点，让first指向该节点，并形成环。 后面我们没创建一个新的节点，就把该节点，加入到已有的环形链表即可 遍历环形链表 先让一个辅助指针指向first节点 后通过一个while循环遍历该环形链表即可(current.next == first) 出圈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package day4单向循环链表;/** * @author zhang * @date 2020/12/27 20:39 */public class Josepfu &#123; public static void main(String[] args) &#123; CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList(); circleSingleLinkedList.addNode(5);//加入5个节点 //circleSingleLinkedList.list(); //测试出圈 circleSingleLinkedList.out(1,2,5); &#125;&#125;//创建一个环形的单向链表class CircleSingleLinkedList&#123; //创建一个first节点，当前没有编号 private Node first = null; //添加node节点，构建成一个环形链表 public void addNode(int nums)&#123; //数据校验 if (nums &lt; 1)&#123; throw new RuntimeException(\"非法参数\"); &#125; Node curNode = null;//辅助指针 for (int i = 1; i &lt;= nums; i++) &#123; //根据编号创建node节点 Node node = new Node(i); //如果是第一个node if (i == 1)&#123; first = node; first.setNext(first);//构成一个环，只是环中只有一个元素 curNode = first;//curNode指向第一个节点 &#125;else &#123; curNode.setNext(node); node.setNext(first); curNode = node; &#125; &#125; &#125; //遍历当前环形链表 public void list()&#123; //判空 if (first == null)&#123; System.out.println(\"链表为空\"); return; &#125; //first不能动，使用辅助指针完成遍历 Node curNode = first; while (true)&#123; System.out.printf(\"NODE节点的编号 %d \\n\",curNode.getNo()); if (curNode.getNext() == first)&#123; //说明遍历完毕 break; &#125; //后移 curNode = curNode.getNext(); &#125; &#125; /** * 根据用户的输入，计算出出圈的顺序 * @param startNode 从第几个节点开始 * @param countNum 表示数几下 * @param nums 表示最初有多少节点在圈中 */ public void out(int startNode,int countNum,int nums)&#123; //数据校验 if (first == null || startNode &lt; 1 || startNode &gt; nums)&#123; throw new RuntimeException(\"非法参数\"); &#125; //创建一个辅助指针 Node helper = first; //让helper指向了最后一个节点 while (helper.getNext() != first) &#123; helper = helper.getNext(); &#125; //报数之前，first和helper先移动k-1次 for (int i = 0; i &lt; startNode - 1; i++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //当小孩报数时，让first和helper指针移动m-1次，然后出圈 while (true)&#123; if (helper == first)&#123; //说明圈中只有一个节点 break; &#125; for (int i = 0; i &lt; countNum - 1; i++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //这是first指向的节点，就是要出圈的节点 System.out.printf(\"节点%d出圈 \\n\",first.getNo()); first = first.getNext(); helper.setNext(first); &#125; System.out.printf(\"最后留在圈中的节点 %d \\n\",first.getNo()); &#125;&#125;//节点类class Node&#123; private int no; private Node next;//下一个节点，默认是null public Node(int no)&#123; this.no = no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"java动态代理","slug":"java动态代理","date":"2020-12-22T09:52:13.000Z","updated":"2020-12-24T12:58:31.364Z","comments":true,"path":"2020/12/22/java动态代理/","link":"","permalink":"http://yoursite.com/2020/12/22/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"目前java动态代理的实现分为两种 基于JDK的动态代理(面向接口) 基于CGILB的动态代理(面向父类)","text":"目前java动态代理的实现分为两种 基于JDK的动态代理(面向接口) 基于CGILB的动态代理(面向父类) 作用在业务中使用动态代理，一般是为了给需要实现的方法添加预处理或者添加后续操作，但是不干预实现类的正常业务，把一些基本业务和主要的业务逻辑分离。我们一般所熟知的Spring的AOP原理就是基于动态代理实现的 基于JDK的动态代理基于JDK的动态代理就需要知道两个类：1.InvocationHandler（接口）、2.Proxy（类） 第一步、创建一个接口 123456789package dynamicProxy;/** * @author zhang * @date 2020/12/22 17:36 */public interface Subject &#123; void hello(String param);&#125; 第二步、实现接口 123456789101112package dynamicProxy;/** * @author zhang * @date 2020/12/22 17:36 */public class SubjectImpl implements Subject&#123; @Override public void hello(String param) &#123; System.out.println(\"Hello World\"); &#125;&#125; 第三步、创建SubjectImpl的代理类 1234567891011121314151617181920212223242526package dynamicProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * @author zhang * @date 2020/12/22 17:37 * 创建SubjectImpl代理类 */public class SubjectProxy implements InvocationHandler &#123; private Subject subject; public SubjectProxy(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"--------begin-------\"); //利用反射调用类里面的实际方法 Object invoke = method.invoke(subject, args); System.out.println(\"---------end--------\"); return invoke; &#125;&#125; 第四步、编写代理类的实际调用，利用Proxy类创建代理之后的Subject类 1234567891011121314151617181920212223package dynamicProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;/** * @author zhang * @date 2020/12/22 17:43 * 代理类实际调用 */public class Test &#123; public static void main(String[] args) &#123; Subject subject = new SubjectImpl(); InvocationHandler subjectProxy = new SubjectProxy(subject); Subject subjectProxy1 = (Subject) Proxy.newProxyInstance( subjectProxy.getClass().getClassLoader(),//代理类的类加载器 subject.getClass().getInterfaces(),//被代理的接口，如果有多个就是数组形式传入 subjectProxy//代理类的实例 ); subjectProxy1.hello(\"\"); &#125;&#125; 基于CGLIB的动态代理因为基于JDK的动态代理一定要继承一个接口，而绝大部分情况是基于POJO类的动态代理，那么CGLIB就是一个很好的选择，在Hibernate框架中PO的字节码生产工作就是靠CGLIB来完成的。 引入CGLIB jar包 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 创建代理类 1234567891011package dynamicProxy;/** * @author zhang * @date 2020/12/22 18:06 */public class CGSubject &#123; public void hello(String param)&#123; System.out.println(\"hello\" + param); &#125;&#125; 实现MethodInterceptor接口，对方法进行拦截 1234567891011121314151617181920package dynamicProxy;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * @author zhang * @date 2020/12/22 18:08 */public class HelloInterceptor implements MethodInterceptor &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"----------begin---------\"); Object object = methodProxy.invokeSuper(o, objects); System.out.println(\"-----------end-----------\"); return object; &#125;&#125; 创建被代理的类 1234567891011121314151617package dynamicProxy;import net.sf.cglib.proxy.Enhancer;/** * @author zhang * @date 2020/12/24 20:55 */public class CGTest &#123; public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(CGSubject.class); enhancer.setCallback(new HelloInterceptor()); CGSubject cgSubject = (CGSubject) enhancer.create(); cgSubject.hello(\"zhangsan\"); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2020-12-21T08:34:15.000Z","updated":"2020-12-27T09:00:02.639Z","comments":true,"path":"2020/12/21/Docker学习笔记/","link":"","permalink":"http://yoursite.com/2020/12/21/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Docker学习笔记","text":"Docker学习笔记 docker虚拟机配置网络可以使用dhclient工具为虚拟机分配一个可用的ip 123456789101112# 分配ip地址dhclient# 修改网络配置vi /etc/sysconfig/network-scripts/ifcfg-ens33BOOTPROTO=\"static\"ONBOOT=\"yes\"# 添加如下配置IPADDR=192.168.31.17 #注意这是分配的IPGATEWAY=192.168.31.1DNS1=119.29.29.29 一.修改网络配置: vi /etc/sysconfig/network-scripts/ifcfg-ens33 2.输入i进入编辑模式，将最后一行的ONBOOT=no改为ONBOOT=yes 按Esc键，输入“：wq!”,保存并退出 然后重启网络，输入service network restart 输入ip addr查看ip Docker的历史有意思的是，Docker 公司起初是一家名为 dotCloud 的平台即服务（Platform-as-a-Service, PaaS）提供商。 底层技术上，dotCloud 平台利用了 Linux 容器技术。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的！ 2013年，dotCloud 的 PaaS 业务并不景气，公司需要寻求新的突破。于是他们聘请了 Ben Golub 作为新的 CEO，将公司重命名为“Docker”，放弃dotCloud PaaS 平台，怀揣着“将 Docker 和容器技术推向全世界”的使命，开启了一段新的征程。 如今 Docker 公司被普遍认为是一家创新型科技公司，据说其市场价值约为 10 亿美元。Docker 公司已经通过多轮融资，吸纳了来自硅谷的几家风投公司的累计超过 2.4 亿美元的投资。 几乎所有的融资都发生在公司更名为“Docker”之后。 提示：“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人。 Docker能干嘛 之前的虚拟机技术 虚拟机缺点 资源占用多 冗余步骤多 启动慢 容器化技术 容器化技术并不是一个完整的技术 一个容器包含了运行环境和应用，每个容器时互相隔离的，容器直接运行在操作系统之上，从分利用操作系统的资源。 Docker 是一个开源的应用容器引擎，基于Go语言并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 比较Docker和虚拟机不同： 传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，在这个系统上安装和操作软件。 容器内的应用直接运行在宿主机的内容，容器是没有内核的，也没有虚拟我们的硬件，所以是非常轻便的。 没有容器间是相互隔离的，每个容器都有属于自己的文件系统，互不影响。 DevOps(开发、运维) 更快速的交付和部署。 更便捷的升级和扩缩容。 更简单的系统运维。 更高效的计算机资源利用(Docker是内核级别的虚拟化) Docker的基本组成 镜像(image)镜像就是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建很多容器 容器(container)Docker利用容器独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启用，开始，停止，删除。每个容器都是相互隔离的，保证安全的平台。 可以把容器看作是一个简易版的Linux环境(包括root用户权限，进程空间，用户空间和网络空间等)和运行在其中的应用程序。 容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的 仓库(repository)仓库是集中存放镜像文件的场所。 仓库和仓库注册服务器(Registry)是有区别的，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签 仓库分为公开仓库(public)和私有仓库(private)两种形式 最大的开放仓库是Docker Hub： https://hub.docker.com/ 存放了数量庞大的镜像供用户下载。 国内的公开仓库包括阿里云，网易云等 安装Docker查看系统内核 12[root@MiWiFi-R4A-srv /]# uname -r3.10.0-1062.el7.x86_64 查看系统版本 12345678910111213141516[root@MiWiFi-R4A-srv /]# cat /etc/os-release NAME=\"CentOS Linux\"VERSION=\"7 (Core)\"ID=\"centos\"ID_LIKE=\"rhel fedora\"VERSION_ID=\"7\"PRETTY_NAME=\"CentOS Linux 7 (Core)\"ANSI_COLOR=\"0;31\"CPE_NAME=\"cpe:/o:centos:centos:7\"HOME_URL=\"https://www.centos.org/\"BUG_REPORT_URL=\"https://bugs.centos.org/\"CENTOS_MANTISBT_PROJECT=\"CentOS-7\"CENTOS_MANTISBT_PROJECT_VERSION=\"7\"REDHAT_SUPPORT_PRODUCT=\"centos\"REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 卸载旧的版本 12345678910111213141516171819202122232425262728293031323334353637383940414243# 卸载旧版本$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 需要的安装包sudo yum install -y yum-utils# 设置镜像的仓库sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 更新yum软件包索引yum makecache fast# 安装docker相关 docker-ce社区版 ee版企业版sudo yum install docker-ce docker-ce-cli containerd.io# 启动dockersudo systemctl start docker# 使用docker -version查看是否安装成功docker -version# hello world程序docker run hello-world# 查看镜像[root@MiWiFi-R4A-srv ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtomcat latest 6d15a1d68603 7 days ago 649MBmysql 8.0.22 ab2f358b8612 8 days ago 545MBmysql latest ab2f358b8612 8 days ago 545MBredis latest ef47f3b6dc11 8 days ago 104MBcentos centos7 8652b9f0cb4c 5 weeks ago 204MBhello-world latest bf756fb1ae65 11 months ago 13.3kB 卸载Docker 12345# 卸载依赖$ sudo yum remove docker-ce docker-ce-cli containerd.io# 删除资源$ sudo rm -rf /var/lib/docker 阿里云镜像加速 1234567891011sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://n1p195zp.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 底层原理Docker是怎么工作的？ Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 DockerServer接收到Docker-Client的指令，就会执行这个命令。 为什么Docker比VM快？ Docker有着虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上Docker将会有明显优势。 Docker利用的是宿主机的内核，而不需要GuestOS，因此，当新建一个容器时Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载GuestOS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker只需几秒钟。 Docker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 Docker的常用命令帮助命令123docker --version # 显示Docker的版本信息docker info # 显示Docker的系统信息，包括镜像和容器的数量docker --help # 帮助命令 镜像命令123docker images # 查看本地所有镜像docker images -a # 列出本地所有的镜像（含中间映像层）docker images -q # 只显示id 12docker search mysql # 搜索镜像docker search mysql --filter=STARS=3000 # 过滤只搜索3000satr以上的 12docker pull mysql # 如果不写tag，默认latest最新版docker pull mysql:5.7 # 指定版本下载 1docker rmi 697daaecf703 # Docker删除镜像 容器命令有镜像才能创建容器，下载一个centos镜像来学习。 1docker pull centos 新建容器并启动 123456789101112131415161718docker run [可选参数] image# 参数说明--name=\"NAME\" 容器名字，用来区别容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p -p 8080:8080 -p 主机端口:容器端口(常用) -p 容器端口 容器端口-P 随机指定端口# 测试docker run -it centos /bin/bash# 从容器退回主机exit 列出所有正在运行的容器 12345678910[root@MiWiFi-R4A-srv /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES581a17d041b4 centos \"/bin/bash\" 3 minutes ago Up 3 minutes nice_roentgendocker ps -a # 列出所有容器docker ps -a -n=1 # 显示最近创建的容器docker ps -aq # 显示当前容器的编号 退出容器 12exit # 直接容器停止并退出Ctrl + P + Q # 容器不停止退出 删除容器 12docker rm 容器id # 删除指定的容器，不能删除正在运行的容器docker rm -f $(docker ps -ap) # 删除所有的容器 启动和停止容器操作 1234docker start容器id # 启动容器docker restart 容器id # 重启容器docker stop 容器id # 停止容器docker kill 容器id #强制停止当前容器 常用其他命令后台启动容器 123docker run -d centos# docker ps发现centos停止了# 常见的坑，dokcer容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 查看日志 1docker logs -f -t --tail 容器id 查看容器中进程信息 123[root@MiWiFi-R4A-srv ~]# docker top 847858ee8a4aUID PID PPID C STIME TTY TIME CMDroot 5967 5947 0 22:28 ? 00:00:00 /bin/bash 查看镜像的元数据 1docker inspect 847858ee8a4a 进入当前正在运行的容器12345# 方式一 开启一个新的终端docker exec -it 847858ee8a4a /bin/bash# 方式二 执行正在运行的终端docker attach 847858ee8a4a #正在执行当前的代码 从容器内部拷贝文件到主机上1234docker cp 容器id：容器内路径 目的主机路径# 将dockers内部/home下的zhang.java拷贝到主机的homedocker cp dc6084befe30:/home/zhang.java /home 练习 Docker安装nginx 123456# 搜索镜像docker search nginx# 下载镜像docker pull nginx# 运行镜像 -d后台运行 --name给容器命名 -p宿主机端口docker run -d --name nginx01 -p 3344:80 nginx Docker安装tomcat 12# 官方的使用(-rm 用完及删除，用于测试)docker run --rm tomcat:9.0 可视化 portainer docker图形化管理工具 安装 12docker run -d -p 8088:9000 \\--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 访问测试 Rancher(CI/CD) Docker镜像镜像是什么镜像是一个轻量级、可执行的的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的内容，包括代码，运行时库，环境变量和配置文件。 如何得到镜像呢？ 远程仓库下载 拷贝 自己制作一个镜像 Docker镜像加载原理 UnionFS(联合文件系统) Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 Docker镜像的加载原理 docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs(boot file system) 主要包含bootloader和kernel，bootloader 主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就存在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 roorfs （root file system），在bootfs之上。包含的就是典型Linux系统中的 /dev ，/proc，/bin ，/etx 等标准的目录和文件。rootfs就是各种不同的操作系统发行版。比如Ubuntu，Centos等等。 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host（宿主机）的kernel，自己只需要提供rootfs就行了，由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部。这一层就是我们通常说的容器层，容器之下都叫镜像层。 Commit镜像123docker commit # 提交容器成为一个新的版本docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[tag] 实战测试 123456789101112# 启动一个默认的tomcatdocker run -it -p 9999:9999 tomcat# 发现这个tomcat，webapps下面时没有文件的root@24cc7cd482ff:/usr/local/tomcat# cd webappsroot@24cc7cd482ff:/usr/local/tomcat/webapps# ls# 自己拷贝进去基本的文件root@24cc7cd482ff:/usr/local/tomcat# cp -r webapps.dist/* webapps# 生成一个新镜像docker commit -a=\"zhang\" -m=\"add webapps app\" 24cc7cd482ff tomcat02:1.0 这就是我们修改过的镜像 安装MySQLmysql数据的持久化问题 123456789[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysqle1911d0e9045f63df828e4639196ce32e1bf631e21df3c7fb789c487055d572b# 启动mysql-d 后台运行-p 端口映射-v 卷挂载-e 环境配置 密码--name 容器名称 测试连接 进入host的home目录，发现mysql目录，进入data目录可以看到数据。 我们利用本地navicat新建一个数据库，再次查看data目录下文件 发现多了test文件，说明映射的路径是ok的。 假设我们删除容器 发现数据并没消失 Dockerfiledockerfile就是用来构建docker镜像的构建文件(命令脚本,通过这个脚本可以生成镜像) 12345# 创建一个dockerfile文件FROM centosVOLUME [\"volume01\",\"volume02\"]CMD echo \"------end--------\"CMD /bin/bash 1docker build -f /home/docker-test-voume/dockerfile01 -t zhangdemo/centos:1.o . 启动自己的镜像 构建步骤 编写一个dokerfile文件 docker build构建一个镜像 docker run 运行镜像 docker push 发布镜像 基础知识 每个关键字都是大写 执行从上到下的顺序 # 表示注释 每一个指令都会创建提交一个新的镜像层，并提交 dockerfile是面向开发。Docker逐渐成为了企业交付的标准。 DockerFile的指令123456789101112FROM # 基础镜像，一切从这里开始构建MAINTAINER # 镜像是谁写的，姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤，tomcat镜像，这个tomcat的压缩包！添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录位置EXPOST # 暴露端口CMD # 指定容器启动时要输出的命令，只有最后一个会生效，可被替代ENTRYPOINT # 指定容器启动时要输出的命令，可以追加命令ONBUILD # 当构建一个被继承DockerFile这个时候就会运行ONBUILD指令，触发指令。COPY # 类似ADD命令，将文件拷贝到镜像中ENV # 构建的时候设置环境变量 构建自己的Centos1.编写dockerfile的配置文件 1234567891011121314151617181920212223#基于CentosFROM centos#告诉别人我是谁MAINTAINER zhang&lt;495726603@qq.com&gt;#环境变量ENV MYPATH /usr/local#工作目录WORKDIR $MYPATH#安装一个vimRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo \"-----end-------\"CMD /bin/bash 2.通过文件构建镜像 1234docker build -f mydockerfile -t mycentos:v1 .# -f 代表dockerfile的文件路径# -t 镜像名和版本号 3.测试运行 可以看到运行的工作目录为我们在dockerfile中配置的工作目录， 并且ifconfig命令可用了. 4.可以通过docker history 镜像id列出本地镜像的变更地址 CMD和ENTRYPOINT的区别 测试cmd 12345678910111213141516171819202122232425262728# 编写dockerfile文件vim dockerfile-cmd-testFROM centosCMD [\"ls\",\"-a\"]#构建镜像docker build -f dockerfile-cmd-test -t cmdtest .#run运行，发现我们的ls -a命令生效[root@izbp13r5pmefkwfqgkx4i2z dockerfile]# docker run bef2698bd130....dockerenvbindevetchomeliblib64lost+foundmedia#想追加一个命令 -l ls -al[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run bef2698bd130 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: \"-l\": executable file not found in $PATH: unknown.#cmd的情况下 -l替换了CMD[\"ls\",\"-a\"]命令 ，不是命令所以报错 测试entryporint(我们追加的命令，是直接在我们的entrypoint命令后面的) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970[root@izbp13r5pmefkwfqgkx4i2z ~]# vim dockerfile-cmd-entrypoint[root@izbp13r5pmefkwfqgkx4i2z ~]# docker build -f dockerfile-cmd-entrypoint -t entorypoint-test .Sending build context to Docker daemon 726kBStep 1/2 : FROM centos ---&gt; 300e315adb2fStep 2/2 : ENTRYPOINT [\"ls\",\"-a\"] ---&gt; Running in 51ffcc67a242Removing intermediate container 51ffcc67a242 ---&gt; 4645e2e60db1Successfully built 4645e2e60db1Successfully tagged entorypoint-test:latest[root@izbp13r5pmefkwfqgkx4i2z ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEentorypoint-test latest 4645e2e60db1 15 seconds ago 209MBcmdtest latest bef2698bd130 14 minutes ago 209MBmycentos v1 ee0d621d29ee 2 hours ago 282MBzhangdemo/centos 1.o 8bb60281dfef 4 hours ago 209MBmysql latest a347a5928046 4 days ago 545MBtomcat latest feba8d001e3f 8 days ago 649MBredis latest ef47f3b6dc11 2 weeks ago 104MBcentos latest 300e315adb2f 2 weeks ago 209MBportainer/portainer latest 62771b0b9b09 5 months ago 79.1MBhello-world latest bf756fb1ae65 11 months ago 13.3kB[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run 4645e2e60db1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run 4645e2e60db1 -ltotal 56drwxr-xr-x 1 root root 4096 Dec 26 13:15 .drwxr-xr-x 1 root root 4096 Dec 26 13:15 ..-rwxr-xr-x 1 root root 0 Dec 26 13:15 .dockerenvlrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Dec 26 13:15 devdrwxr-xr-x 1 root root 4096 Dec 26 13:15 etcdrwxr-xr-x 2 root root 4096 Nov 3 15:22 homelrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Dec 4 17:37 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 15:22 mediadrwxr-xr-x 2 root root 4096 Nov 3 15:22 mntdrwxr-xr-x 2 root root 4096 Nov 3 15:22 optdr-xr-xr-x 90 root root 0 Dec 26 13:15 procdr-xr-x--- 2 root root 4096 Dec 4 17:37 rootdrwxr-xr-x 11 root root 4096 Dec 4 17:37 runlrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 15:22 srvdr-xr-xr-x 13 root root 0 Dec 26 13:15 sysdrwxrwxrwt 7 root root 4096 Dec 4 17:37 tmpdrwxr-xr-x 12 root root 4096 Dec 4 17:37 usrdrwxr-xr-x 20 root root 4096 Dec 4 17:37 var 实战：Tomcat镜像1.准备镜像文件，tomcat压缩包，tomcat依赖java，需要jdk 2.编写dockekfile文件。官方命名Dockerfile，使用这个就不需要加-f指定文件名 1234567891011121314151617181920212223242526272829303132333435363738# 基础镜像FROM centosMAINTAINER zhangliyuan&lt;495726603@qq.com&gt;COPY readme.txt /tomcat/readme.txt# 用add命令会自动帮我们解压ADD jdk-11.0.8_linux-x64_bin.tar.gz /usr/local/ADD apache-tomcat-9.0.41.tar.gz /usr/local/# 安装vimRUN yum -y install vim# 环境变量ENV MYPATH /usr/local# 工作目录WORKDIR $MYPATH# java环境变量ENV JAVA_HOME /usr/loacl/jdk11.0.8ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# 配置tomcat环境变量ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#暴露端口EXPOSE 8080# tomcat日志CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.41/bin/logs/catalina.out 3.构建镜像 1docker build -t diytomcat . 发布自己的镜像DockerHub登录dockerhub login -u zhangliyuandocker```1234567891011121314151617181920212223242526272829303132333435363738394041424344增加一个tag`docker tag a6c12980154f zhangliyuan/tomcat:1.0`提交`docker push zhangliyuan/tomcat:1.0`![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12272.png)#### 阿里云- 找到镜像容器服务- 创建命名空间- 创建容器镜像![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12273.png)### Springboot项目打包- 在idea中新建Dockerfile文件```shellFROM java:8WORKDIR /appCOPY upload.jar .CMD [\"--server.port=8080\"]EXPOSE 8080ENTRYPOINT java -jar upload.jar 将Dockerfile和jar包用xftp上传到服务器 构建镜像 docker build -t zhangupload . 运行 docker run -d -P --name upload zhangupload 测试 查看日志 sudo docker logs -f -t --tail 行数 容器名","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"Dubbo和Zookeeper集成","slug":"Dubbo和Zookeeper集成","date":"2020-10-24T03:01:19.000Z","updated":"2020-10-24T07:02:32.995Z","comments":true,"path":"2020/10/24/Dubbo和Zookeeper集成/","link":"","permalink":"http://yoursite.com/2020/10/24/Dubbo%E5%92%8CZookeeper%E9%9B%86%E6%88%90/","excerpt":"分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。","text":"分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 什么是RPC框架RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； dubbo基本概念 服务提供者(Provider):暴露服务的服务提供发，服务提供者启动时，向注册中心注册自己提供的服务 服务消费者(Consumer):调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己锁需要的服务，服务消费者从提供者列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选用另一台 注册中心(Register):注册中心返回服务提供者地址列表给服务消费者，如果有变更，注册中心将基于长连接推送变更数据给数据消费者 监控中心(Moiter):服务消费者和提供者，在内存累计调用次数和调用时间，定义每分钟发送一次统计数据到监控中心 使用Dubbo-admindubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。 地址 ：https://github.com/apache/dubbo-admin/tree/master 下载完成后解压,修改dubbo-admin-server下的配置文件，修改成我们自己的配置即可 将这个项目达成jar包 mvn clean package -Dmaven.test.skip=true 用java -jar启动就好了 访问localhost:8080 测试环境搭建Linux安装zookeeper xftp上传zookeeper到根目录 解压zookeeper到指定目录 tar -zxvf zookeeper-3.4.6.tar.gz -C /usr/local/ 进入zookeeper目录 cd zookeeper-3.4.6 创建data目录 mkdir data 进入conf目录 cd conf 重命名/拷贝zoo_sample.cfg,修改为zoo.cfg mv zoo_sample.cfg zoo.cfg vim进入zoo.cfg文件 vim zoo.cfg 修改zoo.cfg文件 修改datadir=/usr/local/zookeeper-3.4.6/data注意:使用i进入修改模式,修改后使用esc退出修改,输入:wq退出vim 操作zookeeper1.启动进入bin目录下,执行./zkServer.sh start 2.停止./zkServer.sh stop 3.查看状态./zkServer.sh status SpringBoot+dubbo+zookeeper编写服务提供者 导入依赖 12345678910111213141516171819202122232425262728293031323334353637&lt;!--dubbo--&gt;&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 编写service接口 12345678package com.gem.service;/** * @author zhang * @date 2020/10/24 13:43 */public interface HelloService &#123; String sayHello(String name);&#125; 编写实现类 这里注意@Service注解使用的是dubbo的而非spring提供的，loadbalance表示负载均衡，interfaceClass指定接口 12345678910111213141516package com.gem.service.impl;import com.gem.service.HelloService;import org.apache.dubbo.config.annotation.Service;/** * @author zhang * @date 2020/10/24 13:50 */@Service(loadbalance = \"random\",interfaceClass = HelloService.class)public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return \"Hello,\" + name; &#125;&#125; 配置文件 12345678#当前应用名称dubbo.application.name=dubbo-prodiver#注册中心地址dubbo.registry.address=zookeeper://192.168.40.130:2181#扫描指定包下的服务dubbo.scan.base-packages=com.gem.service#服务器端口server.port=9999 编写服务消费者 导入依赖 同上 编写service接口 同上 配置文件 123456789101112#当前应用名称dubbo: application: name: dubbo-consumer registry: address: zookeeper://192.168.40.130:2181 scan: base-packages: com.gem.controllerserver: port: 8888 编写Controller 我们要使用服务提供者的服务，使用@Reference注解去注册中心查找服务 123456789101112131415161718192021222324package com.gem.controller;import com.gem.service.HelloService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @author zhang * @date 2020/10/24 13:58 */@Controllerpublic class HelloController &#123; //到注册中心查找服务 @Reference(check = false,loadbalance = \"random\") HelloService helloService; @RequestMapping(\"/hello\") @ResponseBody public String sayHello(String name)&#123; return helloService.sayHello(name); &#125;&#125; 测试启动服务器，访问呢服务消费者的controller","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot集成editor.md","slug":"SpringBoot集成editor-md","date":"2020-10-13T12:21:23.000Z","updated":"2020-10-13T12:52:52.811Z","comments":true,"path":"2020/10/13/SpringBoot集成editor-md/","link":"","permalink":"http://yoursite.com/2020/10/13/SpringBoot%E9%9B%86%E6%88%90editor-md/","excerpt":"SpringBoot集成editor.md Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费。","text":"SpringBoot集成editor.md Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费。 基础工程搭建article：文章表 字段 类型 备注 id int 文章的唯一ID author varchar 作者 title varchar 标题 content longtext 文章的内容 建表SQL： 1234567CREATE TABLE `article` (`id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'int文章的唯一ID',`author` varchar(50) NOT NULL COMMENT '作者',`title` varchar(100) NOT NULL COMMENT '标题',`content` longtext NOT NULL COMMENT '文章的内容',PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 实体类 123456789101112//文章类@Data@NoArgsConstructor@AllArgsConstructorpublic class Article implements Serializable &#123; private int id; //文章的唯一ID private String author; //作者名 private String title; //标题 private String content; //文章的内容&#125; mapper接口 12345678910111213141516@Mapper@Repositorypublic interface ArticleMapper &#123; //查询所有的文章 List&lt;Article&gt; queryArticles(); //新增一个文章 int addArticle(Article article); //根据文章id查询文章 Article getArticleById(int id); //根据文章id删除文章 int deleteArticleById(int id);&#125; 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.kuang.mapper.ArticleMapper\"&gt; &lt;select id=\"queryArticles\" resultType=\"Article\"&gt; select * from article &lt;/select&gt; &lt;select id=\"getArticleById\" resultType=\"Article\"&gt; select * from article where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=\"addArticle\" parameterType=\"Article\"&gt; insert into article (author,title,content) values (#&#123;author&#125;,#&#123;title&#125;,#&#123;content&#125;); &lt;/insert&gt; &lt;delete id=\"deleteArticleById\" parameterType=\"int\"&gt; delete from article where id = #&#123;id&#125; &lt;/delete&gt; &lt;/mapper&gt; 文章编辑整合下载好的项目结构 进入examples文件夹css和js文件夹粘到项目的static文件夹下，另外粘贴项目根目录下的css文件夹的editormd.css和js文件夹下的editormd.js，最后把整个lib也粘贴过来。 项目路径 编辑文章页面 editor.html、需要引入 jQuery； 需要修改css和js的路径，和path的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html class=\"x-admin-sm\" lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi\" /&gt; &lt;!--Editor.md--&gt; &lt;link rel=\"stylesheet\" th:href=\"@&#123;/css/style.css&#125;\"&gt; &lt;link rel=\"stylesheet\" th:href=\"@&#123;/css/editormd.css&#125;\"/&gt; &lt;link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"layui-fluid\"&gt; &lt;div class=\"layui-row layui-col-space15\"&gt; &lt;div class=\"layui-col-md12\"&gt; &lt;!--博客表单--&gt; &lt;form name=\"mdEditorForm\"&gt; &lt;div&gt; 标题：&lt;input type=\"text\" name=\"title\"&gt; &lt;/div&gt; &lt;div&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt; &lt;/div&gt; &lt;div id=\"article-content\"&gt; &lt;textarea name=\"content\" id=\"content\" style=\"display:none;\"&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;!--editormd--&gt;&lt;script th:src=\"@&#123;/js/jquery.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/js/editormd.js&#125;\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var testEditor; //window.onload = function()&#123; &#125; $(function() &#123; testEditor = editormd(\"article-content\", &#123; width : \"100%\", height : 600, syncScrolling : \"single\", path : \"../lib/\", saveHTMLToTextarea : true, // 保存 HTML 到 Textarea emoji: true, theme: \"default\",//工具栏主题 previewTheme: \"default\",//预览主题 editorTheme: \"pastel-on-default\",//编辑主题 tex : true, // 开启科学公式TeX语言支持，默认关闭 flowChart : true, // 开启流程图支持，默认关闭 sequenceDiagram : true, // 开启时序/序列图支持，默认关闭, //图片上传 imageUpload : true, imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"], imageUploadURL : \"/article/file/upload\", onload : function() &#123; console.log('onload', this); &#125;, /*指定需要显示的功能按钮*/ toolbarIcons : function() &#123; return [\"undo\",\"redo\",\"|\", \"bold\",\"del\",\"italic\",\"quote\",\"ucwords\",\"uppercase\",\"lowercase\",\"|\", \"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"|\", \"list-ul\",\"list-ol\",\"hr\",\"|\", \"link\",\"reference-link\",\"image\",\"code\",\"preformatted-text\", \"code-block\",\"table\",\"datetime\",\"emoji\",\"html-entities\",\"pagebreak\",\"|\", \"goto-line\",\"watch\",\"preview\",\"fullscreen\",\"clear\",\"search\",\"|\", \"help\",\"info\",\"releaseIcon\", \"index\"] &#125;, /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/ toolbarIconTexts : &#123; releaseIcon : \"&lt;span bgcolor=\\\"gray\\\"&gt;发布&lt;/span&gt;\", index : \"&lt;span bgcolor=\\\"red\\\"&gt;返回首页&lt;/span&gt;\", &#125;, /*给自定义按钮指定回调函数*/ toolbarHandlers:&#123; releaseIcon : function(cm, icon, cursor, selection) &#123; //表单提交 mdEditorForm.method = \"post\"; mdEditorForm.action = \"/article/addArticle\";//提交至服务器的路径 mdEditorForm.submit(); &#125;, index : function()&#123; window.location.href = '/'; &#125;, &#125; &#125;); &#125;);&lt;/script&gt;&lt;/html&gt; 编写Controller，进行跳转，以及保存文章 123456789101112131415@Controller@RequestMapping(\"/article\")public class ArticleController &#123; @GetMapping(\"/toEditor\") public String toEditor()&#123; return \"editor\"; &#125; @PostMapping(\"/addArticle\") public String addArticle(Article article)&#123; articleMapper.addArticle(article); return \"editor\"; &#125;&#125; 图片上传问题js中添加 1234//图片上传imageUpload : true,imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],imageUploadURL : \"/article/file/upload\", // //这个是上传图片时的访问地址 后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.66&lt;/version&gt;&lt;/dependency&gt; controller 1234567891011121314151617181920212223242526272829303132333435//博客图片上传问题 @RequestMapping(\"/file/upload\") @ResponseBody public JSONObject fileUpload(@RequestParam(value = \"editormd-image-file\", required = true) MultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 //获得SpringBoot当前项目的路径：System.getProperty(\"user.dir\") String path = System.getProperty(\"user.dir\")+\"/upload/\"; //按照月份进行分类：// Calendar instance = Calendar.getInstance();// String month = (instance.get(Calendar.MONTH) + 1)+\"月\";// path = path+month; File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //解决文件名字问题：我们使用uuid; String filename = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ filename)); //给editormd进行回调 JSONObject res = new JSONObject(); res.put(\"url\",\"/upload/\"+\"/\"+ filename); res.put(\"success\", 1); res.put(\"message\", \"upload success!\"); return res; &#125; 解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！ 123456789101112@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; // 文件保存在真实目录/upload/下， // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/upload/**\") .addResourceLocations(\"file:\"+System.getProperty(\"user.dir\")+\"/upload/\"); &#125;&#125; 文章展示controller增加方法 123456@GetMapping(\"/&#123;id&#125;\")public String show(@PathVariable(\"id\") int id,Model model)&#123; Article article = articleMapper.getArticleById(id); model.addAttribute(\"article\",article); return \"article\";&#125; 编写页面 article.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;title th:text=\"$&#123;article.title&#125;\"&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt; &lt;h2 style=\"margin: auto 0\" th:text=\"$&#123;article.title&#125;\"&gt;&lt;/h2&gt; 作者：&lt;span style=\"float: left\" th:text=\"$&#123;article.author&#125;\"&gt;&lt;/span&gt; &lt;!--文章主体内容--&gt; &lt;div id=\"doc-content\" style=\"width: 80%;margin-left: 10%\"&gt; &lt;textarea style=\"display:none;\" placeholder=\"markdown\" th:text=\"$&#123;article.content&#125;\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt;&lt;link rel=\"stylesheet\" th:href=\"@&#123;/editormd/css/editormd.preview.css&#125;\" /&gt;&lt;script th:src=\"@&#123;/js/jquery.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/marked.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/prettify.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/raphael.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/underscore.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/sequence-diagram.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/flowchart.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/lib/jquery.flowchart.min.js&#125;\"&gt;&lt;/script&gt;&lt;script th:src=\"@&#123;/js/editormd.js&#125;\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var testEditor; $(function () &#123; testEditor = editormd.markdownToHTML(\"doc-content\", &#123;//注意：这里是上面DIV的id htmlDecode: \"style,script,iframe\", emoji: true, taskList: true, tocm: true, tex: true, // 默认不解析 flowChart: true, // 默认不解析 sequenceDiagram: true, // 默认不解析 codeFold: true &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同样需要修改js和css","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot笔记","slug":"SpringBoot笔记","date":"2020-10-12T13:20:28.000Z","updated":"2020-10-14T10:57:57.216Z","comments":true,"path":"2020/10/12/SpringBoot笔记/","link":"","permalink":"http://yoursite.com/2020/10/12/SpringBoot%E7%AC%94%E8%AE%B0/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 Spring优缺点优点：Spring是java企业级的轻量代替品，Spring为企业级java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的java对象实现了EJB的功能。 缺点：虽然Spring的组件是轻量级的，但是Spring的配置文件确实重量级的，此外项目的依赖管理也是一件耗时耗力的事。 Spring的概述SpringBoot对上述Spring的缺点进行了改善了优化，基于约定由于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中。 SpringBoot的优点 为基于Spring的代码开发提供了更快的入门体验 开箱即用，没有代码生成，也无需xml配置，同时可以修改默认值来满足特定的需求 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器，安全，指标，健康检测，外部配置等。 SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式 SpringBoot的核心功能 起步依赖 起步依赖本质上是一个Maven项目对象模型，定义了对其他库的传递依赖，这些东西加载一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 自动配置 SpringBoot的自定配置是一个运行的过程，考虑了众多元素，才决定Spring配置中应该用哪个，不该用哪个，该过程是SpringBoot自动完成的。 SpringBoot原理分析起步依赖按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）： 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/parent&gt; 按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）： 12345678910111213141516171819202122&lt;properties&gt; &lt;activemq.version&gt;5.15.13&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.82&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.12.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.6&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.16.1&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;awaitility.version&gt;4.0.3&lt;/awaitility.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;build-helper-maven-plugin.version&gt;3.1.0&lt;/build-helper-maven-plugin.version&gt; &lt;byte-buddy.version&gt;1.10.14&lt;/byte-buddy.version&gt; &lt;caffeine.version&gt;2.8.5&lt;/caffeine.version&gt; &lt;cassandra-driver.version&gt;4.6.1&lt;/cassandra-driver.version&gt; &lt;classmate.version&gt;1.5.1&lt;/classmate.version&gt; &lt;commons-codec.version&gt;1.14&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.7.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.10&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; &lt;commons-pool2.version&gt;2.8.1&lt;/commons-pool2.version&gt; &lt;couchbase-client.version&gt;3.0.8&lt;/couchbase-client.version&gt; &lt;db2-jdbc.version&gt;11.5.4.0&lt;/db2-jdbc.version&gt; 从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分的坐标版本、管理依赖、插件管理已经定义好了，所有我们的SpringBoot工程继承spring-boot-stater-parent后已经具备版本锁定等配置了。所有起步依赖的作用就是进行依赖的传递。 自动配置按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication 1234567@SpringBootApplicationpublic class Springdemo02Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Springdemo02Application.class, args); &#125;&#125; 注解@SpringBootApplication的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @AliasFor( annotation = EnableAutoConfiguration.class ) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor( annotation = EnableAutoConfiguration.class ) String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackages\" ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackageClasses\" ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = \"nameGenerator\" ) Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true;&#125; 其中，@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类@EnableAutoConfiguration：SpringBoot自动配置功能开启按住Ctrl点击查看注解@EnableAutoConfiguration 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; SpringBoot工程热部署在pom.xml中添加(也可在创建SpringBoot项目的时候勾选) 1234567&lt;!-- 热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 对idea进行配置 然后 Shift+Ctrl+Alt+/，选择Registry 勾选 SpringBoot配置文件SpringBoot是基于约定的，所有很多配置都有默认值，但如果相使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml进行配置。 自定义配置配置文件与配置类的映射方式 123person: name: zhangsan age: 20 使用@Value来映射我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上 1234567891011121314151617181920/** * @author zhang * @date 2020/10/10 9:39 */@Controllerpublic class HelloController &#123; @Value(\"$&#123;person.name&#125;\") private String name; @Value(\"$&#123;person.age&#125;\") private int age; @ResponseBody @RequestMapping(\"/index\") public String index()&#123; System.out.println(name + \"---------\" + age); return \"Hello Spring Boot\"; &#125;&#125; 使用@ConfigurationProperties先导入依赖 12345&lt;dependency&gt; &lt;groupId&gt; org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt; spring-boot-configuration-processor &lt;/artifactId&gt; &lt;optional&gt; true &lt;/optional&gt;&lt;/dependency&gt; 测试类(提供set方法) 12345678910111213141516171819202122232425262728/** * @author zhang * @date 2020/10/10 9:39 */@Controller@ConfigurationProperties(prefix = \"person\")public class HelloController &#123; private String name; private int age; @ResponseBody @RequestMapping(\"/index\") public String index()&#123; System.out.println(name + \"---------\" + age); return \"Hello Spring Boot\"; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 整合Myabtis添加Mybatis起步依赖和数据库驱动 123456789101112&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt;&lt;/dependency&gt; 在application.yml中添加数据库配置信息 1234567#数据源spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/study?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8 username: root password: root 在application.yml中添加mybatis配置信息 12345678#mybatis配置mybatis: #别名 type-aliases-package: com.gem.springdemo1.entity #扫描mapper mapper-locations: classpath:com/gem/springdemo1/mapper/*Mapper.xml configuration: log-impl: org.apache.ibatis.logging.log4j.Log4jImpl SpringBoot默认使用logback作为日志打印工具，我们要想查看sql语句，需要使用log4j 导入log4j的起步依赖 12345678910111213&lt;!-- log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;!-- 修复重复绑定报红的问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 在application.yml中配置 123mybatis: configuration: log-impl: org.apache.ibatis.logging.log4j.Log4jImpl 整合Junit添加依赖 123456&lt;!-- 测试启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在测试类上加上对应的注解 12@SpringBootTest(classes = Springdemo1Application.class)@RunWith(SpringRunner.class) 静态资源在SpringBoot中有四个目录可以放我们的静态资源 - &quot;classpath:/META-INF/resources/&quot; - &quot;classpath:/resources/&quot; - &quot;classpath:/static/&quot; - &quot;classpath:/public/&quot;例如 网站图标的说明 与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。 1、关闭SpringBoot默认图标 12#关闭默认图标spring.mvc.favicon.enabled=false 2、自己放一个图标在静态资源目录下 Thymeleaf模板引擎jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。SpringBoot推荐你可以来使用模板引擎 引入Thymeleaf 12345&lt;!-- thymeleaf模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 创建一个Controller，model添加一个User实体，返回hello.html 12345678910111213141516/** * @author zhang * @date 2020/10/12 9:42 */@Controllerpublic class HelloController &#123; @RequestMapping(\"/index\") public String index(Model model)&#123; User user = new User(1L,\"张三\",new Date()); model.addAttribute(\"user\",user); model.addAttribute(\"num\",10); model.addAttribute(\"gender\",\"w\"); return \"hello\"; &#125;&#125; 在hello.html中获取数据 在html中引入Thymeleaf 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 在标签中取值使用th:text(写在标签体中)，使用#datas.format来格式化时间 处理字符串和数字类型同理 12345&lt;div&gt; &lt;p th:text=\"$&#123;user.id&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;user.username&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;#dates.format(user.createDate,'yyyy-MM-dd HH:mm:ss')&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 如果是表单标签使用th:value设置值 1&lt;input type=\"text\" th:value=\"$&#123;user.id&#125;\"&gt; 单选框使用th:attr设置属性 12&lt;input name=\"gender\" type=\"radio\" th:attr=\"checked=$&#123;gender eq 'm'?true:false&#125;\"&gt;男 &lt;input name=\"gender\" type=\"radio\" th:attr=\"checked=$&#123;gender eq 'w'?true:false&#125;\"&gt;女 if123456&lt;div&gt; &lt;p th:if=\"$&#123;num == 10&#125;\"&gt;num:10&lt;/p&gt; &lt;p th:if=\"$&#123;num == 20&#125;\"&gt;num:20&lt;/p&gt; &lt;p th:if=\"$&#123;num == 30&#125;\"&gt;num:30&lt;/p&gt;&lt;/div&gt; switch case12345&lt;div th:switch=\"$&#123;num&#125;\"&gt; &lt;p th:case=\"10\"&gt;num为10&lt;/p&gt; &lt;p th:case=\"20\"&gt;num为20&lt;/p&gt; &lt;p th:case=\"30\"&gt;num为30&lt;/p&gt;&lt;/div&gt; each编写一个controller，模拟数据查询到的list 1234567891011121314151617181920/** * @author zhang * @date 2020/10/12 15:54 */@Controller@RequestMapping(\"/user\")public class UserController &#123; @RequestMapping(\"/userList\") public String userList(Model model)&#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L,\"张三\",new Date())); list.add(new User(2L,\"李四\",new Date())); list.add(new User(3L,\"王五\",new Date())); list.add(new User(4L,\"赵六\",new Date())); list.add(new User(5L,\"田七\",new Date())); model.addAttribute(\"userList\",list); return \"user\"; &#125;&#125; html代码 1234567891011121314151617&lt;table&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"u:$&#123;userList&#125;\"&gt; &lt;td th:text=\"$&#123;u.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;u.username&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(u.createDate,'yyyy-MM-dd')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href=\"@&#123;/user/edit(id=$&#123;u.id&#125;)&#125;\" th:text=\"编辑\"&gt;&lt;/a&gt; &lt;a th:href=\"@&#123;'/user/delete/' + $&#123;u.id&#125;&#125;\" th:text=\"删除\"&gt;&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; url、href、src问题，原始？传参版本使用th:href动态的写，参数使用()传递 1&lt;a th:href=\"@&#123;/user/edit(id=$&#123;u.id&#125;)&#125;\" th:text=\"编辑\"&gt;&lt;/a&gt; Controller 12345@RequestMapping(\"/edit\")public String editUser(int id)&#123; System.out.println(\"要修改的id是\" + id); return \"user\";&#125; Rest风格 1&lt;a th:href=\"@&#123;'/user/delete/' + $&#123;u.id&#125;&#125;\" th:text=\"删除\"&gt;&lt;/a&gt; Controller 12345@RequestMapping(\"/delete/&#123;id&#125;\")public String deleteUser(@PathVariable(\"id\") int id)&#123; System.out.println(\"要删除的id是:\" + id); return \"user\";&#125; 使用{参数}表示展位符，使用@pathVaiable注解获取url中占位符，并且绑定到方法的参数上。 引入css 1&lt;link rel=\"stylesheet\" th:href=\"@&#123;/css/style.css&#125;\"&gt; 全局异常处理@ControllerAdvice搭配@ExceptionHandler注解 123456789101112@ControllerAdvicepublic class WebException &#123; @ExceptionHandler(value = Exception.class) public ModelAndView defaultException(Exception e, HttpServletRequest request)&#123; ModelAndView mv=new ModelAndView(); mv.setViewName(\"error\"); //异常对象 mv.addObject(\"exception\",e); //异常请求 mv.addObject(\"url\",request.getRequestURI()); return mv; &#125; 拦截器springboot拦截器和springmvc一样，自己定义一个类实现HandlerInterceptor接口，实现其中的preHandle方法就可以了。 12345678910111213141516171819202122232425262728293031323334public class WebInterceptor implements HandlerInterceptor &#123; /** * * @param request * @param response * @param handler * @return * @throws Exception * * 登录验证： * 拦截所有请求 * 对于登录请求放行 * 非登录请求进行登录验证（currUser是否为空） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String uri=request.getRequestURI(); System.out.println(uri); if(uri.endsWith(\"/login\")||uri.endsWith(\"/toLogin\")||uri.endsWith(\"/\"))&#123; //登录请求 放行 return true; &#125; // HttpSession session=request.getSession(); Object user=session.getAttribute(\"currUser\"); if(user==null)&#123; //未登录 //跳转到登录页 response.sendRedirect(request.getContextPath()+\"/toLogin\"); return false; &#125; return true; &#125;&#125; 重要的是拦截器的配置。 自己定义一个配置类，打上@Configuration注解，实现WebMvcConfigurer接口,重写addInterceptors方法,注意静态资源要剔除掉。 1234567891011@Configurationpublic class WebMvc implements WebMvcConfigurer &#123; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new WebInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/css/**\") .excludePathPatterns(\"/js/**\") .excludePathPatterns(\"/images/**\"); &#125;&#125; 给指定视图添加控制层同样写一个配置类，实现WebMvcConfigurer接口，实现addViewControllers方法 123456789101112131415@Configurationpublic class WebMvc implements WebMvcConfigurer &#123; /** * * @param registry * registry给指定的视图添加控制层 * login */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //http://localhost:8088/ProductWeb/ registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/toLogin\").setViewName(\"login\"); &#125;&#125; 文件上传和配置本地静态资源路径配置本地服务器路径为静态路径 注意原来的静态资源路径也要配置进去，自己本地的路径前要加file 1234567spring: #将图片服务器路径配置为静态路径 resources: static-locations: classptah:/static/,classpath:/public/,classpath:/resource/,file:$&#123;imgFile&#125;#图片的访问路径imgFile: D:\\a_demo\\img 上传文件页面 修改表单的类型为multipart/form-data 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=\"@&#123;/file/upload&#125;\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"imgFile\"&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 文件上传Controller，上传完毕进行展示 12345678910111213141516171819202122232425262728293031323334/** * @author zhang * @date 2020/10/14 9:20 */@Controller@RequestMapping(\"/file\")public class FileUploadController &#123; @Value(\"$&#123;imgFile&#125;\") private String targetPath; @RequestMapping(\"/uploadPage\") public String uploadPage()&#123; return \"/upload/fileupload\"; &#125; @RequestMapping(\"/upload\") public String upload(MultipartFile imgFile, Model model) throws IOException &#123; //获取文件名称，包含上传文件的后缀 String fileName = imgFile.getOriginalFilename(); //获取文件上传的后缀名 assert fileName != null; String suffix = fileName.substring(fileName.lastIndexOf(\".\")); //文件重命名 fileName = UUID.randomUUID().toString().replace(\"-\",\"\").toLowerCase() + suffix; System.out.println(\"上传的文件名称:\"+fileName); System.out.println(\"上传的路径\" + targetPath); //上传 imgFile.transferTo(new File(targetPath,fileName)); model.addAttribute(\"path\",fileName); return \"upload/show\"; &#125; 可以默认上传的文件大小 1234567spring: servlet: multipart: #单文件大小 max-file-size: 10MB #总文件大小 max-request-size: 100MB 整合Mybatis分页插件 PageHelper导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; 剩下的和Mybatis一样，设置分页参数，封装PageInfo对象即可。","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2020-09-29T13:12:05.000Z","updated":"2020-09-29T13:13:48.554Z","comments":true,"path":"2020/09/29/SpringMVC/","link":"","permalink":"http://yoursite.com/2020/09/29/SpringMVC/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 三层架构和MVC三层架构表现层：也就是我们常说的web层，它负责接收客户端请求，向客户端相应结果，，通常客户端使用http请求web层。 业务层：也就是我们说的service层，负责逻辑业务处理，和我们开发项目的需求息息相关，web层依赖于业务层，但业务层不依赖于web层。 持久层：也就是我们常说的dao层，负责数据持久化。通俗的讲，持久层就是和数据库交互，对数据库表进行增删改查。 MVC模型 全名Model View Controller，是模型，视图，和控制器的缩写，是一种用于设计创建web应用程序表现层的模式。是一种软件设计规范。 是将业务逻辑，数据，显示分离的方式来阻止代码。 MVC的主要作用是降低视图和业务逻辑之间的双向耦合 MVC不是一种设计模式，是一种架构模式 Model(模型)：通常指我们的数据模型，作用一般情况下用于封装数据。 View(视图)：负责进行模型的展示，通常指我们的jsp或者html。 Controller(控制器)：接收请求，委托给模型处理，，处理完毕后把返回的模型数据返回给视图，由视图负责展示。 SpringMVC Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 SpringMVC的特点: 轻量级，简单易学 高效，基于请求的相应的MVC框架 与Spring兼容性好，无缝结合 约定大于配置 功能强大:restful、数据验证、格式化、本地化、主题等 简单灵活 SpringMVC和Structs2的优略分析共同点: ​ 他们都是表现层框架，都是基于MVC模型编写的。 ​ 他们的底层都离不开原始的ServletAPI ​ 它们处理请求的机制都是一个核心控制器 区别: ​ SpringMVC的入口是Servlet和Structs2是Filter ​ SpringMVC基于方法设计的，而Structs是基于类，Structs2每次执行都会创建一个动作类，所有SpringMVC会稍比Structs2快些。 ​ SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 ​ SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。 ​ pring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高 入门程序修改web.xml，配置DispatherServlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;!--配置SpringMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc配置文件(XML配置文件)--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--容器启动时就创建前端控制器对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置全局过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 注意：/ 和 /* 的区别 &lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错 配置mvc配置文件 mvc.xml类似于spring配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--mvc注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置mvc扫描包--&gt; &lt;context:component-scan base-package=\"com.gem.controller\"/&gt; &lt;!--配置静态资源处理--&gt;&lt;!-- &lt;mvc:resources mapping=\"/asserts/**\" location=\"/asserts/\"/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--拦截路径--&gt; &lt;mvc:mapping path=\"/test/**\"/&gt; &lt;!--剔除拦截--&gt; &lt;mvc:exclude-mapping path=\"/test/test2\"/&gt; &lt;bean class=\"com.gem.interceptor.MyInterceptor\" id=\"myInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!--配置文件上传解析器--&gt; &lt;bean class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\" id=\"multipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt; &lt;/bean&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--指定视图类型(JSP),可以省略--&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--视图前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;!--视图后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建Controller，打上@Controller和@RequestMapping注解 测试 @RequestMapping注解@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 属性 value表示映射路径 method表示触发该路径的方式,指定哪种方式就只能通过该方式触发，触发方法不对，报405异常。 params表示请求中必须含有的参数，如果没有该参数则报400异常。 注意:可以使用XXXMapping来替代RequestMapping(method=XXX) 1234567@RequestMapping(value = \"/index\", method = RequestMethod.GET, params = &#123;\"id\"&#125;)public String index(Long id) &#123; System.out.println(\"请求中的参数为: \" + id); // 视图解析器会作用在这个index前后自动拼接完整跳转路径 // 默认使用转发跳转 return \"index\";&#125; 可以接收基本类型，String类型和pojo类型，如果我们传入一个实体类，SpringMVC会自动帮我们封装成一个对象(参数列表必须要和实体类字段对应，不然为null)。 静态资源过滤问题 方式一 12&lt;!--配置静态资源处理--&gt;&lt;mvc:resources mapping=\"/asserts/**\" location=\"/asserts/\"/&gt; 方式二 1&lt;mvc:default-servlet-handler/&gt; 方式三(使用tomcat默认servlet来解决) web.xml中添加 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 表单提交乱码问题post方式提交表单会出现中文乱码问题，这时候我们想要配置springMVC自带的过滤器，可以在web.xml中配置。 12345678910111213141516171819&lt;!--配置字符集过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--配置过滤器使用UTF-8字符集--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--强制使用该字符集过滤器设置--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 处理日期类型参数在需要处理的实体类字段打上@DateTimeFormat注解，pattern属性传入要格式化的字符串。 123//参数绑定字符串和日期转换注解@DateTimeFormat(pattern = \"yyyy-MM-dd\")private LocalDate createDate; 常用注解RequestParam修饰绑定的参数 value 表示参数名称，用来对应方法的形参，默认和方法的形参同名 required 表示参数是否是必须参数，默认值为true，表示该参数必须要有 defaultValue 表示如果没有传入该参数，则使用默认值。 required=false，defaultValue = “XXX”连用 123456@GetMapping(\"/index4\")public String index4(@RequestParam(value = \"sname\", required = false, defaultValue = \"admin\") String name, int age) &#123; System.out.println(name); System.out.println(age); return\"success\";&#125; 运行结果 RequestBody修饰属性,用来获取请求体中的数据,即参数键值 required 表示是否是必须的,默认是true 注意:此注解只能通过post请求触发才能获取响应数据,不支持get请求 12345@PostMapping(\"/index5\")public String index5(@RequestBody(required = false) String body) &#123; System.out.println(body); return \"success\";&#125; PathVariable表示在URL中使用占位符来指定方法形参，它是后面我们使用Restful风格URL的基础 12345@GetMapping(\"/index6/&#123;id&#125;\")public String index6(@PathVariable(\"id\") Long id) &#123; System.out.println(id); return \"success\";&#125; 运行结果 RequestHeader获取请求头中指定key对应的value值 12345@GetMapping(\"/header\")public String header(@RequestHeader(\"User-Agent\") String header) &#123; System.out.println(header); return \"success\";&#125; 访问路径 localhost:8888/mvc/hello/header 运行结果 CookieValue表示获取Cookie中指定名称的值 12345@GetMapping(\"/cookie\")public String cookie(@CookieValue(\"JSESSIONID\") String cookieValue) &#123; System.out.println(cookieValue); return \"success\";&#125; ModelAttribute该注解是SpringMVC4.3版本后新加入的，它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行前执行，它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。当表单提交数据不是完整的实体类数据时，保证没有提交数据字段使用数据库原来对象的数据。 123456789101112@ModelAttributepublic void showModel(User user) &#123; System.out.println(\"HelloMvc.testModelAttribute\"); System.out.println(user); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");&#125;@GetMapping(\"/testma\")public String testModelAttribute(@ModelAttribute(\"user\") User user) &#123; System.out.println(user); return \"success\";&#125; model对象多个页面中数据共享使用Model对象。 它相当于request请求作用域,如果想要联动操作session,则可以在类上面使用@SessionAttributes注解,该注解可以把放入到model中的数据,同等的放入到session中 1234567891011//Session操作@SessionAttributes(&#123;\"message\"&#125;)public class HelloMvc &#123; @RequestMapping(\"/index10\") public ModelAndView index10()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"message\",\"Hello\"); modelAndView.setViewName(\"success\"); return modelAndView; &#125;&#125; jsp使用el表达式提取 12$&#123;requestScope.message&#125;$&#123;sessionScope.message&#125; 结果 如果要在控制器的方法中获取session,则可以使用model.get(“”)来获取如果要清空session,则可以在控制器方法参数中传入SessionStatus对象,然后调用该对象的setComplete()方法即可 restful风格url由于浏览器的form表单只支持GET与POST请求，而delete、put等方法不支持，Spring3.0添加了一个过滤器，可以将浏览器请求改为指定的请求方式，使得支持get、post、put、delete请求 使用方法： 1.在web.xml中配置该过滤器 123456789&lt;!--配置Rest请求URL方式转换过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.请求方式必须使用post请求 3.按照要求提供_method请求参数，该参数的取值就是我们的请求方式 12345678910&lt;form action=\"user/1\" method=\"post\"&gt; &lt;%--&lt;input type=\"text\" name=\"username\"/&gt; &lt;input type=\"password\" name=\"password\"/&gt;--%&gt; &lt;%--设置请求方式--%&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"&gt; &lt;input type=\"text\" name=\"id\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 4.对应Controller 123456789101112131415161718192021222324252627282930313233343536373839404142package com.gem.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;/** * 本类用来演示Restful风格URL * * 查询 /user/1 GET * 删除 /user/1 DELETE * 修改 /user/1 PUT * 添加 /user POST */@Controller@RequestMapping(\"/user\")public class RestController &#123; //localhost:8888/mvc/user/1 @GetMapping(\"/&#123;id&#125;\") public String select(@PathVariable(\"id\") Long id) &#123; System.out.println(\"执行查询操作的id:\" + id); return \"success\"; &#125; //localhost:8888/mvc/user @PostMapping public String add() &#123; System.out.println(\"执行添加操作\"); return \"success\"; &#125; //localhost:8888/mvc/user/1 @DeleteMapping(\"/&#123;id&#125;\") public String delete(@PathVariable(\"id\") Long id) &#123; System.out.println(\"执行删除操作的id:\" + id); return \"success\"; &#125;&#125; SpringMVC方法返回Json数据1.导入jackson jar包(Spring内置转换就是基于jackson) 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; 2.在控制器对应方法上添加注解@ResponseBody ​ @ResponseBody放在方法上,表示该方法返回纯数据,即不是视图名称 ​ @ResponseBody放在类上,则表示该类中所有的方法返回的都是纯数据 @ResponseBody + @Controller = @RestController 123456789@RestControllerpublic class JsonController &#123; @GetMapping(\"/json\") public User getData() &#123; User user = new User(1L, \"admin\", \"123456\"); return user; &#125;&#125; 访问http://localhost:8888/mvc/json 运行结果 SpringMVC文件上传 引入maven依赖(commons-fileupload+commons-io) 123456&lt;!--文件上传组件--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 提供form表单(post,multipart/form-data,file表单控件) 1234567891011121314&lt;%@ page contentType=\"text/html; charset=UTF-8\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMVC文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 图片：&lt;input type=\"file\" name=\"uploadFile\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Controller 1234567891011121314151617181920@Controllerpublic class UploadController &#123; @PostMapping(\"/upload\") public String upload(MultipartFile uploadFile) throws IOException &#123; //定义文件名 String fileName = \"\"; //1.获取原始文件名 String uploadFileName = uploadFile.getOriginalFilename(); //2.截取文件扩展名 String extendName = uploadFileName.substring(uploadFileName.lastIndexOf(\".\") + 1, uploadFileName.length()); //3.把文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\").toUpperCase(); fileName = uuid + \".\" + extendName; //4.判断路径是否存在 File file = new File(\"D:/a_dmeo/img/\" + fileName); //5.使用MulitpartFile接口中方法，把上传的文件写到指定位置 uploadFile.transferTo(file); return \"success\"; &#125; 配置文件上传解析器 1234&lt;!--配置文件上传解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt;&lt;/bean&gt; 全局异常处理 方式一(web.xml配置错误页面) 12345&lt;!--web全局异常处理--&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/pages/error.jsp&lt;/location&gt;&lt;/error-page&gt; 方式二 123456789101112/**全局异常处理增强类*/@ControllerAdvicepublic class ExceptionAdvice &#123; @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) // 响应 状态码500 // @ExceptionHandler 参数为 要处理器的 异常类(或子类) // 注解参数不声明指定异常类，则默认为方法列表中的异常参数类 @ExceptionHandler(ArithmeticException.class) public String showInfo(Exception e) &#123; System.out.println(e.getMessage()); return \"error\"; &#125;&#125; 拦截器SpringMVC的拦截器类似于Servlet开发中的过滤器Filter，拦截器只会拦截访问控制器的方法，不会拦截静态资源。 步骤 编写一个普通的实现类实现HandlerInterceptor接口 在mvc.xml中配置拦截器 可以配置要剔除的路径。 多个拦截器的执行顺序 两个拦截器同时拦截一个请求 SSM整合pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.gem&lt;/groupId&gt; &lt;artifactId&gt;ssmdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssmdemo Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.2.9.RELEASE&lt;/spring.version&gt; &lt;tomcat.version&gt;7.0.86&lt;/tomcat.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;version&gt;2.7.19&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssmdemo&lt;/finalName&gt; &lt;!-- 将mapper.xml一起打包 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/ssm&lt;/path&gt; &lt;port&gt;8888&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;staticContextPath&gt;/img&lt;/staticContextPath&gt; &lt;staticContextDocbase&gt;D:\\a_demo\\img&lt;/staticContextDocbase&gt; &lt;contextReloadable&gt;false&lt;/contextReloadable&gt; &lt;useTestClasspath&gt;true&lt;/useTestClasspath&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-util&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-coyote&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jasper&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jasper-el&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-el-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-tribes&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina-ha&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-juli&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-logging-juli&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-logging-log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!--添加配置跳过测试--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--添加配置跳过测试--&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; spring配置文件 spring.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--导入外部配置文件--&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;context:component-scan base-package=\"com.gem.service\"/&gt; &lt;!--配置AOP注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--开启声明式事务--&gt; &lt;tx:annotation-driven/&gt; &lt;!--配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;mysql_driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;mysql_url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;mysql_user&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;mysql_password&#125;\"/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactoryBean--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--绑定数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--配置mybatis--&gt; &lt;property name=\"configuration\"&gt; &lt;bean class=\"org.apache.ibatis.session.Configuration\"&gt; &lt;property name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;property name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;property name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.gem.entity\"/&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"defaultEnumTypeHandler\" value=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\"/&gt; &lt;/bean&gt; &lt;!--配置Mapper扫描器--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.gem.mapper\"/&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt;&lt;/beans&gt; mvc配置文件 mvc.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--mvc注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置mvc扫描包--&gt; &lt;context:component-scan base-package=\"com.gem.controller\"/&gt; &lt;!--配置默认跳转--&gt; &lt;mvc:view-controller path=\"/\" view-name=\"user/login\"/&gt; &lt;!--配置静态资源处理--&gt; &lt;mvc:resources mapping=\"/asserts/**\" location=\"/asserts/\"/&gt; &lt;!--配置文件上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"5242880\"/&gt; &lt;/bean&gt; &lt;!--配置拦截器--&gt; &lt;!--&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &amp;lt;!&amp;ndash;拦截路径&amp;ndash;&amp;gt; &lt;mvc:mapping path=\"/**\"/&gt; &amp;lt;!&amp;ndash;剔除拦截&amp;ndash;&amp;gt; &lt;mvc:exclude-mapping path=\"\"/&gt; &lt;bean class=\"com.gem.interceptor.AdminInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;--&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--指定视图类型(JSP),可以省略--&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--视图前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;!--视图后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; log4j配置文件log4j.properties 12345678# \\u5168\\u5C40\\u65E5\\u5FD7\\u914D\\u7F6Elog4j.rootLogger=WARN, stdout# \\u63A7\\u5236\\u53F0\\u8F93\\u51FAlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n# MyBatis \\u65E5\\u5FD7\\u914D\\u7F6Elog4j.logger.com.gem.mapper=DEBUG mybatis缓存配置文件ehcache.xml 1234567891011121314151617181920212223&lt;ehcache&gt; &lt;!--二级缓存存储路径--&gt; &lt;diskStore path=\"D:\\java\\ehcache\"/&gt; &lt;!-- maxElementsInMemory 内存中存储缓存对象的最大值 maxElementsOnDisk 磁盘中存储缓存对象的最大值 eternal 缓存对象是否是永久的 overflowToDisk 缓存对象是否允许被写到磁盘中 timeToIdleSeconds 缓存对象最大空闲时间,超时将被销毁 timeToLiveSeconds 缓存对象最长存活时间,超时将被销毁 --&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"true\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"600\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 数据库配置文件db.properties 1234mysql_driver=com.p6spy.engine.spy.P6SpyDrivermysql_url=jdbc:p6spy:mysql:///ssm?serverTimezone=GMT%2B8mysql_user=rootmysql_password=root p6spy配置文件spy.properties 1234mysql_driver=com.p6spy.engine.spy.P6SpyDrivermysql_url=jdbc:p6spy:mysql:///ssm?serverTimezone=GMT%2B8mysql_user=rootmysql_password=root web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" id=\"WebApp_ID\" version=\"4.0\"&gt; &lt;!--web全局异常处理--&gt; &lt;!--&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/pages/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/pages/error.jsp&lt;/location&gt; &lt;/error-page&gt;--&gt; &lt;!--配置session过期时间(分钟)--&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!--配置spring容器监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--指定spring配置文件路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置SpringMVC前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc配置文件(XML配置文件)--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--容器启动时就创建前端控制器对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置字符集过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--配置过滤器使用UTF-8字符集--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--强制使用该字符集过滤器设置--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置Rest请求URL方式转换过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Mybatis巩固","slug":"Mybatis巩固","date":"2020-09-22T10:35:24.000Z","updated":"2020-09-24T10:51:04.225Z","comments":true,"path":"2020/09/22/Mybatis巩固/","link":"","permalink":"http://yoursite.com/2020/09/22/Mybatis%E5%B7%A9%E5%9B%BA/","excerpt":"Mybatis再学习","text":"Mybatis再学习 Mybatis工具类(线程安全版本)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.gem.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.Reader;/** * @author zhang * @date 2020/9/22 9:34 */public class MybatisUtil &#123; private static SqlSessionFactory sqlSessionFactory = null; private static ThreadLocal&lt;SqlSession&gt; threadLocal = new ThreadLocal(); static &#123; try &#123; Reader reader = Resources.getResourceAsReader(\"sqlMapConfig.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 获取SqlSessionFactory * @return */ public static SqlSessionFactory getSqlSessionFactory()&#123; return sqlSessionFactory; &#125; /** * 新建一个Sqlsession对象，并且把他放入线程变量中 */ private static void newSqlSession()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(true); threadLocal.set(sqlSession); &#125; /** * 获取sqlSession * @return */ public static SqlSession getSqlSession()&#123; SqlSession sqlSession = threadLocal.get(); if (sqlSession ==null)&#123; newSqlSession(); sqlSession = threadLocal.get(); &#125; return sqlSession; &#125; /** * 关闭sqlSession对象，并且从线程变量中删除 */ public static void closeSqlSession()&#123; //获取线程变量中的SqlSession对象 SqlSession sqlSession = threadLocal.get(); //判断 if (sqlSession != null)&#123; sqlSession.close(); threadLocal.set(null); &#125; &#125;&#125; 配置别名给整个包下的所有类配置别名，默认首字符大小写都可以 1234&lt;!--别名--&gt;&lt;typeAliases&gt; &lt;package name=\"com.gem.entity\"/&gt;&lt;/typeAliases&gt; 配置类型处理器实体类存在枚举类型 12345678910111213/** * @author zhang * @date 2020/9/21 16:50 */@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private Integer id; private String name; private LocalDate birthday; private Gender gender;&#125; 1234567/** * @author zhang * @date 2020/9/21 16:50 */public enum Gender &#123; MALE,FEMALE;&#125; 数据库存的是枚举的下标0，1 ，直接查询会报错 这是因为mybatis提供了两种枚举处理器，默认情况下是EnumTypeHandler(字符串)，我们需要修改默认的枚举处理器，使用下标来实现 1234&lt;!--枚举下标--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\" javaType=\"com.gem.entity.Gender\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 引入外部配置文件我们可以使用properties标签来引入外部文件，将数据库的配置文件分离开来。 12&lt;!--引入外部配置文件 --&gt;&lt;properties resource=\"db.properties\"/&gt; 使用log4j实现日志功能导入log4j依赖 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 导入log4j配置文件 12345678# \\u5168\\u5C40\\u65E5\\u5FD7\\u914D\\u7F6Elog4j.rootLogger=WARN, stdout# \\u63A7\\u5236\\u53F0\\u8F93\\u51FAlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n# MyBatis \\u65E5\\u5FD7\\u914D\\u7F6Elog4j.logger.com.gem.mapper=DEBUG 使用p6spy探测sql语句上面我们可以看出使用Log4j输出的日志信息并没有完整的sql语句，想要查看完整的sql语句 ，我们需要使用第三方工具p6spy 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt;&lt;/dependency&gt; 替换mysql驱动 123&lt;!--使用p6spy探测SQL语句,替换原有驱动--&gt;&lt;!--&lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;--&gt;&lt;property name=\"driver\" value=\"com.p6spy.engine.spy.P6SpyDriver\"/&gt; 修改url 12&lt;!--并且修改url--&gt;&lt;property name=\"url\" value=\"jdbc:p6spy:mysql:///study?serverTimezone=GMT%2B8\"/&gt; P6Spy是一个可以用来在应用程序中拦截和修改数据操作语句的开源框架。 通过P6Spy我们可以对SQL语句进行拦截，相当于一个SQL语句的记录器，这样我们可以用它来作相关的分析，比如性能分析。 P6SPY提供了如下几个功能： 记录SQL语句的执行时间戳。 记录SQL语句类型 记录SQL填入参数的和没有填入参数的SQL语句 根据配置的时间控制SQL语句的执行时间，对超出时间的SQL语句输出到日志文件中 #{} 和 ${} 需求:通过姓名模糊查询 1List&lt;Student&gt; selectStudentsByName(String name); 两种实现方式 123&lt;select id=\"selectStudentsByName\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student where name like concat('%',#&#123;name&#125;,'%');&lt;/select&gt; 123&lt;select id=\"selectStudentsByName\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student where name like '%$(name)%';&lt;/select&gt; 虽然两种方法都可以实现，但是${}是不可取的 #{}是预编译处理，$ {}是字符串替换。使用 #{} 可以有效的防止SQL注入，提高系统安全性。 当然在在某些特殊的场合下只能使用${},不能用#{}。例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成ORDER BY “id”,这显然是一种错误的写法。 动态SQL通过mybatis提供的各种标签方法实现动态拼接sql。 if需求：更新用户信息 1int updateStudent(Student student); 正常写法 1234&lt;update id=\"updateStudent\"&gt; update mybatis_student set name = #&#123;name&#125;,birthday = #&#123;birthday&#125;,gender = #&#123;gender&#125; where id = #&#123;id&#125;&lt;/update&gt; 如果我们不想修改name属性并没有设置name属性，这时候就会把数据库更新为null，这就不符合要求了。这时候就需要使用if标签进行判断了 1234567891011121314151617&lt;!--更新--&gt; &lt;!--动态SQL语句--&gt; &lt;update id=\"updateStudent\"&gt; update mybatis_student set id=#&#123;id&#125; &lt;if test=\"name !=null and name!=''\"&gt; ,name=#&#123;name&#125; &lt;/if&gt; &lt;if test=\"birthday !=null and birthday!=''\"&gt; ,birthday=#&#123;birthday&#125; &lt;/if&gt; &lt;if test=\"gender !=null and gender!=''\"&gt; ,gender=#&#123;gender&#125; &lt;/if&gt; &lt;where&gt; id=#&#123;id&#125; &lt;/where&gt; &lt;/update&gt; where需求：按多个要求查找 1List&lt;Student&gt; selectStudentsByConditions(@Param(\"name\") String name, @Param(\"gender\")Gender gender); 这个正常实现 12345678910&lt;select id=\"selectStudentsByConditions\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student where &lt;if test=\"name != null and name != ''\"&gt; and name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender != null\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt;&lt;/select&gt; 传入两个参数没有问题，但是如果我们只传入最后一个参数就会解析有问题，多出一个and这时候就需要使用where标签 123456789101112&lt;select id=\"selectStudentsByConditions\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; and name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender != null\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where标签会自动帮我们去除第一个and，保证sql语句的正确解析。 foreach向sql传递数组或者list，mybatis使用foreach解析 需求：传入一个list，查找id在其中的student 1List&lt;Student&gt; selectStudentsByIds(@Param(\"ids\") List&lt;Long&gt; ids); 12345678910&lt;select id=\"selectStudentsByIds\" resultType=\"Student\"&gt; select * from mybatis_student &lt;where&gt; &lt;if test=\"ids != null and ids.size &gt; 0\"&gt; &lt;foreach collection=\"ids\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; collection 表示迭代的集合或者数组 open 表示迭代开始的内容 close 表示迭代结束的内容 item 表示迭代的每一个项 separator 表示迭代间隔符 SQL片段Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下： 原本sql 123456789101112&lt;select id=\"selectStudentsByConditions\" resultType=\"com.gem.entity.Student\"&gt; select * from mybatis_student &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; and name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender != null\"&gt; and gender = #&#123;gender&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 我们可以将where条件抽取成sql片段 1234567891011&lt;!--定义SQL片段--&gt; &lt;sql id=\"query_student_condition\"&gt; &lt;where&gt; &lt;if test=\"name!=null and name!=''\"&gt; and name=concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test=\"gender!=null\"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; 使用include引入 1234567&lt;select id=\"selectStudentsByConditions\" resultType=\"Student\"&gt; select * from mybatis_student &lt;!--引用SQL片段--&gt; &lt;!--注意:如果想要引用其他xml文件中的SQL片段,必须指定全名(命名空间+sqlid)--&gt; &lt;include refid=\"query_student_condition\"&gt;&lt;/include&gt; &lt;/select&gt; 关联查询一对一husband和wife实体 1234567@Datapublic class Husband &#123; private Integer id; private String name; private Wife wife;&#125; 12345@Datapublic class Wife &#123; private Integer id; private String name;&#125; 需求：级联查询，如果通过姓名查询丈夫，如果丈夫有妻子则一起查出 1Husband selectHusbandByName(String name); 实现 12345678910111213&lt;resultMap id=\"husbandAndWife\" type=\"Husband\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"name\" column=\"name\"&gt;&lt;/result&gt; &lt;!--关联绑定--&gt; &lt;association property=\"wife\" javaType=\"Wife\"&gt; &lt;id property=\"id\" column=\"wid\"/&gt; &lt;result property=\"name\" column=\"wname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectHusbandByName\" resultMap=\"husbandAndWife\"&gt; select h.id,h.name,w.id wid,w.name wname from mybatis_husband h left join mybatis_wife w on h.wife_id = w.id where h.name = #&#123;name&#125;&lt;/select&gt; 一对一使用association标签，property表示实体类字段，column表述数据库字段，使用javaType属性 一对多顾客和订单实体 1234567@Datapublic class Customer &#123; private Long id; private String name; // 体现一对多关系 private List&lt;Order&gt; orders;&#125; 123456@Datapublic class Order &#123; private Long id; private String orderno; private Double price;&#125; 需求：根据客户名查询客户,如果该客户有订单,则级联查询该客户的订单信息 1Customer selectCustomerAndOrders(String name); 实现 12345678910111213141516171819&lt;mapper namespace=\"com.gem.mapper.CustomerMapper\"&gt; &lt;resultMap id=\"customerAndOrdersMap\" type=\"Customer\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!--一对多关系绑定--&gt; &lt;collection property=\"orders\" ofType=\"Order\"&gt; &lt;id property=\"id\" column=\"oid\"/&gt; &lt;result property=\"orderno\" column=\"orderno\"/&gt; &lt;result property=\"price\" column=\"price\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectCustomerAndOrders\" resultMap=\"customerAndOrdersMap\"&gt; select c.id, c.name, o.id oid, o.orderno, o.price from hbm_customer c left join hbm_order o on o.customer_id = c.id where c.name = #&#123;name&#125; &lt;/select&gt; 一对多使用collection标签，使用ofType表示多端类型 多对多用户和角色实体 12345678@Datapublic class User &#123; private Long id; private String username; private String password; // 多对多 private List&lt;Role&gt; roles;&#125; 1234567@Datapublic class Role &#123; private Long id; private String roleName; // 多对多 private List&lt;User&gt; users;&#125; 需求：根据姓名查询用户信息,并且级联查询出用户的角色 1User selectUserAndRoles(String name); 实现 123456789101112131415161718&lt;mapper namespace=\"com.gem.mapper.UserMapper\"&gt; &lt;resultMap id=\"userAndRolesMap\" type=\"User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;collection property=\"roles\" ofType=\"Role\"&gt; &lt;id property=\"id\" column=\"rid\"/&gt; &lt;result property=\"roleName\" column=\"roleName\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectUserAndRoles\" resultMap=\"userAndRolesMap\"&gt; select u.id, u.username, u.password, r.id rid, r.roleName from mybatis_user u join mybatis_ur ur on ur.user_id = u.id join mybatis_role r on ur.role_id = r.id where u.username = #&#123;username&#125; &lt;/select&gt; 需要关联一张中间表，多对多和一对多一致。 获取自增id的值实体对应上面的客户表 1int insertCustomer(Customer customer); 123&lt;insert id=\"insertCustomer\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into hbm_customer(name) value (#&#123;name&#125;)&lt;/insert&gt; useGeneratedKeys属性设置为true，keyProperty设置为id 测试类 1234567@Testpublic void insertCustomer() &#123; Customer customer = new Customer(); customer.setName(\"张三\"); mapper.insertCustomer(customer); System.out.println(\"id为----&gt;\" + customer.getId());&#125; 输出结果 我们还可以通过&lt;selectKey&gt;实现 123456&lt;insert id=\"insertCustomer\" parameterType=\"Customer\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into hbm_customer(name) value (#&#123;name&#125;)&lt;/insert&gt; 延迟加载打开延迟加载开关 设置项 描述 允许值 默认值 lazyLoadingEnabled 全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。 true | false false aggressiveLazyLoading 当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。 true | false true 在mybatis核心配置文件中配置： 1234567&lt;!--延迟加载--&gt;&lt;settings&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--关闭积极加载--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 实现 需求：根据姓名查询丈夫信息,如果该丈夫有妻子,则延迟加载妻子的信息 Mapper接口中的两个方法 123Husband selectHusbandAndWifeLazy(String name);Wife selectWifeById(Long id); xml的实现 12345678910111213141516&lt;resultMap id=\"lazyHusbandAndWife\" type=\"Husband\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!-- association,collection中使用select标签调用其他查询来实现延迟加载 --&gt; &lt;association property=\"wife\" javaType=\"Wife\" select=\"selectWifeById\" column=\"id\"&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"selectHusbandAndWifeLazy\" resultMap=\"lazyHusbandAndWife\"&gt; select * from mybatis_husband where name = #&#123;name&#125;;&lt;/select&gt;&lt;select id=\"selectWifeById\" resultType=\"com.gem.entity.Wife\"&gt; select * from mybatis_wife where husband_id = #&#123;id&#125;&lt;/select&gt; 于正常级联查询不同，将原本一个sql分为两个单独sql，但是不同的是查询丈夫的时候，并没有返回丈夫的实体，而是返回了一个resultMap，association标签也并没有去绑定实体，而是去引用另一个sql，association本身提供懒加载功能 测试 我们只打印丈夫的name 1System.out.println(husband.getName()); sql语句并没有执行查询妻子的部分 尝试输出妻子的信息 1System.out.println(husband.getWife()); 两句sql都有执行 小结 ​ 当需要查询关联信息时再去数据库查询，默认不去关联查询，提高数据库性能。 ​ 只有使用resultMap支持延迟加载设置。 场合： ​ 当只有部分记录需要关联查询其它信息时，此时可按需延迟加载，需要关联查询时再向数据库发出sql，以提高数据库性能。 ​ 当全部需要关联查询信息时，此时不用延迟加载，直接将关联查询信息全部返回即可，可使用resultType或resultMap完成映射。 查询缓存Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。 Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存 一级缓存 测试 1234567891011121314/** * 测试一级缓存 默认开启 */@Testpublic void testFirstLevelCache()&#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); Student s1 = mapper.selectStudentById(1); System.out.println(s1); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); Student s2 = mapper.selectStudentById(1); System.out.println(s2); System.out.println(s1 == s2);&#125; 二级缓存 二级缓存区域是根据mapper的namespace划分的，相同namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解为二级缓存区域是根据mapper划分。 每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。 Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象 sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。 开启二级缓存 描述 允许值 默认值 cacheEnabled 对在此配置文件下的所有cache 进行全局性开/关设置。 true false true 在核心配置文件SqlMapConfig.xml中加入 1234&lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 要在你的Mapper映射文件中添加一行：&lt;cache /&gt; ，表示此mapper开启二级缓存 二级缓存需要查询结果映射的实体对象实现java.io.Serializable接口实现序列化和反序列化操作，注意如果存在父类、成员pojo都需要实现序列化接口。 测试就可以实现了 使用ehcache实现二级缓存 引入maven依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 导入ehcahe的xml配置文件 1234567891011121314151617181920212223242526272829303132&lt;ehcache&gt; &lt;!--二级缓存存储路径--&gt; &lt;diskStore path=\"D:\\a_demo\\ehcache\"/&gt; &lt;!-- maxElementsInMemory 内存中存储缓存对象的最大值 maxElementsOnDisk 磁盘中存储缓存对象的最大值 eternal 缓存对象是否是永久的 overflowToDisk 缓存对象是否允许被写到磁盘中 timeToIdleSeconds 缓存对象最大空闲时间,超时将被销毁 timeToLiveSeconds 缓存对象最长存活时间,超时将被销毁 --&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"true\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"600\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt; &lt;!--可以配置多套缓存配置--&gt; &lt;!-- &lt;cache name=\"myCache1\"&gt; maxElementsInMemory=\"1000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"600\"&gt; &lt;/cache&gt;--&gt;&lt;/ehcache&gt; 在需要开启二级缓存的mapper文件中添加 12&lt;!--使用ehcache缓存--&gt;&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt;&lt;/cache&gt; 测试 1234567891011121314151617@Testpublic void testSecondLevelCache()&#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); Student s1 = mapper.selectStudentById(1); System.out.println(s1); MybatisUtil.closeSqlSession(); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); sqlSession = MybatisUtil.getSqlSession(); mapper = sqlSession.getMapper(StudentMapper.class); Student s2 = mapper.selectStudentById(1); System.out.println(s2); System.out.println(s1 == s2); MybatisUtil.closeSqlSession();&#125; 在第一次查询完毕过后，关闭sqlsession再次查询 pagehelper分页插件 导入maven依赖 123456&lt;dependency&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 在mybatis核心配置文件中添加插件 12345678&lt;!--mybatis插件配置--&gt;&lt;plugins&gt; &lt;!--pagehelper分页插件--&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt; &lt;property name=\"helperDialect\" value=\"mysql\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; mapper定义查询全部的方法 123public interface ProvinceMapper &#123; List&lt;Province&gt; selectAllProvinces();&#125; 1234&lt;select id=\"selectAllProvinces\" resultType=\"Province\"&gt; select * from province&lt;/select&gt; service层 12345678910public PageInfo&lt;Province&gt; selectAllProvincesByPage(int pageNow,int pageSize)&#123; SqlSession sqlSession = MybatisUtil.getSqlSession(); ProvinceMapper mapper = sqlSession.getMapper(ProvinceMapper.class); //设置分页参数 PageHelper.startPage(pageNow,pageSize,true); List&lt;Province&gt; provinces = mapper.selectAllProvinces(); PageInfo&lt;Province&gt; pageInfo = new PageInfo&lt;&gt;(provinces); return pageInfo;&#125; 定义方法返回pageInfo对象，设置分页参数，pageInfo构造方法传入全部数据的集合即可 测试 123456789@Testpublic void selectAllProvincesByPage() &#123; PageInfo&lt;Province&gt; pageInfo = provinceService.selectAllProvincesByPage(1, 5); System.out.println(\"总页码\" + pageInfo.getPages()); System.out.println(\"每页显示条数\"+pageInfo.getPageSize()); pageInfo.getList().forEach(System.out::println); System.out.println(\"是否有下一页\" + pageInfo.isHasNextPage()); System.out.println(\"是否是第一页\" + pageInfo.isIsFirstPage());&#125; 逆向工程通用mapper 导入Maven依赖 123456&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.1.5&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 实体类配置 1234567891011@Data@Table(name = \"gem_person\")public class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; private String phone; private String qq; private String address;&#125; 需要在实体类上使用table注解指定数据库，使用id注解标明主键，自增字段需要加GeneratedValue，类似于Hibernate 编写mapper接口 123456/** * @author zhang * @date 2020/9/24 10:23 */public interface PersonMapper extends Mapper&lt;Person&gt; &#123;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test() throws IOException &#123; InputStream in = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = sqlSessionFactory.openSession(); MapperHelper mapperHelper = new MapperHelper(); mapperHelper.registerMapper(PersonMapper.class); mapperHelper.processConfiguration(sqlSession.getConfiguration()); PersonMapper mapper = sqlSession.getMapper(PersonMapper.class); //mapper.selectAll().forEach(System.out::println); //System.out.println(mapper.selectByPrimaryKey(1L)); Person person = new Person(); person.setName(\"张三\"); //System.out.println(mapper.select(person)); //System.out.println(mapper.selectOne(person)); //统计个数 //System.out.println(mapper.selectCount(null)); //条件组合工具 Example example = new Example(Person.class); //条件，一个create中可以组合无数个条件，但这些条件都是and关系 Example.Criteria criteria = example.createCriteria(); criteria.andLike(\"name\",\"%张%\"); //System.out.println(mapper.selectByExample(example)); Example.Criteria criteria1 = example.createCriteria(); criteria1.andEqualTo(\"name\",\"王五\"); example.or(criteria1); //System.out.println(mapper.selectByExample(example)); //排序 example.setOrderByClause(\"id desc\"); System.out.println(mapper.selectByExample(example));&#125; 在传统的Mybatis写法中，DAO接口需要与Mapper文件关联，即需要编写SQL来实现DAO接口中的方法。而在通用Mapper中，DAO只需要继承一个通用接口，即可拥有丰富的方法： 继承通用的Mapper，必须指定泛型","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Servlet生命周期","slug":"Servlet生命周期","date":"2020-09-08T13:43:25.000Z","updated":"2020-09-09T11:10:02.955Z","comments":true,"path":"2020/09/08/Servlet生命周期/","link":"","permalink":"http://yoursite.com/2020/09/08/Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Servlet生命周期总共由四个阶段：创建对象，初始化，服务，销毁","text":"Servlet生命周期总共由四个阶段：创建对象，初始化，服务，销毁 servlet类图 测试代码123456789101112131415161718192021222324252627282930313233343536package com.gem.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author zhang * @date 2020/9/8 14:44 */@WebServlet(\"/hello\")public class HelloServlet extends HttpServlet &#123; public HelloServlet()&#123; System.out.println(\"这是构造方法\"); &#125; @Override public void init() throws ServletException &#123; super.init(); System.out.println(\"初始化方法\"); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"这是服务方法\"); &#125; @Override public void destroy() &#123; System.out.println(\"这是销毁方法\"); super.destroy(); &#125;&#125; 多次请求hello 构造方法和初始化方法只加载一次，服务方法加载多次 创建对象(不存在线程安全问题)调用构造方法，默认情况下，当第一次访问到达服务器时，将调用构造方法创建对象，而且只创建一次(单例模式)，我们可用通过load-on-startup来调节Servlet的创建时机 1@WebServlet(urlPatterns = \"/hello\",loadOnStartup = 1) 整数表示服务器启动创建对象，值越小，约优先创建，0表示不在乎创建顺序，负数表示默认情况，表示当第一次到达创建 初始化(不存在线程安全问题)调用完构造方法之后，紧接着调用init初始化方法。 init方法一般用于初始化数据，执行费时费力的重量级代码， 我们可以配置初始化参数，通过ServletConfig对象来获取初始化参数 1@WebServlet(urlPatterns = \"/hello\",initParams = &#123;@WebInitParam(name = \"username\",value = \"root\"),@WebInitParam(name = \"password\",value = \"root\")&#125;) 获取初始化参数 1234ServletConfig config = getServletConfig();String username = config.getInitParameter(\"username\");String password = config.getInitParameter(\"password\");System.out.println(username + \"-------\" + password); 注意:Servlet顶级接口的init(ServletConfig config)方法时带参数的 。 我们可以发现HttpServlet的父类GenericServlet重写了带参数的init()方法，同时又提供了一个没有参数的init方法 在GenericServlet中,从servlet接口带来的init(ServletConfig config)对它进行重写时,如果忘了调用super.init(config)时,就会出现空指针异常,为了解决这样的 情况,GenericServlet中于是有了一个无参的init()方法,推荐大家重写init方法时, 重写无参的init()方法. 服务(非多线程安全)如果有必要的话，需要进行线程同步，保证线程并发安全。 HttpServlet对service方法进行了大量的细分，例如doGet、doPost、doPut、doDelete… 销毁(不存在线程安全问题)当卸载应用时，服务器会调用destory()方法，销毁当前Servlet的实例 注意： 如果当前Servlet没有提供服务，则可以被销毁。 如果当前Servlet实例正在提供服务，则调用destory()方法时，会等待一段时间，超时后销毁。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"NIO","slug":"NIO","date":"2020-08-09T08:24:52.000Z","updated":"2020-08-09T10:53:21.421Z","comments":true,"path":"2020/08/09/NIO/","link":"","permalink":"http://yoursite.com/2020/08/09/NIO/","excerpt":"Java NIO","text":"Java NIO NIO流在 JDK 1.4 中新加入了 NIO( New Input/ Output)类,引入了一种基于通道和缓冲区的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。 NIO是一种非线程阻塞的IO模型。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO时，可以同时做其他任务。同步的核心就是Selector，Selector代表了线程本事轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是线程和缓冲区，当IO事件就绪时，可以通过写道缓冲区，保证IO的成功，而无需线程阻塞时的等待。 IO和NIO的区别 IO NIO 面向流 面向缓冲 阻塞IO 基于Selector的非阻塞IO Buffer 缓冲区Java.nio.Buffer是特定的基本类型元素的线性有序序列。 缓冲区的类都有四个属性： 容量(Capacity) 上界(Limit) 位置(Position) 标记(Mark) 方法： flip()确定缓冲区数据的起始点和终止点 clear()缓冲区初始化，准备再次接收新数据到缓冲区 hasRemaining()判断postion到limit之间是否还有元素 缓冲区的分类有ByteBuffer(字节缓冲区)、CharBuffer(字符缓冲区)、ShortBuffer(短整型缓冲区)、IntBuffer(整形缓冲区)、LongBuffer(长整型缓冲区)、FloatBuffer(单精度缓冲区)、DoubleBuffer(双精度缓冲区)，就是没有布尔缓冲区。 他们都是抽象类所以不能实例化，然后他们都继承Buffer类，所以都有get()和set()方法，也都可以通过各自的静态方法allocation()创建缓冲区。 该方法是将现有的数组包装到缓冲区中来为缓冲区中的内容分配空间。 Channel 通道java.nio.Channel通过buffer(缓冲区)进行读写操作,read表示读取通道数据到缓冲区，writer表示把缓冲区数据写入到通道。 Channel需要通过节点流作为创建基础，例如FileInputStream和FileOutputStream的getChannel()方法.RandomAccessFile()也能创建文件通道，支持读写模式。通过IO创建通道是单向的，使用RandomAccessFile创建的通道支持双向。 通道可以异步读写，异步读写表示通道执行读写操作时，也能做别的事情， 解决线程阻塞。如果使用文件管道（FileChannel），建议用 RandomAccessFile 来创建管道，因为该类支持读写模式以及有大量处理文件的方法。 读取文件 写入文件","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java集合比较器规则","slug":"Java集合比较器规则","date":"2020-08-01T01:04:43.000Z","updated":"2020-08-01T01:28:58.094Z","comments":true,"path":"2020/08/01/Java集合比较器规则/","link":"","permalink":"http://yoursite.com/2020/08/01/Java%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83%E5%99%A8%E8%A7%84%E5%88%99/","excerpt":"Java集合框架自带一个排序的方法sort()，但是需要传入一个比较器对象","text":"Java集合框架自带一个排序的方法sort()，但是需要传入一个比较器对象 我们可以定义一个比较器的类，实现Comparator接口，重写compare方法 123456789101112//按照年龄比较class comparatorAge implements Comparator&lt;User&gt;&#123; @Override public int compare(User u1, User u2) &#123; if (u1.getAge() &gt; u2.getAge()) &#123; return -1; &#125;else if (u1.getAge() &lt; u2.getAge())&#123; return 1; &#125; return 0; &#125;&#125; 1users.sort(new comparatorAge()); sort传入比较方法就可以了，但这样写明显是不合理的。 我们可以改进成匿名内部类的形式 1234567891011users.sort(new Comparator&lt;User&gt;() &#123; @Override public int compare(User u1, User u2) &#123; if (u1.getAge() &gt; u2.getAge())&#123; return -1; &#125;else if (u1.getAge() &lt; u2.getAge())&#123; return 1; &#125; return 0; &#125;&#125;); 我们还可以用Java8的新特性lambda表达式优化一下 12345678910users.sort((u1,u2)-&gt;&#123; if (u1.getAge() &gt; u2.getAge())&#123; return -1; &#125;else if (u1.getAge() &lt; u2.getAge())&#123; return 1; &#125; return 0; //如果年龄相等我们可以根据名字来排序，字符串直接调用compareTo()方法就可以了。 //return u1.getName().compareTo(u2.getName());&#125;); 如果存在多个比较规则的话，这样代码写起来会比较困难，我们可以用之前的工厂模式进行简单封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package colltection;import java.util.Comparator;/** * @author zhang * @date 2020/7/31 11:11 */public class ComparatorFactort &#123; public final static int AGE_MIN_TO_MAX = 1; public final static int AGE_MAX_TO_MIN = 2; public final static int NAME_MAX_TO_MIN = 3; public final static int NAME_MIN_TO_MAX = 4; //public static Comparator&lt;User&gt; comparator = null; public static Comparator getComparator(int type)&#123; Comparator&lt;User&gt; comparator = null; if (type == AGE_MAX_TO_MIN)&#123; comparator = (p1,p2)-&gt;&#123; if (p1.getAge() &gt; p2.getAge())&#123; return -1; &#125;else if (p1.getAge() &lt; p2.getAge())&#123; return 1; &#125;return 0; &#125;; &#125; if (type == AGE_MIN_TO_MAX)&#123; comparator = (p1,p2)-&gt;&#123; if (p1.getAge() &gt; p2.getAge())&#123; return 1; &#125;else if (p1.getAge() &lt; p2.getAge())&#123; return -1; &#125; return 0; &#125;; &#125; if (type == NAME_MAX_TO_MIN)&#123; comparator = (p1,p2)-&gt; p1.getName().compareTo(p2.getName()); &#125; if (type == NAME_MIN_TO_MAX)&#123; comparator = (p1,p2)-&gt; p2.getName().compareTo(p1.getName()); &#125; return comparator; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"正则表达式的基本使用","slug":"正则表达式的基本使用","date":"2020-07-30T10:08:27.000Z","updated":"2020-07-30T10:56:25.532Z","comments":true,"path":"2020/07/30/正则表达式的基本使用/","link":"","permalink":"http://yoursite.com/2020/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。","text":"正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。 规则字符在java.util.regex Pattern类中 常见规则 表达式 规则 ^ 匹配行的开头 $ 匹配行的结尾 . 匹配换行符以外的任意字符 […] 匹配在方括号中的任意字符 * 匹配前面子表达式零次或多次 + 匹配前面子表达式一次或多次 ？ 匹配前面子表达式零次或一次 {n} 匹配前面子表达式n次 {n,} 匹配前面子表达式n次或n次以上 {n,m} 匹配前面子表达式至少n次，至多m次 a|b 匹配a或者b [^…] 匹配不在方括号的任意字符 Java中如何使用正则表达式在Java中调用正则表达式的类是Java.util.regex.Matcher和Java.util.regex.Pattern,java.util.regex是JDK1.4开始提供的，有多种写法来使用正则表达式。 当然String类也提供了matches()方法来匹配正则表达式 实现模糊查询","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Object类Clone()方法","slug":"Object类Clone-方法","date":"2020-07-28T10:21:24.000Z","updated":"2020-07-28T12:29:02.773Z","comments":true,"path":"2020/07/28/Object类Clone-方法/","link":"","permalink":"http://yoursite.com/2020/07/28/Object%E7%B1%BBClone-%E6%96%B9%E6%B3%95/","excerpt":"Object对象有个clone()方法，实现了对象中各个属性的复制.","text":"Object对象有个clone()方法，实现了对象中各个属性的复制. 实现步骤 实现Cloneable接口，这是一个标记接口，自身没有方法 覆盖clone()方法，可见性提升为public 这里说一下为什么要重写clone方法，并且提升为public类型 如果不重写，由于Object的clone()方法时protected修饰的，在不同包下别的类即使使用目标类的对象也不能访问目标类继承的clone()方法，只能在目标类内部使用，局限性大。 实现 测试 遇到点麻烦，我们之修改了克隆对象的地址，发现原来对象的地址也被改变了，这就涉及到了clone的浅拷贝和深拷贝。 浅拷贝和深拷贝clone()方法默认浅拷贝，即基本数据类型+常用类型(日期，字符串)，拷贝一份，修改克隆对象，不影响原对象。 但是对象类型的属性，拷贝的是引用(地址),它是两个对象共用的，所以修改克隆对象影响原对象。 如果想实现深拷贝，我们可以让属性对应的实体类同样实现Cloneable接口，重写clone()方法。 再次测试发现克隆对象的属性，原对象的属性不会发生变化，深克隆实现成功！","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java模板模式","slug":"Java模板模式","date":"2020-07-27T10:44:59.000Z","updated":"2020-07-27T11:20:39.998Z","comments":true,"path":"2020/07/27/Java模板模式/","link":"","permalink":"http://yoursite.com/2020/07/27/Java%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"在模板模式中，一个抽象类公开定义了执行它的方法的方式。它的子类可以按照重写方法实现，但调用将以抽象类中定义的方法进行。这种类型的设计模式属于行为型模式。","text":"在模板模式中，一个抽象类公开定义了执行它的方法的方式。它的子类可以按照重写方法实现，但调用将以抽象类中定义的方法进行。这种类型的设计模式属于行为型模式。 介绍意图：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法子类可以不改变算法的结构即可重定义该算法的某些步骤。 关键代码：在抽象类实现，其他步骤在子类实现 优点： 封装不变部分，扩展可变部分 提取公共代码便于维护 行为有父类控制子类实现 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 有多个子类共有方法，且逻辑相同 重要的、复杂的方法，可以考虑作为模板方法 注意事项：为了防止恶意操作，一般模板方法上都加上final关键字 实现我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。 步骤1创建一个抽象类，它的模板方法被设置为 final。 12345678910111213141516171819202122package class类.模板设计模式;/** * @author zhang * @date 2020/7/27 10:03 */public abstract class 春晚小品 &#123; abstract void 开场(); abstract void 叙事(); abstract void 煽情(); abstract void 谢幕(); /** * 顶级业务流程 */ public final void 演小品()&#123; 开场(); 叙事(); 煽情(); 谢幕(); &#125;&#125; 步骤2创建扩展了上述类的实体类 12345678910111213141516171819202122232425262728package class类.模板设计模式;/** * @author zhang * @date 2020/7/27 10:06 */public class 冯巩 extends 春晚小品&#123; @Override void 开场() &#123; System.out.println(\"朋友们想死你们了\"); &#125; @Override void 叙事() &#123; System.out.println(\"冯巩叙事\"); &#125; @Override void 煽情() &#123; System.out.println(\"冯巩煽情\"); &#125; @Override void 谢幕() &#123; System.out.println(\"冯巩谢幕\"); &#125;&#125; 测试12345678910111213package class类.模板设计模式;/** * @author zhang * @date 2020/7/27 10:07 */public class Test &#123; @org.junit.Test public void test() &#123; 春晚小品 冯巩 = new 冯巩(); 冯巩.演小品(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java抽象工厂模式","slug":"Java抽象工厂模式","date":"2020-07-27T09:58:55.000Z","updated":"2020-07-27T10:41:07.099Z","comments":true,"path":"2020/07/27/Java抽象工厂模式/","link":"","permalink":"http://yoursite.com/2020/07/27/Java%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。","text":"抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory*。接着定义工厂类 *ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo*，我们的演示类使用 *FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤1为形状创建一个接口 12345678910package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:14 * 形状接口 */public interface Shape &#123; void draw();&#125; 步骤2创建实现接口的实体类 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:15 */public class Rect implements Shape&#123; @Override public void draw() &#123; System.out.println(\"这是一个矩形！\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:16 */public class Square implements Shape&#123; @Override public void draw() &#123; System.out.println(\"这是一个正方形！\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:17 */public class Circle implements Shape&#123; @Override public void draw() &#123; System.out.println(\"这是一个圆形!\"); &#125;&#125; 步骤3为颜色创建一个接口 123456789package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:19 */public interface Color &#123; void fill();&#125; 步骤4创建实现接口的实体类 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:20 */public class Red implements Color&#123; @Override public void fill() &#123; System.out.println(\"红色!\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:21 */public class Blue implements Color&#123; @Override public void fill() &#123; System.out.println(\"蓝色！\"); &#125;&#125; 123456789101112package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:20 */public class Green implements Color&#123; @Override public void fill() &#123; System.out.println(\"绿色!\"); &#125;&#125; 步骤5为Color和Shape创建抽象工厂来获取工厂 12345678910package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:23 */public abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape);&#125; 步骤6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 123456789101112131415161718192021222324252627package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:25 */public class ShapeFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; return null; &#125; @Override Shape getShape(String shape) &#123; Shape shape1 = null; if (shape.equalsIgnoreCase(\"CIRCLE\"))&#123; shape1 = new Circle(); &#125;else if (shape.equalsIgnoreCase(\"RECT\"))&#123; shape1 = new Rect(); &#125;else if (shape.equalsIgnoreCase(\"SQUARE\"))&#123; shape1 = new Square(); &#125;else &#123; throw new RuntimeException(\"非法参数1!\"); &#125; return shape1; &#125;&#125; 123456789101112131415161718192021222324252627package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:29 */public class ColorFactory extends AbstractFactory &#123; @Override Color getColor(String color) &#123; Color color1 = null; if (color.equalsIgnoreCase(\"RED\"))&#123; color1 = new Red(); &#125;else if (color.equalsIgnoreCase(\"GREEN\"))&#123; color1 = new Green(); &#125;else if (color.equalsIgnoreCase(\"BLUE\"))&#123; color1 = new Blue(); &#125;else &#123; throw new RuntimeException(\"非法参数!\"); &#125; return color1; &#125; @Override Shape getShape(String shape) &#123; return null; &#125;&#125; 步骤7创建一个工厂创建器，通过传递形状或颜色信息来获取工厂 1234567891011121314151617181920package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:33 */public class FactoryProducer &#123; public static AbstractFactory getFactory(String type)&#123; AbstractFactory factory = null; if (type.equalsIgnoreCase(\"SHAPE\"))&#123; factory = new ShapeFactory(); &#125;else if (type.equalsIgnoreCase(\"COLOR\"))&#123; factory = new ColorFactory(); &#125;else &#123; throw new RuntimeException(\"非法参数!\"); &#125; return factory; &#125;&#125; 步骤8测试 12345678910111213141516171819202122package class类.抽象工厂模式;/** * @author zhang * @date 2020/7/27 18:36 */public class Test &#123; @org.junit.Test public void test()&#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(\"Shape\"); //获取形状为circle的对象 Shape circle = shapeFactory.getShape(\"CIRCLE\"); circle.draw(); AbstractFactory colorFactory = FactoryProducer.getFactory(\"Color\"); Color red = colorFactory.getColor(\"RED\"); red.fill(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java静态工厂模式","slug":"Java静态工厂","date":"2020-07-24T13:04:20.000Z","updated":"2020-07-25T01:27:45.612Z","comments":true,"path":"2020/07/24/Java静态工厂/","link":"","permalink":"http://yoursite.com/2020/07/24/Java%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82/","excerpt":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。","text":"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现步骤一创建一个Shape父类 123456789101112131415161718192021222324package class类;/** * @author zhang * @date 2020/7/23 14:30 *///形状类public class Shape &#123; /** * 得到周长 * @return */ public double getPerimeter()&#123; return 0.0; &#125; /** * 获得面积 * @return */ public double getArea()&#123; return 0.0; &#125;&#125; 步骤二创建圆形子类继承Shape类 123456789101112131415161718192021222324252627282930313233343536373839404142package class类;/** * @author zhang * @date 2020/7/24 14:56 *///圆形public class Circle extends Shape&#123; private double radius; public Circle() &#123; &#125; public Circle(double radius) &#123; this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double radius) &#123; this.radius = radius; &#125; @Override public String toString() &#123; return \"Circle&#123;\" + \"radius=\" + radius + '&#125;'; &#125; @Override public double getArea() &#123; return Math.pow(radius,2) * Math.PI; &#125; @Override public double getPerimeter() &#123; return 2 * Math.PI * radius; &#125;&#125; 创建矩形子类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package class类;/** * @author zhang * @date 2020/7/24 14:52 *///矩形public class Rect extends Shape&#123; private double length;//长 private double width;//宽 public Rect() &#123; &#125; public Rect(double length, double width) &#123; this.length = length; this.width = width; &#125; public double getLength() &#123; return length; &#125; public void setLength(double length) &#123; this.length = length; &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this.width = width; &#125; @Override public String toString() &#123; return \"Rect&#123;\" + \"length=\" + length + \", width=\" + width + '&#125;'; &#125; @Override public double getPerimeter() &#123; return 2 * (width + length); &#125; @Override public double getArea() &#123; return width * length; &#125;&#125; 创建正方形子类，间接继承Shape类 1234567891011121314151617package class类;/** * @author zhang * @date 2020/7/24 14:56 */public class Square extends Rect&#123; private int bianchang; public Square(int bianchang) &#123; super(bianchang,bianchang); &#125; public Square()&#123; &#125;&#125; 步骤三创建一个工厂，生成基于给定信息的实体类的对象。 12345678910111213141516171819202122232425262728293031package class类.foactorydemo;import class类.Circle;import class类.Rect;import class类.Shape;import class类.Square;/** * @author zhang * @date 2020/7/24 14:48 */public class ShapeFactory &#123; public static final int CIRCLE = 1; public static final int RECT = 2; public static final int SQUARE = 3; public static Shape getInstance(int i)&#123; Shape shape = null; if (i == CIRCLE)&#123; shape = new Circle(); &#125;else if (i == RECT)&#123; shape = new Rect(); &#125;else if (i == SQUARE)&#123; shape = new Square(); &#125;else &#123; throw new RuntimeException(\"参数有误！\"); &#125; return shape; &#125;&#125; 步骤四使用该工厂，通过传递类型信息来获取实体类的对象。 12345678910111213141516package class类.foactorydemo;import class类.Circle;import class类.Shape;/** * @author zhang * @date 2020/7/24 14:59 */public class TestFactory &#123; public static void main(String[] args) &#123; Shape shape = ShapeFactory.getInstance(ShapeFactory.CIRCLE); System.out.println(shape instanceof Circle); &#125;&#125; 返回结果为true 更优雅的实现，将该类的所以静态资源导入 12345678910111213141516package class类.foactorydemo;import class类.Circle;import class类.Shape;import static class类.foactorydemo.ShapeFactory.*;/** * @author zhang * @date 2020/7/24 14:59 */public class TestFactory &#123; public static void main(String[] args) &#123; Shape shape = getInstance(CIRCLE); System.out.println(shape instanceof Circle); &#125;&#125; 特点1 它是一个具体的类，非接口 抽象类。有一个重要的getInstance()方法，利用if或者 switch创建产品并返回。 2 getInstance()方法通常是静态的，所以也称之为静态工厂。 缺点1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法） 2 不同的产品需要不同额外参数的时候 不支持。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java单例模式","slug":"Java单例模式","date":"2020-07-23T09:43:05.000Z","updated":"2020-07-25T00:25:58.221Z","comments":true,"path":"2020/07/23/Java单例模式/","link":"","permalink":"http://yoursite.com/2020/07/23/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"单例模式","text":"单例模式 概述单例模式的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。属于设计模式三大类中的创建型模式。单例模式具有典型的三个特点： 只有一个实例。 自我实例化。 提供全局访问点。 其UML结构图非常简单，就只有一个类，如下图： 优缺点 优点：由于单例模式只生成一个实例，所以能够节省系统资源，减少性能开销，提高系统效率，同时也能够严格的控制客户对他的访问。 缺点：也正是因为系统只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责”的原则，同时也没有抽象类，这样扩展起来有一定的困难。 实现方式 饿汉式：线程安全，调用效率高，但是不能延迟加载。 123456789101112131415161718package class类;/** * @author zhang * @date 2020/7/23 18:02 */public class SingletonDemo1 &#123; //线程安全，类初始化立即加载这个对象 private static SingletonDemo1 singletonDemo1 = new SingletonDemo1(); //私有构造方法--&gt;外界不能通过new来创建对象 private SingletonDemo1()&#123;&#125; //提供一个公开的静态方法来创建当前类的对象 public static SingletonDemo1 getInstance()&#123; return singletonDemo1; &#125;&#125; 由于该模式类加载的时候对象就已创建了，所以加载类的速度比较慢，但是获取对象的速度比较块，且是线程安全 的。 懒汉式：线程不安全 123456789101112131415161718192021package class类;import javax.crypto.spec.PSource;/** * @author zhang * @date 2020/7/23 18:09 */public class SingletonDemo2 &#123; private static SingletonDemo2 singletonDemo2; //提供私有的构造方法 private SingletonDemo2()&#123;&#125; public static SingletonDemo2 getInstance()&#123; if (singletonDemo2 == null)&#123; singletonDemo2 = new SingletonDemo2(); &#125; return singletonDemo2; &#125;&#125; 由于该模式是在运行时加载对象的，所以加载类比较快，但是对象的获取速度相对较慢，且线程不安全。如果想要线程安全的话可以加上synchronized关键字，但是这样会付出惨重的效率代价 懒汉式(双重同步锁) 12345678910111213141516171819202122232425package class类;/** * @author zhang * @date 2020/7/23 18:19 */public class SingletonDemo3 &#123; //使用双重锁机制 private static volatile SingletonDemo3 singletonDemo3; //提供私有的构造方法 private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; if (singletonDemo3 == null)&#123; //线程同步加锁 synchronized (SingletonDemo3.class)&#123; if (singletonDemo3 == null)&#123; singletonDemo3 = new SingletonDemo3(); &#125; &#125; &#125; return singletonDemo3; &#125;&#125; 优点：线程安全，缺点：每次获取实例都要加锁，耗费资源，其实只要实例已经生成，以后获取就不需要再锁了 常见应用场景 网站计数器。 项目中用于读取配置文件的类。 数据库连接池。因为数据库连接池是一种数据库资源。 Spring中，每个Bean默认都是单例的，这样便于Spring容器进行管理。 Servlet中Application Windows中任务管理器，回收站。 等等。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java的堆区、栈区和方法区简单分析","slug":"Java的堆区、栈区和方法区简单分析","date":"2020-07-21T13:28:27.000Z","updated":"2020-07-21T13:40:19.472Z","comments":true,"path":"2020/07/21/Java的堆区、栈区和方法区简单分析/","link":"","permalink":"http://yoursite.com/2020/07/21/Java%E7%9A%84%E5%A0%86%E5%8C%BA%E3%80%81%E6%A0%88%E5%8C%BA%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/","excerpt":"Java的堆区、栈区和方法区简单分析","text":"Java的堆区、栈区和方法区简单分析 堆：**堆主要存放Java在运行过程中new出来的对象，凡是通过new生成的对象都存放在堆中，对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。类的非静态成员变量也放在堆区，其中基本数据类型是直接保存值，而复杂类型是保存指向对象的引用，非静态成员变量在类的实例化时开辟空间并且初始化。所以你要知道类的几个时机，加载-连接-初始化-实例化。** 栈：**栈主要存放在运行期间用到的一些局部变量（基本数据类型的变量）或者是指向其他对象的一些引用，因为方法执行时，被分配的内存就在栈中，所以当然存储的局部变量就在栈中咯。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；** 常量池：**常量池是方法区的一部分内存。常量池在编译期间就将一部分数据存放于该区域，包含基本数据类型如int、long等以final声明的常量值，和String字符串、特别注意的是对于方法运行期位于栈中的局部变量String常量的值可以通过 String.intern()方法将该值置入到常量池中。** 静态域：**位于方法区的一块内存。存放类中以static声明的静态成员变量。** 方法区：**是各个线程共享的内存区域，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。它有个名字叫做Non-Heap(非堆)，目的是与Java堆区分开。** 需要特别注意的是： 方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待 ！ 最后总结起来就是： 栈：**为即时调用的方法开辟空间，存储局部变量值(基本数据类型)，局部变量引用。注意：局部变量必须手动初始化。**堆：**存放引用类型的对象，即new出来的对象、数组值、类的非静态成员变量值(基本数据类型)、非静态成员变量引用。其中非静态成员变量在实例化时开辟空间初始化值。更具体点，个人感觉非静态成员变量是放在堆的对象中。**方法区：**存放class二进制文件。包含类信息、静态变量，常量池（String字符串和final修饰的常量值等），类的版本号等基本信息。因为是共享的区域，所以如果静态成员变量的值或者常量值(String类型的值能够非修改，具体请查看博客)被修改了直接就会反应到其它类的对象中。**","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java类加载机制","slug":"Java类加载机制","date":"2020-07-19T07:24:30.000Z","updated":"2020-07-19T07:34:40.860Z","comments":true,"path":"2020/07/19/Java类加载机制/","link":"","permalink":"http://yoursite.com/2020/07/19/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"Java类加载机制","text":"Java类加载机制 1、什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在java堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class 对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 2、 类的加载过程JVM 将类的加载过程分为三个大的步骤：加载(loading)，链接(link)，初始化(initialize)。其中链接又分为三个步骤：验证，准备，解析。 (1) 加载：查找并加载类的二进制数据加载是类加载过程中的第一个阶段，加载过程虚拟机需要完成以下三件事情： 1) 通过一个类的全限定名来获取其定义的二进制字节流； 2) 将这个字节流所代表的静态存储结构转为方法区的运行时数据结构； 3) 在Java 堆中生成一个代表这个类的java.lang.Class 对象，作为方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据 (2) 链接：① 验证：确保被加载类的正确性； 主要是为了安全考虑，为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 ② 准备：为类的静态变量分配内存，并将其初始化为默认值； 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 1)、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2)、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为：public static int value = 3； 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 ③ 解析：把类中的符号引用转换为直接引用； 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 (3) 初始化：为类的静态变量赋予正确的初始值为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ① 声明类变量是指定初始值； ② 使用静态代码块为类变量指定初始值； ③ JVM初始化步骤 1)、假如这个类还没有被加载和连接，则程序先加载并连接该类 2)、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3)、假如类中有初始化语句，则系统依次执行这些初始化语句 ④ 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： – 创建类的实例，也就是new的方式 – 访问某个类或接口的静态变量，或者对该静态变量赋值 – 调用类的静态方法 – 反射（如Class.forName(“com.shengsiyuan.Test”)） – 初始化某个类的子类，则其父类也会被初始化 – Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 (4) 结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 – 执行了System.exit()方法 – 程序正常执行结束 – 程序在执行过程中遇到了异常或错误而异常终止 – 由于操作系统出现错误而导致Java虚拟机进程终止 3、类加载器JVM 类加载器作用，将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。 类加载器是通过ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述： (1) Bootstrap ClassLoader 引导类加载器 负责加载Java核心库$JAVA_HOME中的jre/lib/rt.jar 里所有的class，由c++实现，不是ClassLoader子类。 (2) Extension ClassLoader 扩展类加载器 负责加载Java 平台中扩展功能的一些jar包，包括$JAVA_HOME中的jre/lib/ext/*.jar 或 -D java.ext.dirs指定目录下的jar包。 (3) App ClassLoader 负责加载classpath 中指定的jar包及目录中class (4) Custom ClassLoader 应用程序根据自身需要自定义的ClassLoader，如tomcat，jboss 都会根据j2ee规范自行实现ClassLoader，加载过程中会先检查是否已被加载，检查顺序是自底向上，从Custom ClassLoader 到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类在所有ClassLoader 只加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 4、JVM 三种预定义加载器JVM预定义有三种类加载器，当一个 JVM启动的时候，Java 默认开始使用如下三种类加载器： (1) 引导类加载器（Bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。它负责将/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 (2) 扩展类加载器（Extensions class loader）：该类加载器在此目录里面查找并加载 Java 类。扩展类加载器是由Sun的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量-Djava.ext.dirs指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 (3) 系统类加载器（System class loader）：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 5、类加载器 “双亲委派” 机制(1) 双亲委派机制介绍 在这里需要着重说明，JVM在加载类时默认采用的是双亲委派机制。所谓的双亲委派机制，就是某个特定的类加载器在接到类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和标准扩展类加载器为例作简单分析。 双亲委派机制是为了保证Java核心库的类型安全。**这种机制能保证不会出现用户自己能定义java.lang.Object类的情况，因为即使定义了，也加载不了。**","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java位运算符","slug":"Java位运算符","date":"2020-07-16T09:56:31.000Z","updated":"2020-07-16T11:07:49.491Z","comments":true,"path":"2020/07/16/Java位运算符/","link":"","permalink":"http://yoursite.com/2020/07/16/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"位运算符","text":"位运算符 位运算符关于位运算符无非也就 与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;) 位运算其实就是二进制的运算，加减乘除适用于十进制，而位运算就是二进制的运算,但是由于我们的运算都是基于十进制来说的，所以会有点绕，略微有点难懂，接下来言归正传 与运算符(&amp;)4&amp;7 我们需要把两个二进制转换成十进制 4：0000 0100 7：0000 0111 这里提到一点：1表示true，0表示false 而与运算的时候相同位之间其实就是两个Boolean的运算 ​ 全true(1),即为true(1) ​ 全false(0),即为false(0) ​ 一false(0)一true(1),还是false(0) 或运算符(|) 以 5|9 为例 5 ： 0000 0101 9 ： 0000 1001 在做与运算的时候 ​ 遇true(1)就是true(1), ​ 无true(1)就是false(0) 异或运算符(^) 以 7^15 为例 7： 0000 0111 15： 0000 1111 在异或的时候 ​ 只要相同都是false(0) ​ 只有不同才是true(1) 一个数连续异或同一个数两次,结果是它本身 取反运算符(~)例： ~15 同样的先变成二进制：15：0000 1111 这个其实挺简单的，就是把1变0，0变1 注意：二进制中，最高位是符号位 1表示负数，0表示正数 左移运算(&lt;&lt;) 左移就是把所有位向左移动几位 如： 12 &lt;&lt; 2 意思就是12向左移动两位 ​ 12的二进制是： 0000 1100 通过这个图我们可以看出来，所有的位全都向左移动两位，然后把右边空的两个位用0补上，最左边多出的两个位去掉，最后得到的结果就是00110000 结果就是48 我们用同样的办法算 12&lt;&lt;3 结果是 96 ​ 8&lt;&lt;4 结果是 128 由此我们得出一个快速的算法 M &lt;&lt; n 其实可以这么算 M &lt;&lt; n = M * 2n 右移运算符(&gt;&gt;)这个跟左移运算大体是一样的 例： 12 &gt;&gt; 2 我们可以看出来右移和左移其实是一样的，但是还是有点不同的，不同点在于对于正数和负数补位的时候补的不一样，负数补1，正数补0 如我们再做一个 –8 的 -8&gt;&gt;2 这里总结一下，关于负数或者正数来说，移位的时候是一样的，但是在补位的时候，如果最高位是0就补0，如果最高位是1就补1 由此我们得出一个快速的算法 M &gt;&gt; n 其实可以这么算 M &gt;&gt; n = M / 2^n 无符号右移(&gt;&gt;&gt;)无符号右移(&gt;&gt;&gt;)只对32位和64位有意义 在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"SpringMVC笔记(五)","slug":"SpringMVC笔记-五","date":"2020-07-03T12:24:42.000Z","updated":"2020-07-03T12:30:41.135Z","comments":true,"path":"2020/07/03/SpringMVC笔记-五/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%94/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 重点@ResponseBody阻止视图解析器的效果，会直接返回一个字符串 Json交互处理 什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 123&#123;\"name\": \"QinJiang\"&#125;&#123;\"age\": \"3\"&#125;&#123;\"sex\": \"男\"&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: 'Hello', b: 'World'&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse('&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;');//结果是 &#123;a: 'Hello', b: 'World'&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;);//结果是 '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;' Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617@Controllerpublic class UserController &#123; @RequestMapping(\"/json1\") @ResponseBody//阻止视图解析器的效果，会直接返回一个字符串 public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 1234567891011121314151617@RestControllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 1234567891011121314151617181920@RequestMapping(\"/json2\")public String json2() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;&#125; 运行结果 : 十分完美，没有任何问题！","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(四)","slug":"SpringMVC笔记-四","date":"2020-07-03T12:04:50.000Z","updated":"2020-07-03T12:15:01.862Z","comments":true,"path":"2020/07/03/SpringMVC笔记-四/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E5%9B%9B/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 结果跳转方式ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; ServletAPI通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 123456789101112131415161718192021@Controllerpublic class ResultGo &#123; @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.getWriter().println(\"Hello,Spring BY servlet API\"); &#125; @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(\"/index.jsp\"); &#125; @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); &#125;&#125; SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 1234567891011121314151617181920@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(\"/rsm/t1\") public String test1()&#123; //转发 return \"/index.jsp\"; &#125; @RequestMapping(\"/rsm/t2\") public String test2()&#123; //转发二 return \"forward:/index.jsp\"; &#125; @RequestMapping(\"/rsm/t3\") public String test3()&#123; //重定向 return \"redirect:/index.jsp\"; &#125;&#125; 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 12345678910111213141516@Controllerpublic class ResultSpringMVC2 &#123; @RequestMapping(\"/rsm2/t1\") public String test1()&#123; //转发 return \"test\"; &#125; @RequestMapping(\"/rsm2/t2\") public String test2()&#123; //重定向 return \"redirect:/index.jsp\"; //return \"redirect:hello.do\"; //hello.do为另一个请求/ &#125;&#125; 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=zhangsan 处理方法 : 12345@RequestMapping(\"/hello\")public String hello(String name)&#123; System.out.println(name); return \"hello\";&#125; 后台输出 : zhangsan 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=zhangsan 处理方法 : 123456//@RequestParam(\"username\") : username提交的域的名称 .@RequestMapping(\"/hello\")public String hello(@RequestParam(\"username\") String name)&#123; System.out.println(name); return \"hello\";&#125; 后台输出 : zhangsan 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 12345678public class User &#123; private int id; private String name; private int age; //构造 //get/set //tostring()&#125; 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 3、处理方法 : 12345@RequestMapping(&quot;&#x2F;user&quot;)public String user(User user)&#123; System.out.println(user); return &quot;hello&quot;;&#125; 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 第二种 : 通过ModelMap ModelMap 12345678@RequestMapping(\"/hello\")public String hello(@RequestParam(\"username\") String name, ModelMap model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\";&#125; 第三种 : 通过Model Model 12345678@RequestMapping(\"/ct2/hello\")public String hello(@RequestParam(\"username\") String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\";&#125; 对比就对于新手而言简单来说使用区别就是： 12345Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题测试步骤： 1、我们可以在首页编写一个提交的表单 1234&lt;form action=\"/e/t\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 2、后台编写对应的处理类 12345678@Controllerpublic class Encoding &#123; @RequestMapping(\"/e/t\") public String test(Model model,String name)&#123; model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 &#125;&#125; 3、输入中文测试，发现乱码 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(三)","slug":"SpringMVC笔记-三","date":"2020-07-03T11:50:18.000Z","updated":"2020-07-03T12:04:29.119Z","comments":true,"path":"2020/07/03/SpringMVC笔记-三/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 RestFul和控制器控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 123456789101112//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; 增加一个ControllerTest2类，使用注解实现； 1234567891011121314//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2&#123; //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; &#125;&#125; 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping@RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(\"/admin\")public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController 123@Controllerpublic class RestFulController &#123;&#125; 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 12345678910111213141516@Controllerpublic class RestFulController &#123; //映射访问路径 @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\") public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; &#125; &#125; 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 123456//映射访问路径,必须是POST请求@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.POST&#125;)public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\";&#125; 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； 123456//映射访问路径,必须是Get请求@RequestMapping(value = \"/hello\",method = &#123;RequestMethod.GET&#125;)public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\";&#125; 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(二)","slug":"SpringMVC笔记-二","date":"2020-07-03T08:06:21.000Z","updated":"2020-07-03T11:49:00.095Z","comments":true,"path":"2020/07/03/SpringMVC笔记-二/","link":"","permalink":"http://yoursite.com/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%8C/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 第一个SpringMVC程序配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， 注册DispatcherServlet 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 5、添加 处理映射器 1&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 6、添加 处理器适配器 1&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 7、添加 视图解析器 1234567&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 123456789101112131415161718import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author zhang * @date 2020/7/2 19:46 */public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"HelloSpringMVC!!!\"); //视图跳转 mv.setViewName(\"test\"); return mv; &#125;&#125; 9、将自己的类交给SpringIOC容器，注册bean 12&lt;!--Handler--&gt;&lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 注意点： / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 123456789101112131415161718192021222324252627282930314. 1. 在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 2. - 让IOC的注解生效 - 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ..... - MVC的注解驱动 - 配置视图解析器1. **6、创建Controller**2. 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范3. &#96;&#96;&#96;java import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; &#x2F;** * @author zhang * @date 2020&#x2F;7&#x2F;2 20:20 *&#x2F; @Controller @RequestMapping(&quot;&#x2F;hello&quot;) public class HelloController &#123; @RequestMapping(&quot;&#x2F;h1&quot;) public String hello(Model model)&#123; &#x2F;&#x2F;封装数据 model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVCAnnotation!&quot;); return &quot;hello&quot;; &#125; &#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"SpringMVC笔记(一)","slug":"SpringMVC笔记-一","date":"2020-06-23T11:12:16.000Z","updated":"2020-06-23T11:14:33.387Z","comments":true,"path":"2020/06/23/SpringMVC笔记-一/","link":"","permalink":"http://yoursite.com/2020/06/23/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"SpringMVC学习笔记","text":"SpringMVC学习笔记 SpringMVCssm:mybats+Spring+SpringMVC MVC三层架构 回顾MVC1.1什么是MVC? MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.2Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.3Model2时代Model2把一个项目分成三部分，包括视图、控制、模型 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 什么是SpringMVC2.1概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 2.2、中心控制器​ Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 2.3、SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"注解和反射","slug":"注解和反射","date":"2020-06-12T10:43:27.000Z","updated":"2020-06-12T10:45:22.336Z","comments":true,"path":"2020/06/12/注解和反射/","link":"","permalink":"http://yoursite.com/2020/06/12/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"注解和反射笔记","text":"注解和反射笔记 注解什么是注解java.Annotation包 Annotation是从JDK5.0开始引入的新技术 Annotation的作用： 不是程序本事，可以对程序做出解释（这一点和注释comment没什么区别） 可以被其他程序（比如编译器）读取 Annotation的格式 注解是以”@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=”unchecked”) Annotation在哪里使用? 可以附加在package，class，method，filed等上面， 相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解@Override：定义在java.lang.Override中，此注解只适合用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明@Deprecated：定义在java.lang.Deprecated中，此注解可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为他们很危险或者存在更好的选择 @SuppressWarnings:定义在java.lang.SuppressWarning中，用来抑制编译时的警告信息。 元注解 元注解的作用就是负责注解其他注解，java定义了4个标准的meta-annotation类型，他们被用来提供给对其他annotation类型做说明 @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 （SOURCE&lt;CLASS&lt;RUNTIME） @Document：说明该注解将被包含在javadoc中 Inherited：说明子类可以继承父类中的该注解 自定义注解使用@interface自定义注解时，自动继承了java.lang.anntation.Anntation接口 分析： @interface用来声明一个注解，格式：public @interface 注解名 {定义内容} 其中每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值的类型就是参数的类型（返回值只能是基本类型，Class，String，enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须有值，我们定义注解元素时，经常使用空字符串，0作为默认值 12345678910111213141516171819/** * @author zhang * @date 2020/6/10 19:05 */public class Demo3 &#123; @MyAnnotation2(name = \"张三\",schools = &#123;\"黑龙江八一农垦大学\"&#125;) public void test()&#123;&#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2&#123; //注解的参数 String name() default \"\"; int age() default 0; int id() default 1; String[] schools() default &#123;\"清华大学\"&#125;;&#125; 反射反射概述 Reflection(反射)时Java被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法 Class c = Class.forName(&quot;java.lang.String&quot;) 加载完类之后，在堆内存的方法去中就产生了一个class类型的对象(一个类只有一个class对象)，这个对象就包含了完整的类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射 Java反射的优缺点 优点：可以实现动态创建对象和编译，体现出很大的灵活性 缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么兵器它满足我们的需求。这类操作总是慢于直接执行相同的操作。 获得反射对象Class类 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定的某个结构(class/interface/enum/annotation/primitive type/void[])的有关信息。 Class本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，支队任何你想动态加载、运行的类，唯有先获得相应的Class对象 Class的常用方法 方法名 功能说明 static ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回一个Class对象的实例 getName() 返回此Class对象表示的实体(类、接口、数组类或void)的名称 Class getSuperClass 返回当前Class对象的父类Class对象 Class[] getinterfaces 返回当前Class对象的接口 ClassLoader getClassLoader 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Method getMethod(String name,Class.. T) 返回一个Method对象，此对象的参数类型为paramType Field[] getDeclaredFields() 返回Field对象的一个数组 Java内存分析 类的加载过程 当程序主动使用某个类时，如果该类未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时的数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将java类的二进制文件合并到JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用(常量名)替换为直接引用（地址）的过程 初始化： 执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法由编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器时构造类信息的，不是构造该类对象的构造器） 当初始化一个类的时候，如果发现器父类没有进行初始化，则需要先触发器父类的初始化 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。 什么时候会发生类的初始化？ 类的主动引用（一定会发生类的初始化） 当虚拟机启动时，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就已经存入调用类的常量池了） 类加载器类加载器的作用：将class文件的字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口， 类缓存：标准的javaSE类可以按照要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 获取运行时类的完整结构通过反射获取运行时类的完整结构 Field、Method、Constructor、Superclass、Interface、Annotation 实现类的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * @author zhang * @date 2020/6/12 15:59 */public class Demo6 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class&lt;?&gt; c1 = Class.forName(\"reflect.User\"); //获得类的名字 System.out.println(c1.getName()); System.out.println(c1.getSimpleName()); //获得类的属性 Field[] fields = c1.getFields();//只能获得public修饰的 for (Field field : fields) &#123; System.out.println(field); &#125; Field[] fields1 = c1.getDeclaredFields(); for (Field field : fields1) &#123; System.out.println(field); &#125; //获得类的方法 Method[] methods = c1.getMethods();//获得本类机器父类的全部public方法 for (Method method : methods) &#123; System.out.println(method); &#125; //获得构造器 Constructor&lt;?&gt;[] constructors = c1.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) &#123; System.out.println(constructor); &#125; //获得指定的构造器 Constructor&lt;?&gt; constructor = c1.getConstructor(String.class,int.class,int.class); System.out.println(constructor); &#125;&#125; 有了class对象，能做什么？创建类的对象：调用Class对象的newInstance()方法 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 调用指定的方法 通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod(String name,Class..parameterTypes)方法取得一个Method对象，并设置此方法操作是锁需要的参数类型 之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。 Object invoke(Object obj,Object...args) Object对应原方法的返回值，若方法无返回值，此时返回null 若原方法为静态方法，此时形参Object obj可为null 若原方法参数列表为空，则Object[] args为null 若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(四)","slug":"Spring学习笔记-四","date":"2020-06-10T03:45:44.000Z","updated":"2020-06-10T03:48:29.516Z","comments":true,"path":"2020/06/10/Spring学习笔记-四/","link":"","permalink":"http://yoursite.com/2020/06/10/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/","excerpt":"Spring学习笔记","text":"Spring学习笔记 整合MyBatis步骤： 导入相关jar包 junit mybatis mysql数据库 spring相关的 aop植入 mybatis-spring【new】 编写配置文件 测试 回忆MyBatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 Mybatis-SpringMyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。 要使用 MyBatis-Spring 模块，只需要在类路径下包含 mybatis-spring-2.0.5.jar 文件和相关依赖即可。如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt;&lt;/dependency&gt; 步骤： 编写数据源 sqlSessionfactory sqlSessionTemplate 需要接口加实现类 将自己写的实现类注入到spring中测试使用 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--DataSource:使用Spring的数据源替换Mybatis的配置--&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\"/&gt; &lt;!--绑定MyBatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/demo/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionTemplate就是我们使用的sqlSession--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--只能使用构造器注入 没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"teacherMapper\" class=\"com.demo.mapper.TeacherMapperImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt;&lt;/beans&gt; TeacherMapperImpl.java 123456789101112131415161718/** * @author zhang * @date 2020/6/7 18:42 */public class TeacherMapperImpl implements TeacherMapper&#123; //我们的所有操作都需要SqlSession来执行，现在使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;Teacher&gt; selectTeacher() &#123; TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); return mapper.selectTeacher(); &#125;&#125; SqlSessionDaoSupportSqlSessionDaoSupport 是一个抽象的支持类，用来为你提供 SqlSession。调用 getSqlSession() 方法你会得到一个 SqlSessionTemplate，之后可以用于执行 SQL 方法，就像下面这样: 12345public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; public User getUser(String userId) &#123; return getSqlSession().selectOne(\"org.mybatis.spring.sample.mapper.UserMapper.getUser\", userId); &#125;&#125; 在这个类里面，通常更倾向于使用 MapperFactoryBean，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。 SqlSessionDaoSupport 需要通过属性设置一个 sqlSessionFactory 或 SqlSessionTemplate。如果两个属性都被设置了，那么 SqlSessionFactory 将被忽略。 假设类 UserMapperImpl 是 SqlSessionDaoSupport 的子类，可以编写如下的 Spring 配置来执行设置： 123&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;&lt;&#x2F;bean&gt; 声明式事务回顾事务 把一组业务当成一个业务来做，要么都成功，要么都失败 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎 确保完整性和一致性 事务的ACID原则： 原子性 一致性 隔离性 持久性 Spring中事务管理 声明式事务：AOP 编程式事务：需要在代码中，进行事务的管理 一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。 一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。 事务配置好了以后，MyBatis-Spring 将会透明地管理事务。这样在你的 DAO 类中就不需要额外的代码了。 标准配置要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象： 1234567&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"dataSource\" /&gt;&lt;/bean&gt;@Beanpublic DataSourceTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dataSource());&#125; 传入的 DataSource 可以是任何能够与 Spring 兼容的 JDBC DataSource。包括连接池和通过 JNDI 查找获得的 DataSource。 注意：为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的是同一个数据源，否则事务管理器就无法工作了。 1234567891011121314151617181920&lt;!--配置声明式事务--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"datasource\"/&gt; &lt;/bean&gt; &lt;!--结合AOP实现事务的织入--&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\"/&gt; &lt;tx:method name=\"update\"/&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.demospring.Mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt; &lt;/aop:config&gt; 为什么需要事务？ 如果不配置事务，可能存在数据提交不一致情况 如果我们不在Spring中去配置声明事务，我们就需要在代码中手动配置事务 事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不能马虎","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(三)","slug":"Spring学习笔记-三","date":"2020-06-06T10:40:01.000Z","updated":"2020-06-06T10:41:47.579Z","comments":true,"path":"2020/06/06/Spring学习笔记-三/","link":"","permalink":"http://yoursite.com/2020/06/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"Spring学习笔记","text":"Spring学习笔记 AOP什么是AOP？AOP(Aspect Oriented Programming)意为：面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发的一个热点，也是Spring框架的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP在Spring中的作用提供声明式事务；允许用户自定义切面 连接点(Joinpoint)： 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点，也可以理解连接点为：目标类上哪些有可能被增强的方法。 切点（Pointcut）：可以理解为查询条件。一个target（目标类）的所有方法都是连接点，切点可以通过查询条件定位特定的连接点。 增强（Advice）：织入目标类连接点上的一段程序代码。既包含连接点上的执行逻辑（横切逻辑、增强逻辑）又包含定位连接点的方位信息，before、after、around等。增强默认织入目标类的所有方法中。 目标对象（Target）：增强逻辑织入的目标类。 代理（Proxy）：一个类被AOP植入增强后，被产生一个结果代理类。 织入(Weaving)：将通知（增强）应用到连接点上，生成代理的过程。 切面（Aspect)：由切点和增强组成。 引介（Introduction):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice： 前置增强 BeforeAdvice 代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。后置增强 AfterAdvice 代表后增强，表示目标方法在执行后实施增强环绕增强 MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强异常抛出增强 ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强引介增强 IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性 及AOP在不改变原来代码的情况下，去增加新的功能。 使用Spring实现AOP使用AOP，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt; 方式一：使用Spring的API接口 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 注册bean--&gt; &lt;bean id=\"userService\" class=\"com.demo.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.demo.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.demo.log.AfterLog\"/&gt; &lt;!-- 配置aop--&gt; &lt;aop:config&gt; &lt;!-- 切入点 expression:表达式，execution（要执行的位置）--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/&gt; &lt;!-- 执行软绕增强--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567891011121314/** * @author zhang * @date 2020/6/6 16:15 */public class Log implements MethodBeforeAdvice &#123; //method:要执行的目标对象的方法 //args:参数 //o:目标对象 public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(o.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); &#125;&#125; 测试方法 123456789101112/** * @author zhang * @date 2020/6/6 16:36 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //动态代理的式接口 UserService userService = (UserService) context.getBean(\"userService\"); userService.delete(); &#125;&#125; 方式二：自定义来实现AOP【主要是切面定义】 DiyPointCut.java 12345678910111213/** * @author zhang * @date 2020/6/6 17:48 */public class DiyPointCut &#123; public void before()&#123; System.out.println(\"==========方法执行前\"); &#125; public void after()&#123; System.out.println(\"==========方法执行后\"); &#125;&#125; xml 12345678910&lt;bean id=\"diy\" class=\"com.demo.diy.DiyPointCut\"/&gt; &lt;aop:config&gt; &lt;!-- 自定义切面 ref引用类--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方式三：使用注解实现 12345678910111213141516/** * @author zhang * @date 2020/6/6 18:04 */@Aspect//标注这个类是一个切面public class AnnotationPointCut &#123; @Before(\"execution(* com.demo.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"----------方法执行前\"); &#125; @After(\"execution(* com.demo.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"---------方法执行后\"); &#125;&#125; 需要开启注解支持 12&lt;!--开启注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt;","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(二)","slug":"Spring学习笔记-二","date":"2020-06-03T12:01:23.000Z","updated":"2020-06-06T10:39:17.475Z","comments":true,"path":"2020/06/03/Spring学习笔记-二/","link":"","permalink":"http://yoursite.com/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/","excerpt":"Spring学习笔记","text":"Spring学习笔记 Spring配置别名12&lt;!-- 别名，如果添加了别名，我们也可以使用别名获取到对象--&gt;&lt;alias name=\"user\" alias=\"USER\"/&gt; Bean的配置12345678&lt;!-- id：Bean的唯一标识符，也就是相当于我们的对象名 class:对象对应的全限定名 name：也是别名 --&gt; &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt; &lt;property name=\"name\" value=\"Java\"/&gt; &lt;/bean&gt; import这个import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。 DI依赖注入构造器注入Set方式注入【重点】实体类属性 12345678private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private Properties info; private String wife; xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=\"student\" class=\"com.demospring.pojo.Student\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;property name=\"address\" ref=\"address\"&gt;&lt;/property&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;打篮球&lt;/value&gt; &lt;value&gt;敲代码&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"身份证\" value=\"123456789\"/&gt; &lt;entry key=\"银行卡\" value=\"987654321\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;CS&lt;/value&gt; &lt;value&gt;PUBG&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;2019052531&lt;/prop&gt; &lt;prop key=\"性别\"&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 拓展方式注入P命名空间注入需要添加xml约束 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 12&lt;!-- p命名空间注入，可以直接注入属性的值:property--&gt;&lt;bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\"/&gt; C命名空间注入需要添加xml约束 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 12&lt;!-- c命名空间注入，通过构造器注入：construct-args--&gt;&lt;bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\"/&gt; Bean的作用域 Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 1.单例模式(Spring默认机制) 1&lt;bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\" scope=\"singleton\"/&gt; 2.原型模式：每次从容器get的时候，都会产生一个新对象！ 1&lt;bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\" scope=\"prototype\"/&gt; 3.其余的request，session，application这些只能在web开发中用到 Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显式的配置 在java中显式的配置 隐式的自动装配bean【重要】 ByName自动装配123&lt;bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;/bean&gt; autowire=&quot;byName&quot; ByName：会自动在容器上下文中查找，和自己对象set方法后面的值对象的beanid！ Bytype自动装配123&lt;bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"张三\"/&gt;&lt;/bean&gt; autowire=&quot;byType&quot; ByType：会自动在容器上下文中查找，和自己对象属性类型相同的bean 小结： byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！ bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一样 使用注解实现自动装配1.导入约束：context约束 2.配置注解的支持：context:annotation-config/ 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！也可以在set方法上使用 12345@Autowired private Dog dog; @Autowired private Cat cat; private String name; 使用Autowird我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC容器存在 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value=”xxxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！ 使用注解开发在Spring4之后，需要使用注解开发，必须要保证aop的包导入了 使用注解需要导入context约束，增加注解的支持 12&lt;!-- 指定要扫描的包，这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=\"com.demospring\"/&gt; @Component:组件，放在类上，说明这个类被Spring管理了，就是Bean！ 注入属性 123456789101112/** * @author zhang * @date 2020/6/4 16:00 *///等价于 &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt;&lt;/bean&gt;@Componentpublic class User &#123; //相当于&lt;property name=\"name\" value=\"张三\"/&gt; @Value(\"张三\") public String name ;&#125; 衍生的注解 @Component有几个衍生注解，我们在web开发中，会按照MVC三成架构分层 dao【@Repository】 service【@Service】 controller【@Controller】 这四个注解的功能都是一样的，都是代表将某个类注册到Spring容器中装配 作用域 1@Scope(\"prototype\") 使用Java的方式配置Spring12345678910111213141516171819202122package com.demospring.config;import com.demospring.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author zhang * @date 2020/6/4 17:42 *///这个也会被Spring容器托管，注册到容器中，因为它本来就是一个@Component//@Configuration代表这是一个配置类，就和我们之前看的bean.xml@Configurationpublic class MyConfig &#123; //注册一个Bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bena标签的class属性 @Bean public User getUser()&#123; return new User();//就是返回要注入到bean的对象！ &#125;&#125;","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring学习笔记(一)","slug":"Spring学习笔记-一","date":"2020-06-03T11:57:29.000Z","updated":"2020-06-03T12:00:30.325Z","comments":true,"path":"2020/06/03/Spring学习笔记-一/","link":"","permalink":"http://yoursite.com/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"Spring学习笔记","text":"Spring学习笔记 简介 简介：Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从 Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合现有的技术框架！ SSM：SpringMvc + Spring + Mybatis！ 123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 优点： Spring是一个开源的免费的框架(容器)！ Spring一个轻量级的、非入侵式的框架 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理,对框架整合的支持 总结：Spring就是一个轻量级的控制反转(IOC)和切面编程的框架！ 组成 核心容器（Spring Core） 核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。 应用上下文（Spring Context） Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring面向切面编程（Spring AOP） 通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 JDBC和DAO模块（Spring DAO） JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。 对象实体映射（Spring ORM） Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。 Web模块（Spring Web） Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 MVC模块（Spring Web MVC） MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。 IOC理论控制反转Ioc(Inversion of Control)，是一种设计思想，DI(依赖注入)式实现IoC的一种方法，也有人认为Di只是Ioc的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象创建转移给第三方，个人认为所谓的控制反转就是：获得依赖对象的方式反转了 采用XML配置Bean的时候，Bean的定义信息是和实现分离的，而采用注入的方式可以把二者和为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到零配置的目的 控制反转是一种通过描述(XML或注解)并通过第三方去生产或者获取特定对象的方式。在Spring中实现控制反转的是Ioc容器，其实现方法是依赖注入(Dependency Injection,DI) 由容器动态地将某种依赖关系注入到组件之间。控制反转也称为”依赖注入“（Dependency Injection DI) IoC/DI示例：依赖注入是Java编程思想中”面向接口编程“的体现，因此在设计程序是，对于程序所依赖的组件往往以忌口的形式出现，而不直接使用具体的实现类 第一个Spring程序 besns.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.demospring.pojo.User\"&gt; &lt;property name=\"name\" value=\"Java\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码 123456789101112131415import com.demospring.pojo.User;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author zhang * @date 2020/6/2 17:05 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); user.show(); &#125;&#125; 实体类 12345678910111213141516171819202122232425262728package com.demospring.pojo;/** * @author zhang * @date 2020/6/2 17:03 */public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"name---&gt;\"+name); &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 总结：在配置文件加载的时候，容器中的管理对象就已经初始化了！","categories":[],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2020-05-31T08:08:51.000Z","updated":"2020-05-31T08:20:14.776Z","comments":true,"path":"2020/05/31/Java多线程/","link":"","permalink":"http://yoursite.com/2020/05/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"Java多线程笔记","text":"Java多线程笔记 多线程 说起进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念 而进程则是执行程序的一次执行过程，它是一个动态概念。是系统资源分配的单位 通常一个进程可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。 本章核心概念 线程就是独立的执行路径 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程mian，gc线程 main()称为主线程，为系统入口，用于执行整个程序 在一个线程中，如果开辟了多个线程，线程的运行有调度器安排调度，调度器是与操作系统机密相关的，先后顺序是不能认为的干预的 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制 线程会带来额外的开销，如cpu调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 线程创建三种创建方式： 继承Thread类(重点) 实现Runnable接口(重点) 实现Callable(了解) Thread类1.自定义线程类继承Thread类 2.重写run()方法，编写线程执行体 3.创建线程对象，调用start()方法启动线程 1234567891011121314151617181920212223package thread;public class TestThread extends Thread&#123; @Override public void run() &#123; super.run(); for (int i=0;i&lt;20;i++)&#123; System.out.println(\"run方法\"+i); &#125; &#125; public static void main(String[] args) &#123; //main线程，主线程 //创建一个线程对象，调用start方法开启线程 TestThread testThread = new TestThread(); testThread.start(); for (int i = 0; i &lt; 200; i++) &#123; System.out.println(\"主线程\"+i); &#125; &#125;&#125; 多线程实现网图下载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package thread;import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;//联系Thread，实现多线程同步下载public class TestThread2 extends Thread&#123; private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name)&#123; this.url = url; this.name = name; &#125; //下载图片的线程执行体 @Override public void run() &#123; WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载了文件名为：\"+name); &#125; public static void main(String[] args) &#123; TestThread2 testThread1 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%911.png\",\"D:/a_test/1.jpg\"); TestThread2 testThread2 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%912.png\",\"D:/a_test/2.jpg\"); TestThread2 testThread3 = new TestThread2(\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%913.png\",\"D:/a_test/3.jpg\"); testThread1.start(); testThread2.start(); testThread3.start(); &#125;&#125;//下载器class WebDownloader&#123; //下载方法 public void downloader(String url,String name)&#123; try &#123; FileUtils.copyURLToFile(new URL(url),new File(name)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Runnable接口1.实现MyRunnable类实现Runnable接口 2.实现run()方法，编写线程执行体 3.创建线程对象，调用start()方法启动线程 123456789101112131415161718192021222324package thread;public class TestThread3 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"run方法\"+i); &#125; &#125; public static void main(String[] args) &#123; //创建runnable接口的实现类 TestThread3 testThread3 = new TestThread3(); //创建线程对象，通过线程对象开启线程，代理 Thread thread = new Thread(testThread3); thread.start(); //new Thread(new TestThread3()).start(); for (int i = 0; i &lt; 200; i++) &#123; System.out.println(\"主线程\"+i); &#125; &#125;&#125; 小结 继承Thread类 子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 实现Runnable接口 实现Runnable具有多线程能力 线程启动：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 初识并发问题123456789101112131415161718192021222324252627282930313233package thread;/** * 多个线程操作一个对象 * 买火车票 */public class TestThread4 implements Runnable&#123; //票数 private int ticketNums = 10; @Override public void run() &#123; while (true)&#123; if (ticketNums&lt;=0)&#123; break; &#125; //模拟延迟 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"----&gt;拿到了第\"+ticketNums--+\"张票\"); &#125; &#125; public static void main(String[] args) &#123; TestThread4 t4 = new TestThread4(); new Thread(t4,\"小明\").start(); new Thread(t4,\"老师\").start(); new Thread(t4,\"黄牛\").start(); &#125;&#125; 发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 线程状态 Thread.State NEW ​ 尚未启动的线程处于此状态 RUNNABLE ​ 在Java虚拟机中执行的线程处于此状态 BLOCKED ​ 阻塞等待监视器锁定的线程处于此状态 WAITTING ​ 正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WATTING ​ 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED ​ 已退出的线程处于此状态 线程优先级Java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级来决定应该调度哪个线程先执行 线程的优先级用数字表示,范围1~10 Thread.MIN_PRIORITY = 1; Thread.MAX_PRIORITY = 10; Thread.NORM_PRIORITY = 5; 使用以下方式改变和获取优先级 getPriority() setPriority(int xxx) 注意：优先级低只是意味这获得调度的概率低，并不是优先级低就不会被调用了，这都看cpu的调度 线程方法 方法 说明 setPriority(int newPriority) 更改线程的优先级 static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠 void join() 等待该线程终止 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 void interrupt() 中断线程，别用这个方式 boolean isAlive() 测试线程是否处于活动状态 停止线程 不推荐使用JDK提供的stop()、destory()方法。【已废弃】 推荐线程自己停下来 建议用一个标志位进行终止变量，放flag = false，则终止线程运行 12345678910111213141516171819202122232425262728293031323334353637383940package thread;/** * 测试stop * 建议线程正常停止--&gt;利用次数，不建议死循环 * 建议使用标志位--&gt;设置一个标志位 * 不用使用stop或者destory等过时或者JDK不建议使用的方法 */public class TestThread5 implements Runnable&#123; //设置一个标志位 private boolean flag = true; @Override public void run() &#123; int i = 0; while (flag)&#123; System.out.println(\"run....Thread\"+i++); &#125; &#125; //设置一个公开的方法停止线程，转换标志位 public void stop()&#123; this.flag = false; &#125; public static void main(String[] args) &#123; TestThread5 thread5 = new TestThread5(); new Thread(thread5).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"main\"+i); if (i == 900)&#123; //调用stop方法切换标志位，让线程停止 thread5.stop(); System.out.println(\"线程该停止了\"); &#125; &#125; &#125;&#125; 线程休眠 sleep(时间)指定当前路线阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 线程礼让 线程礼让，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功！看CPU心情 1234567891011121314151617181920package thread;public class TestYield &#123; public static void main(String[] args) &#123; MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"线程开始执行\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行\"); &#125;&#125; join Join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞 可以想象成插队 守护线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕，如后台记录操作日志，监控内存，垃圾回收等等。 线程同步(重点)并发：多个线程操作同一个资源 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程池使用完毕，下一个线程再使用 由于同一进程的多个线程共享同一块存储空间，在带了方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入了锁机制synchronized,当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可，存在一下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题 由于我们可以通private关键字来保证数据对象只能被方法访问，所有我们只需要对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块 同步方法：public synchronized void method(int args){} synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。 缺陷：若将一个大的方法申明为synchronized将会影响效率 同步块synchronized(obj){ } Obj称为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。 同步监视器的执行过程 1.第一个线程访问，锁定同步监视器，执行其中代码 2.第二个线程访问，发现同步监视器被锁定，无法访问 3.第一个线程访问完毕，解锁同步监视器 4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问 死锁多个线程各自占有一些资源，并且相互等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情况。某一个同步块同时拥有“两个以上对象的锁”时就可能会发生“死锁问题”。 死锁避免的方法产生死锁的四个必要条件 1.互斥条件：一个资源每次只能被一个进程使用 2.请求与保持条件：一个进程因请求资源时而被阻塞，对己获得的资源保持不放 3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 4.循环等待条件：若干进程之间实现了一种头尾相接的循环等待资源关系 上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或者多个条件就可以避免死锁发生 Lock(锁) 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口时控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比价常用的是ReentrantLock，可以显式加锁，释放锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package thread;import java.util.concurrent.locks.ReentrantLock;/** * @author zhang * @date 2020/5/31 10:24 */public class TestLock &#123; public static void main(String[] args) &#123; BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket,\"小明\").start(); new Thread(buyTicket,\"小红\").start(); new Thread(buyTicket,\"黄牛\").start(); &#125;&#125;class BuyTicket implements Runnable&#123; int ticketNum = 10; //定义Lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try &#123; lock.lock();//加锁 if (ticketNum&gt;0)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"买到了\"+ticketNum--); &#125;else &#123; break; &#125; &#125;finally &#123; //解锁 lock.unlock(); &#125; &#125; &#125;&#125; synchronized与Lock的对比 Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了作用域会自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类) 优先使用顺序 Lock&gt;同步代码块(已经进入了方法体，分配相应资源)&gt;同步方法(在方法体之外) 线程通信Java提供了几个方法解决线程之间的通信问题 方法名 作用 wait() 表示线程一直等待，知道线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个正处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常lllegalMonitorStateException 线程池背景：经常创建和销毁使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁的创建和销毁、实现重复利用。类似生活中的交通工具 好处： 提高相应速度(减少了创建新线程的时间) 降低资源消耗(重复利用线程池中的线程，不需要每次创建) 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后终止 使用线程池JDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExector void execute(Runnnable command):执行任务/命令，没有返回值，一般用于执行Runnable Future submit(Callable task):执行任务，有返回值，一般用于执行Callable void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 123456789101112131415161718192021222324252627282930313233package thread;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author zhang * @date 2020/5/31 14:58 * 测试线程池 */public class TestPool &#123; public static void main(String[] args) &#123; //创建线程池 ExecutorService service = Executors.newFixedThreadPool(10); //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //关闭连接 service.shutdown(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"mybatis框架(四)","slug":"mybatis框架-四","date":"2020-05-27T07:10:29.000Z","updated":"2020-05-31T08:32:57.008Z","comments":true,"path":"2020/05/27/mybatis框架-四/","link":"","permalink":"http://yoursite.com/2020/05/27/mybatis%E6%A1%86%E6%9E%B6-%E5%9B%9B/","excerpt":"mybatis笔记(四)","text":"mybatis笔记(四) 动态SQL什么是动态SQL：根据不同的条件生成不同的SQL 所谓的动态SQl，本质还是SQL语句，只是我么可以在SQl层面，去执行一个逻辑代码 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach ifBlogMapper.xml代码 123456789&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog where 1 = 1 &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/select&gt; choose、when、otherwise有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。 12345678910111213141516&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title!=null\"&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author!=null\"&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 只会选择其中一个条件实现，前面的实现后面的就不看了 trim、where、setwhere 如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样： 12SELECT * FROM BLOGWHERE 这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样: 123SELECT * FROM BLOGWHEREAND title like ‘someTitle’ 这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。 MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动： where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 set 用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。 set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。 123456789101112&lt;update id=\"updateBlogSet\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"titlt != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; SQL片段有的时候，我们可能将一些功能的部分抽取出来，方便复用 1.使用sql标签抽取公共部分 2.在需要使用的的地方使用include标签引用即可 注意事项： 1.最好基于单表来定义SQL！ 2.不要存在where foreachforeach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ 提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 123456789&lt;select id=\"queryForeach\" parameterType=\"map\" resultType=\"Blog\"&gt; select * from blog &lt;where&gt; &lt;foreach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 缓存简介1.什么是缓存？ 存在内存的临时数据 将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 2.为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 3.什么样的数据能使用缓存 经常查询并且不经常改变的数据 MyBatis缓存 MyBatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率 MyBatis系统中定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称本地缓存) 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中哪，没必要在去查询数据库 缓存失效的情况： 1.查询不同的东西 2.增删改操作，可能会改变原来的数据，所有必定会刷新缓存！ 3.查询不同Mapper.xml 4.手动清理缓存 小结 一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个去加段！ 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名门空间对应一个二级缓存 工作机制： 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据会放在自己对应的缓存中 步骤： 1.开启全局缓存 12&lt;!-- 开启全局缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 2.在要使用二级缓存的Mapper中开启","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mybatis框架(三)","slug":"mybatis框架-三","date":"2020-05-24T11:41:01.000Z","updated":"2020-05-27T00:25:40.396Z","comments":true,"path":"2020/05/24/mybatis框架-三/","link":"","permalink":"http://yoursite.com/2020/05/24/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%89/","excerpt":"mybatis笔记(三)","text":"mybatis笔记(三) 注解开发1.注解在接口上使用 12@Select(\"select * from student\") List&lt;Student&gt; getStudents(); 2.需要在核心配置文件中绑定接口 12345&lt;mappers&gt;&lt;!-- &lt;mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/&gt;--&gt;&lt;!-- &lt;mapper class=\"cn.demomybatis.dao.StudentDao\"/&gt;--&gt; &lt;package name=\"cn.demomybatis.dao\"/&gt; &lt;/mappers&gt; 本质：反射机制实现 底层：动态代理！ MyBatis详细执行流程 CRUD我们可以在创建工具类的时候实现自动提交事务！ 123public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 编写接口，增加注释 12345678910//方法存在多个参数，所有参数前面必须加上@Param注解 @Select(\"select * from student where id = #&#123;id&#125;\") Student getStudentById1(@Param(\"id\") int id); @Insert(\"insert into student(id,name,age,phone) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;phone&#125;)\") int addStudent1(Student student); @Update(\"update student set name=#&#123;name&#125;,age=#&#123;age&#125;,phone=#&#123;phone&#125; where id = #&#123;id&#125;\") int updateStudent1(Student student); 关于@Param注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名！ Lombok使用步骤： 1.在IDEA中安装Lombok插件 2.在项目导入Lombok的jar包 3. 123@Data：生成无参构造，get，set，toString，hashcode，equals@AllArgsConstructor 有参构造方法@NoArgsConstructor 无参构造方法 多对一处理按照插叙嵌套处理1234567891011121314151617181920&lt;!-- 思路： 1.查询所有的学生信息 2.根据查询出来的tid，寻找对应的老师！ 子查询--&gt; &lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student &lt;/select&gt; &lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt; 按照结果嵌套处理12345678910&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id; &lt;/select&gt; &lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多处理同理 小结1.关联 - association 【多对一】 2.集合 - collection 【一对多】 3.javaTape：用来指定实体类中属性的类型 4.ofType：用来指定映射到List或者集合中的实体类类型，泛型中的约束类型","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"mybatis框架(二)","slug":"mybatis框架-二","date":"2020-05-22T11:08:13.000Z","updated":"2020-05-23T10:34:51.915Z","comments":true,"path":"2020/05/22/mybatis框架-二/","link":"","permalink":"http://yoursite.com/2020/05/22/mybatis%E6%A1%86%E6%9E%B6-%E4%BA%8C/","excerpt":"mybatis笔记(二)","text":"mybatis笔记(二) 配置解析核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 环境配置MyBatis可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例智能选择一种环境。 Mybatis默认的事务管理器就是JDBC，连接池POOLED 属性(properties)我们可以通过properties属性实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 编写一个配置文件:db.properties 1234driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?serverTimezone=UTCusername=rootpassword=root 在核心配置文件中引入 12&lt;!-- 引入外部配置文件--&gt; &lt;properties resource=\"db.properties\"/&gt; 类型别名类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。 1234&lt;!-- 可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"cn.demomybatis.domain.Student\" alias=\"Student\"/&gt; &lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，他的默认别名就为这个类的类名首字母小写 设置 设置名 描述 有效值 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true|False false 映射器MapperRegistry:注册绑定我们的Mapper文件 方式一： 1234&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/&gt;&lt;/mappers&gt; 方式二： 1234&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=\"cn.demomybatis.dao.StudentDao\"/&gt;&lt;/mappers&gt; 方式三： 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"cn.demomybatis.dao\"/&gt;&lt;/mappers&gt; 生命周期和作用域生命周期和作用域是只管重要的，因为错误的使用会导致非常严重的并发问题 解决属性名和字段名不一致问题resultMap结果集映射 12345&lt;!-- 结果集映射--&gt; &lt;resultMap id=\"StudentMap\" type=\"Student\"&gt; &lt;!-- column是数据库中的字段，property是实体类中的字段--&gt; &lt;result column=\"u_id\" property=\"id\"&gt;&lt;/result&gt; &lt;/resultMap&gt; resultMap元素是MyBatis中最重要最强大的元素 ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，对于复杂一点的语句只需要猫叔他们的关系就行了 ResultMap最优秀的地方在于，虽然你已经对他相当了解了，但根本不需要显式的用到他们。 日志日志工厂如果一个数据库操作出现了异常，我们需要排错。日志就是最好的帮手！ 设置名 描述 有效值 默认值 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J，LOG4J，LOG4J2，JDK_LOGGING，COMMONS_LOGGING，STDOUT_LOGGING，NO_LOGGING 未设置 1234&lt;settings&gt; &lt;!-- 标准的日志实现--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; LOG4J什么式log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 1.先导入LOG4J的jar包 2.log4j.properties配置文件 12345678910111213141516171819202122232425262728293031############################################### Log4J 配置文件############################################### 定义缺省的日志级别和输出对象log4j.rootLogger=DEBUG,INFO, logfile,console# 设定控制台输出模式log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%d&#123;MM/dd HH:mm:ss&#125;] [%-3p] %c&#123;1&#125;: %m%n# 针对package定义日志级别log4j.logger.org.apache=WARNlog4j.logger.com.paic.pafademo=DEBUG# 设定日志文件的输出模式log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.logfile.DatePattern=yyyyMMdd# $&#123;pafa.log.home&#125;通过参数-D指定，比如启动WebLogic时加入参数-Dpafa.log.home=c:/log4j.appender.logfile.File=$&#123;log.home&#125;/appdemo/pafa.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d&#123;MM/dd HH:mm:ss&#125; [%-3p] %c&#123;1&#125;: %m%n# 如果要查看iBATIS的SQL日志信息，确保有下面配置log4j.logger.com.ibatis=DEBUGlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 3.配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; 简单使用1.在要使用的Log4j的类中，导入import org.apache.log4j.Logger; 2.日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(mybatistest.class); 分页使用limit分类使用MyBatis实现分页，核心SQL 1.接口 12//分页 List&lt;Student&gt; getStudentByLimit(Map&lt;String,Integer&gt; map); 2.StudentDao.xml 123&lt;select id=\"getStudentByLimit\" resultType=\"Student\" parameterType=\"map\"&gt; select * from student limit #&#123;startIndex&#125;,#&#123;pageSize&#125; &lt;/select&gt; 3.测试 12345678910111213@Test public void getStudentByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); StudentDao studentDao = sqlSession.getMapper(StudentDao.class); Map&lt;String,Integer&gt; map = new HashMap(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List&lt;Student&gt; studentList = studentDao.getStudentByLimit(map); for (Student student : studentList) &#123; System.out.println(student); &#125; sqlSession.close(); &#125; RowBounds分页","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"ngork内网穿透","slug":"ngork内网穿透","date":"2020-05-22T01:11:58.000Z","updated":"2020-05-22T01:30:42.390Z","comments":true,"path":"2020/05/22/ngork内网穿透/","link":"","permalink":"http://yoursite.com/2020/05/22/ngork%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"将本地的项目运行在公网上","text":"将本地的项目运行在公网上 1.进入ngrok官网（http://www.ngrok.cc/），注册ngrok账号2.登录–&gt;隧道管理–&gt;开通隧道找到免费的 隧道名称和前置域名随便填就行了 端口填自己tomcat的端口 点击客户端下载 下载完成之后点击启动工具 输入隧道id 显示这个就已经成功了 可以通过上边哪个域名访问自己本地的项目了","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"PicGo+GitHub图床，让Markdown飞","slug":"PicGo-GitHub图床，让Markdown飞","date":"2020-05-21T11:19:47.000Z","updated":"2020-05-23T10:56:51.923Z","comments":true,"path":"2020/05/21/PicGo-GitHub图床，让Markdown飞/","link":"","permalink":"http://yoursite.com/2020/05/21/PicGo-GitHub%E5%9B%BE%E5%BA%8A%EF%BC%8C%E8%AE%A9Markdown%E9%A3%9E/","excerpt":"PicGo+GitHub图床","text":"PicGo+GitHub图床 一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种“轻量级标记语言”。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：Typora和马克飞象。 目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都近乎完美但是却又不能达到完美。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是将截图存放在本机电脑上，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。 这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：PicGo+GitHub图床 注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户） PicGo介绍这是一款图片上传的工具，目前支持微博图床，七牛图床，腾讯云，又拍云，GitHub等图床，未来将支持更多图床。 所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。 Pic Go支持的图床 在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。 创建自己的GitHub图床1. 创建GitHub图床之前，需要注册/登陆GitHub账号 申请GitHub账号很简单，我就不演示了 2. 创建Repository 点击”New repository”按钮 我已经建立过一个同名的repository的，所以第一步会显示红色 第三步，为repository初始化一个README.md文件可以根据需求选择，非必选 3.生成一个Token用于操作GitHub repository 回到主页，点击”Settings”按钮 进入页面后，点击”Developer settings”按钮 点击”Personal access tokens”按钮 创建新的Token 填写描述，选择”repo”,然后点击”Generate token”按钮 注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存 配置PicGo1. 下载运行PicGo 推荐下载exe可执行文件 2. 配置图床 如图配置 设定仓库名的时候，是按照“账户名/仓库名的格式填写” 分支名统一填写“master” 将之前的Token黏贴在这里 存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹 自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/用户名/RepositoryName/分支名，，自定义域名需要按照这样去填写 总结将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下ctrl+shift+c，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！。 自己在本地用确实没有什么问题，但是提交到博客上发现图片加载失败，或者加载异常慢，于是我发现了一种加速的方法 CDN 简介 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。—— Wikipedia 简而言之就是让服务器距离大陆较远的 GitHub ，将托管在那里的静态资源缓存到一个近一点的服务器，从而加快访问。 看了这样的解释你应该能够理解，CDN 虽然能缓解互联压力，可也是要耗费一定的资源的，从而市面上的 CDN 大多是收费的。Cloudflare 虽然有免费 CDN ，可是国内节点致开放给专业版用户使用，价格偏高，而海外的节点又类似负优化，可能还会降低速度。 jsDelivrjsDelivr是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。 有搜索引擎，支持一键复制文件 URL 和标签，支持分发 NPM、GitHub、WordPress SVN 的文件 基础使用可能看起来，官方的使用方法十分复杂，但其实就一句话：把仓库链接的域名替换成 jsDelivr 的域名。 如托管在 GitHub 的仓库链接都是 https://github.com/username/repo/branch/file 的形式，而我们就可以将前面的 github.com 改成 jsDelivr 提供加速 GitHub 仓库的域名 cdn.jsdelivr.net/gh 。 嗯，兴冲冲配置一发，发现什么都没有？其实还是有一点点小差别的。比如分支那里，jsDelivr 默认要直接在仓库名后面 @ ，所以真正其实是 https://cdn.jsdelivr.net/gh/username/repo@branch/file 的形式。当然，如果你放在仓库的默认分支，还可以直接将 branch 这个关键字直接删了，变成 https://cdn.jsdelivr.net/gh/username/repo/file 一样能获取到！ 另外，如果是一些比较稳定的文件，后面不会频繁地改动，还可以发布成一个版本，然后在 repo 后 @version 就可以引用对应的版本。 加速图床如果你还记得笔者之前写的 PicGo + GitHub 搭建免费图床 的话，不难发现 jsDelivr 也是能加速这个图床（本质不还是一个 GitHub 仓库嘛）的。我们只需要在 GitHub 图床设置 中将链接设置为 https://cdn.jsdelivr.net/gh/username/repo 即可！前提是你上传到默认分支。","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"mybatis框架(一)","slug":"mybatis框架-一","date":"2020-05-19T11:04:42.000Z","updated":"2020-05-22T11:12:13.440Z","comments":true,"path":"2020/05/19/mybatis框架-一/","link":"","permalink":"http://yoursite.com/2020/05/19/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%80/","excerpt":"mybatis笔记(一)","text":"mybatis笔记(一) mybatis概述mybatis是一个持久层框架，用java编写，封装了很多jdbc细节，开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程，它使用了ORM思想，实现了结果集的封装。 ORM：Object Relational Mappging 对象关系映射简单的说：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类及实现操作数据库 mybatis环境搭建 1.创建maven工程并导入坐标12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.18&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2.创建实体类和dao接口 3.创建mybatis的主配置文件SqlMapConfig.xml 4.创建映射配置文件注意事项 1.包在创建时 com.demomybatis.dao他是三级目录结构 2.mybatis的映射配置文件位置必须和dao接口的包结构相同 3.映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定而类名 4.映射配置文件的擦偶哦配置(select) id的取值必须是dao接口的方法名 当我们遵从2，3，4点之后，我们开发中就无需再写dao的实现类 SqlMapConfig.xml代码1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default&#x3D;&quot;mysql&quot;&gt; &lt;environment id&#x3D;&quot;mysql&quot;&gt; &lt;!--使用jdbc事务管理 --&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;!-- 数据库连接池(数据源) --&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!-- 引入映射配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;cn&#x2F;demomybatis&#x2F;dao&#x2F;StudentDao.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; StudentDao.xml代码123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace：命名空间，用于隔离sql--&gt;&lt;mapper namespace&#x3D;&quot;cn.demomybatis.dao.StudentDao&quot;&gt; &lt;!-- 配置查询所有 id为dao的方法名--&gt; &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;cn.demomybatis.domain.Student&quot; parameterType&#x3D;&quot;cn.demomybatis.domain.Student&quot;&gt; select * from student &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; mybatis入门案例： 1.读取配置文件 2.创建SqlSessionFactory工厂 3.创建SqlSession 4.创建Dao接口的代理 5.执行Dao中的方法 6.释放资源 注意：需要在映射配置中告知mybatis要封装到哪个实体类中，配置的方式：指定实体类的全类名 增删改需要提交事务 sqlSession.commit() 测试代码1234567891011121314151617181920212223242526272829303132333435363738package cn.demomybatis.test;import cn.demomybatis.dao.StudentDao;import cn.demomybatis.domain.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;&#x2F;** * mybatis入门 *&#x2F;public class mybatistest &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;读取配置文件 InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); &#x2F;&#x2F;创建工厂 SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder(); SqlSessionFactory factory &#x3D; builder.build(in); &#x2F;&#x2F;使用工厂生产SqlSession对象 SqlSession sqlSession &#x3D; factory.openSession(); &#x2F;&#x2F;创建Dao接口的代理对象 StudentDao studentDao &#x3D; sqlSession.getMapper(StudentDao.class); &#x2F;&#x2F;使用代理对象执行方法 List&lt;Student&gt; list &#x3D; studentDao.findAll(); for (Student student:list)&#123; System.out.println(student); &#125; &#x2F;&#x2F;释放资源 sqlSession.close(); in.close(); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"抽取Servlet","slug":"抽取Servlet","date":"2020-05-13T09:15:56.000Z","updated":"2020-05-17T07:41:58.636Z","comments":true,"path":"2020/05/13/抽取Servlet/","link":"","permalink":"http://yoursite.com/2020/05/13/%E6%8A%BD%E5%8F%96Servlet/","excerpt":"BaseServlet代码","text":"BaseServlet代码 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.travel.web.servlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;完成方法的分发 &#x2F;&#x2F;获取请求路径 String uri &#x3D; req.getRequestURI(); System.out.println(&quot;请求uri:&quot;+uri); &#x2F;&#x2F;获取方法对象 String methodName &#x3D; uri.substring(uri.lastIndexOf(&quot;&#x2F;&quot;)+1); System.out.println(&quot;方法名称：&quot;+methodName); &#x2F;&#x2F;获取方法对象Method try &#123; Method method &#x3D; this.getClass().getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class); &#x2F;&#x2F;暴力反射 &#x2F;&#x2F;method.setAccessible(true); &#x2F;&#x2F;执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; UserServlet代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198package cn.travel.web.servlet;import cn.travel.damain.ResultInfo;import cn.travel.damain.User;import cn.travel.service.UserService;import cn.travel.service.impl.UserServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;&#x2F;user&#x2F;*&quot;)public class UserServlet extends BaseServlet &#123; &#x2F;** * 注册功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void regist(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;验证码校验 String checkcode &#x3D; request.getParameter(&quot;checkcode&quot;); String checkcode_session &#x3D; (String) request.getSession().getAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;防止验证码复用 保证验证码只能使用一次 request.getSession().removeAttribute(&quot;checkcode_session&quot;); &#x2F;&#x2F;比较 if (checkcode_session &#x3D;&#x3D; null || !checkcode_session.equalsIgnoreCase(checkcode)) &#123; ResultInfo info &#x3D; new ResultInfo(); info.setFlag(false); info.setErrorMsg(&quot;验证码错误&quot;); &#x2F;&#x2F;将info对象序列化为json ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(info); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); return; &#125; &#x2F;&#x2F;获取数据 String username &#x3D; request.getParameter(&quot;username&quot;); String password &#x3D; request.getParameter(&quot;password&quot;); String name &#x3D; request.getParameter(&quot;name&quot;); String birthday &#x3D; request.getParameter(&quot;birthday&quot;); String email &#x3D; request.getParameter(&quot;email&quot;); &#x2F;&#x2F;封装对象 User user &#x3D; new User(); user.setUsername(username); user.setPassword(password); user.setName(name); user.setBirthday(birthday); user.setEmail(email); &#x2F;&#x2F;调用service完成注册 UserService service &#x3D; new UserServiceImpl(); boolean flag &#x3D; service.regist(user); &#x2F;&#x2F;响应结果 ResultInfo resultInfo &#x3D; new ResultInfo(); if (flag) &#123; &#x2F;&#x2F;注册成功 resultInfo.setFlag(true); &#125; else &#123; &#x2F;&#x2F;注册失败 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;注册失败！&quot;); &#125; &#x2F;&#x2F;将resultInfo对象序列化为JSON，并写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); &#x2F;&#x2F;将json数据写回客户端 &#x2F;&#x2F;设置content-type response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 登录功能 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取用户名和密码数据 Map&lt;String, String[]&gt; map &#x3D; request.getParameterMap(); &#x2F;&#x2F;分装user对象 User user &#x3D; new User(); try &#123; BeanUtils.populate(user, map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;调用service查询 UserService service &#x3D; new UserServiceImpl(); User u &#x3D; service.login(user); &#x2F;&#x2F;判断 ResultInfo resultInfo &#x3D; new ResultInfo(); if (u &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;用户名密码错误 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;用户名或密码错误!&quot;); &#125; &#x2F;&#x2F;判断用户是否激活 if (u !&#x3D; null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;用户尚未激活 resultInfo.setFlag(false); resultInfo.setErrorMsg(&quot;您尚未激活，请前往邮箱激活!&quot;); &#125; &#x2F;&#x2F;登录成功的判断 if (u !&#x3D; null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())) &#123; &#x2F;&#x2F;登录成功 resultInfo.setFlag(true); &#125; request.getSession().setAttribute(&quot;user&quot;, u); &#x2F;&#x2F;响应数据 ObjectMapper mapper &#x3D; new ObjectMapper(); String json &#x3D; mapper.writeValueAsString(resultInfo); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); response.getWriter().write(json); &#125; &#x2F;** * 查找单个对象 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); &#x2F;&#x2F;将user写回客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); mapper.writeValue(response.getOutputStream(), user); &#125; &#x2F;** * 退出 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void exit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;销毁session request.getSession().invalidate(); &#x2F;&#x2F;跳转页面 重定向 response.sendRedirect(request.getContextPath() + &quot;&#x2F;login.html&quot;); &#125; &#x2F;** * 激活 * @param request * @param response * @throws ServletException * @throws IOException *&#x2F; public void active(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#x2F;&#x2F;获取激活码 String code &#x3D; request.getParameter(&quot;code&quot;); if (code !&#x3D; null) &#123; &#x2F;&#x2F;调用service完成激活 UserService service &#x3D; new UserServiceImpl(); Boolean flag &#x3D; service.active(code); &#x2F;&#x2F;判断标记 String msg &#x3D; null; if (flag) &#123; &#x2F;&#x2F;激活成功 msg &#x3D; &quot;激活成功，请&lt;a href&#x3D;&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;; &#125; else &#123; &#x2F;&#x2F;激活失败 msg &#x3D; &quot;激活失败，联系管理员&quot;; &#125; response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); response.getWriter().write(msg); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"redis数据库","slug":"redis数据库","date":"2020-05-01T04:10:36.000Z","updated":"2020-10-24T07:12:54.071Z","comments":true,"path":"2020/05/01/redis数据库/","link":"","permalink":"http://yoursite.com/2020/05/01/redis%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"Redis","text":"Redis 下载：百度云下载 提取码：o1ui Github下载 概念：一款高性能的NOSQL系列的非关系型数据库命令：redis存储的是：key，value格式的数据，其中key都是字符串，value有5中不同的数据结构 value的数据结构 1.字符串类型 string 2.哈希类型 hash ：相当于map集合 3.列表集合 list ：linkedlist格式 4.集合类型 set 5.有序集合类型 sortedset字符串类型string1.存储 set key value 2.获取 get key 3.删除 del key 哈希类型 hash1.存储 hset key field value 2.获取 hget key field hgetall key 获取所有的键和值 3.删除 hdel key field 列表类型 list1.lpush key value 将元素加入列表左边 2.rpush key value 将元素加入列表右边 3.lrange key start end 获取范围 4.lpop key 删除列表最左边的元素，并将元素返回 5.rpop key 删除列表最右边的元素 集合类型 set1.存储：sadd key value 2.获取：smembers key ：获取集合中所有元素 3.删除：srem key value ：删除集合的某个元素 有序集合类型 sortedset1.存储：zadd key score value 2.获取：zrange key start end 3.删除：zrem key value 通用命令：1.keys * ：查询所有的键 2.type key：获取键对应的value的类型 3.del key：删除指定的key value 持久化存储 1.redis是一个内存数据库，东redis服务器重启后，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘中 2.redis持久化机制 1.RDB：默认方式。 在一定的间隔时间中，检测key的变化情况，然后去持久化数据 2.AOF：日志记录的方式，可以检测每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windows.conf文件 appendonly no 给成yes Java客户端JedisJedis是一款java操作redis数据库的工具Jedis连接池：JedisPool1.创建JedisPool连接池对象 2.调用getResource()方法获取Jedis的连接工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142package cn.jedis.utlis;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;&#x2F;*JedisPool工具类加载配置文件，配置连接池参数提供获取连接的方法 *&#x2F;public class JedisPoolUtils &#123; private static JedisPool jedisPool; static &#123; &#x2F;&#x2F;读取配置文件 InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); &#x2F;&#x2F;创建一个Properties对象 Properties pro &#x3D; new Properties(); &#x2F;&#x2F;关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中 JedisPoolConfig config &#x3D; new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); &#x2F;&#x2F;初始化JedisPool jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; &#x2F;&#x2F;获取连接 public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; SpringBoot整合Redis 导入Redis启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在配置文件中配置Redis参数，默认存在，不配也可 12345# 配置redis数据库spring: redis: host: localhost port: 6379 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.gem;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.StringRedisTemplate;import java.util.List;import java.util.Set;/** * @author zhang * @date 2020/10/24 10:10 */@SpringBootTestpublic class RedisTest &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test public void test1()&#123; //String字符串 key相同会覆盖掉 //stringRedisTemplate.opsForValue().set(\"name\",\"tom\"); //System.out.println(\"str = \" + stringRedisTemplate.opsForValue().get(\"name\")); //hash散列 相当于map stringRedisTemplate.boundHashOps(\"h_key\").put(\"name\",\"张三\"); stringRedisTemplate.boundHashOps(\"h_key\").put(\"age\",\"12\"); //获取所有域 Set set = stringRedisTemplate.boundHashOps(\"h_key\").keys(); System.out.println(set); //获取所有值 List list = stringRedisTemplate.boundHashOps(\"h_key\").values(); System.out.println(list); //list列表 stringRedisTemplate.boundListOps(\"l_key\").leftPush(\"c\"); stringRedisTemplate.boundListOps(\"l_key\").leftPush(\"b\"); stringRedisTemplate.boundListOps(\"l_key\").leftPush(\"a\"); //获取所有元素 List l_key = stringRedisTemplate.boundListOps(\"l_key\").range(0,-1); System.out.println(l_key); //set集合 stringRedisTemplate.boundSetOps(\"s_key\").add(\"a\",\"b\",\"c\"); Set s_key = stringRedisTemplate.boundSetOps(\"s_key\").members(); System.out.println(s_key); //sorted set 有序集合 需要天机成绩 用于排序 stringRedisTemplate.boundZSetOps(\"z_key\").add(\"a\",10); stringRedisTemplate.boundZSetOps(\"z_key\").add(\"b\",40); stringRedisTemplate.boundZSetOps(\"z_key\").add(\"c\",30); System.out.println(stringRedisTemplate.boundZSetOps(\"z_key\").range(0,-1)); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"AJAX和JSON","slug":"ajax和JSON","date":"2020-04-28T11:12:12.000Z","updated":"2020-05-17T07:39:30.306Z","comments":true,"path":"2020/04/28/ajax和JSON/","link":"","permalink":"http://yoursite.com/2020/04/28/ajax%E5%92%8CJSON/","excerpt":"AJAX","text":"AJAX 概念：ASynchronous JavaScript And XML 异步的javascript和xml实现方式: 1.原生的JS实现方式 2.JQuery实现方式 1.$.ajax()} $.ajax({键值对}); 2.$.get() 3.$.post() JOSN概念：JavaScript Object Notation JavaScript对象表示法基本规则：获取数据:json对象.键名 json对象[“键名”] 数组对象[索引] 遍历JSON123for (var key in person)&#123; alert(key+&quot;:&quot;+person[key])&#125; JSON数据和Java对象的相互转换1.JSON转为Java 1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 12345678String json &#x3D; &quot;&#123;\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:20,\\&quot;gender\\&quot;:\\&quot;男\\&quot;&#125;&quot;;&#x2F;&#x2F;创建ObjectMappperObjectMapper mapper &#x3D; new ObjectMapper();mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);&#x2F;&#x2F;转换为Java的对象Person person &#x3D; mapper.readValue(json,Person.class);System.out.println(person); 2.Java转为JSON1.导入jar包 2.创建jackson核心对象 ObjectMapper 3.调用ObjectMapper的相关方法进行转换代码 123456789101112131415161718192021public void test1() throws Exception &#123; Person p &#x3D; new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGendeer(&quot;男&quot;); &#x2F;&#x2F;创建Jackson的核心对象 ObjectMapper ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;调用方法 转换 String JSON &#x3D; mapper.writeValueAsString(p); System.out.println(JSON); &#x2F;&#x2F;wirterValue 将数据写入到D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt中 &#x2F;&#x2F;mapper.writeValue(new File(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt&quot;),p); &#x2F;&#x2F;writeValue将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;b.txt&quot;),p);&#125; 注解：1.@JsonIgnore:排除属性 2.@JsonFormat:属性值格式化案例校验用户是否存在 html代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;注册&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;JS&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F;页面加载完成后 给文本框绑定离开焦点事件 $(function () &#123; $(&quot;#username&quot;).blur(function () &#123; &#x2F;&#x2F;获取username获取文本输入框的值 var username &#x3D; $(this).val(); &#x2F;&#x2F;发送ajax请求 $.get(&quot;findUserServlet&quot;,&#123;username:username&#125;,function (data) &#123; var span &#x3D; $(&quot;#s_username&quot;) if (data.userExsit)&#123; &#x2F;&#x2F;用户名存在 span.css(&quot;color&quot;,&quot;red&quot;) span.html(data.msg) &#125;else &#123; &#x2F;&#x2F;用户名不存在 span.css(&quot;color&quot;,&quot;green&quot;) span.html(data.msg) &#125; &#125;,&quot;json&quot;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form&gt; &lt;input id&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt; &lt;span id&#x3D;&quot;s_username&quot;&gt;&lt;&#x2F;span&gt;&lt;br&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;注册&quot;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Servlet代码 123456789101112131415161718192021222324252627282930313233343536373839package cn.test.web.servlet;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;&#x2F;findUserServlet&quot;)public class findUserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username &#x3D; request.getParameter(&quot;username&quot;); &#x2F;&#x2F;设置响应数据为JSON response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;); Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); if (&quot;Tom&quot;.equals(username))&#123; &#x2F;&#x2F;存在 map.put(&quot;userExsit&quot;,true); map.put(&quot;msg&quot;,&quot;用户名已经存在&quot;); &#125;else &#123; &#x2F;&#x2F;不存在 map.put(&quot;userExsit&quot;,false); map.put(&quot;msg&quot;,&quot;用户名可用&quot;); &#125; &#x2F;&#x2F;将map转为json，并且传递给客户端 ObjectMapper mapper &#x3D; new ObjectMapper(); mapper.writeValue(response.getWriter(),map); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"JQuery笔记","slug":"JQuery笔记","date":"2020-04-26T08:04:39.000Z","updated":"2020-05-17T07:43:32.163Z","comments":true,"path":"2020/04/26/JQuery笔记/","link":"","permalink":"http://yoursite.com/2020/04/26/JQuery%E7%AC%94%E8%AE%B0/","excerpt":"JQuery笔记","text":"JQuery笔记 概念：一个JavaScript框架，简化JS开发 使用步骤： 1.下载JQuery 2.导入JQuery的js文件 导入min.js 3.使用 JQuery对象和JS对象的区别 方法不互通 转换： jq -&gt; js : jq对象[索引] 或者 jp对象.get(索引) js -&gt; jq : $(js对象)选择器：筛选具有相似特征的元素(标签)1.基本选择器 1.标签选择器(元素选择器) `$(&quot;html标签名&quot;)` 获得所有匹配标签名称的元素 2.id选择器 `$(&quot;#id的属性值&quot;)` 获得与指定id值匹配的元素 3.类选择器 `$(&quot;.class的属性&quot;)` 获得与指定的class属性值相匹配的元素2.层级选择器 1.后代选择器： `$(&quot;A B&quot;)` 选择A元素所有内部的B元素 2.子选择器 `$(&quot;A &gt; B&quot;)` 选择A元素内部的所有B子元素 3.属性选择器 1.属性名称选择器 $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2.属性选择器 $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3.符合属性选择器 $(&quot;A[属性名=&apos;值&apos;][ ]...&quot;) 包含多个属性条件的选择器 4.过滤选择器 1.首元素选择器 :first 获得选择的元素中第一个元素 2.尾元素选择器 :last 获得选择的元素中最后一个元素 3.非元素选择器 not(.selector) 不包括指定内容的元素 4.偶数选择器 even 偶数，从0开始计数 5.奇数选择器 odd 奇数 ，从0开始 6.等于索引选择器 eq(index) 指定索引元素 7.大于索引选择器 gt(index) 大于指定索引选择器 8.小于索引选择器 lt(index) 小于指定索引选择器 9.标题选择器 header 获得标题(h1-h6)元素，固定写法 5.表单过滤选择器 1.可用元素选择器 :enabled 获得可用元素 2.不可以用元素选择器 :disabled 获得不可用元素 3.选中选择器 :checked 获得单选，复选框中的元素 4.选中选择器 :selected 获得下拉框中选中的元素 DOM操作1.内容操作 1.html() ： 获取/设置元素的标签体内容， 内容 –&gt; 内容 2.text() ： 获取/设置元素标签体纯文本内容 内容 –&gt; 内容 3.val() : 获取/设置元素的属性值 2.属性操作 1.通用属性操作 1.attr() 获取/设置元素的属性 2.removeAttr() 删除属性 3.prop() 获取/设置元素的属性 4.removeProp() 删除属性 *attr和prop的区别 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素的自定义属性，则建议是attr 2.对class属性操作 1.addClass() 添加class属性值 2.removeClass() 删除class属性值 3.toggleClass() 切换class属性值 3.CRUD操作 1.append(): 父元素将子元素追加到末尾 - 对象1.append(对象2)：将对象2添加到对象1元素内部，并且在末尾 2.prepend():父元素将子元素追加到开头 -对象1.prepend(对象2)：将对象2添加到对象1元素内部，并且在开头 3.appendto(): 4.prependto(): 5.after():添加元素到元素后边 6.before()：将元素添加到元素前边 7.insertAfter(): 8.insertBrfore(): 9.remove()：删除元素 10.empty()：清空元素的所有后代元素JQuery高级1.动画 1.三种方式显示和隐藏元素 1.show([speed,[easing],[fn]]) 2.hide([speed,[easing],[fn]]) 3.toggle([speed],[easing],[fn]) 2.滑动显示和隐藏方式 1.slideDown([speed],[easing],[fn]) 2.slideUp([speed,[easing],[fn]]) 3.slieToggle([speed],[easing],[fn]) 3.淡入淡出的显示和隐藏方式 1.fadeIn([speed],[easing],[fn]) 2.fadeOut([speed],[easing],[fn]) 3.fadeToggle([speed,[easing],[fn]])2.遍历 1.jq对象.each(callback) 2.$.each(object,[callback]) 3.for..of: 3.事件绑定 1.jquery标准的绑定方式 jq对象.事件方法(回调函数) 2.on绑定事件/off绑定事件 jq对象.on(&quot;事件名称&quot;,回调函数) jq对象.off(&quot;事件名称&quot;) 3.事件切换 jq对象.toggle(fn1,fn2...) 案例需求：1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;*需求： 1.当页面加载完后。3秒后，自动显示广告 2.当广告显示5秒后自动消失 分析： 1.使用定时器来完成。setTimeout(执行一次) 2.JQuery的动画效果就是控制display属性 *&#x2F; &#x2F;&#x2F;入口函数，在页面加载完成后定义定时器，调用这两个方法 $(function () &#123; &#x2F;&#x2F;定时器 调用adShow()方法 setTimeout(adShow,3000); setTimeout(adHide,8000); &#125;) &#x2F;&#x2F;显示广告方法 function adShow() &#123; &#x2F;&#x2F;获取广告div 调用show方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; &#x2F;&#x2F;隐藏广告方法 function adHide() &#123; $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt; &lt;div id&#x3D;&quot;ad&quot; style&#x3D;&quot;display: none;&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;广告.jpg&quot;&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;content&quot;&gt; 正文部分 &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 需求：抽奖案例 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;抽奖&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;* 分析： 1.给开始按钮绑定单击事件 1.1定义循环定时器 1.2切换小相框的src属性 定义一个数组，存放图片资源的路径 生成随机数 数组索引 2.给结束按钮绑定单击事件 2.1停止定时器 2.2给大相框设置src属性 *&#x2F; var imgs &#x3D; [&quot;..&#x2F;img&#x2F;1.jpg&quot;,&quot;..&#x2F;img&#x2F;2.jpg&quot;,&quot;..&#x2F;img&#x2F;3.jpg&quot;,&quot;..&#x2F;img&#x2F;4.jpg&quot;,&quot;..&#x2F;img&#x2F;5.jpg&quot;,&quot;..&#x2F;img&#x2F;6.jpg&quot;,&quot;..&#x2F;img&#x2F;0.jpg&quot;] var startId;&#x2F;&#x2F;开始定时器的一个Id var index; $(function () &#123; &#x2F;&#x2F;开始按钮 $(&quot;#startID&quot;).click(function () &#123; startId &#x3D; setInterval(function () &#123; &#x2F;&#x2F;生成随机角标 index &#x3D; Math.floor(Math.random() * 7) &#x2F;&#x2F;设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20) &#125;) &#x2F;&#x2F;结束按钮 $(&quot;#stopID&quot;).click(function () &#123; $(&quot;#stopID&quot;).click(function () &#123; &#x2F;&#x2F;停止定时器 clearInterval(startId) $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;) &#125;) &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--小相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;width: 160px;height: 100px;&quot;&gt; &lt;img id&#x3D;&quot;img1ID&quot; style&#x3D;&quot;width: 160px;height: 100px&quot; src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot;&gt;&lt;&#x2F;div&gt;&lt;!--大相框--&gt;&lt;div style&#x3D;&quot;border-style: dotted;height: 500px;position: absolute;left: 500px;top: 10px&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot; id&#x3D;&quot;img2ID&quot; width&#x3D;&quot;800px&quot;height&#x3D;&quot;600px&quot;&gt;&lt;&#x2F;div&gt;&lt;!--开始按钮--&gt;&lt;input id&#x3D;&quot;startID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击开始&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;!--停止按钮--&gt;&lt;input id&#x3D;&quot;stopID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击停止&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Filter过滤器","slug":"Filter过滤器","date":"2020-04-23T06:49:44.000Z","updated":"2020-05-17T07:42:52.842Z","comments":true,"path":"2020/04/23/Filter过滤器/","link":"","permalink":"http://yoursite.com/2020/04/23/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"Filter：过滤器","text":"Filter：过滤器 步骤： 1.定义一个类，实现Filter 2.复写方法 3.配置拦截路径 web.xml的配置12345678&lt;filter&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;cn.filter.demo1&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&#x2F;&#x2F;拦截路径&lt;&#x2F;filter-mapping&gt; 过滤器的生命周期 1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次用于加载资源 2.doFilter:每次拦截资源时被执行，执行很多次。 3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。执行一次，用于释放资源。 拦截路径的配置 1.具体的资源路径:/index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2.目录拦截: /user/* 访问/user下的所有资源时，过滤器都会被执行 3.后缀名拦截： *.jsp 访问所有后缀名为jsp的资源时，过滤器都会被执行 4.拦截所有资源： /* 访问所有资源时，过滤器都会被执行 拦截方式的配置注解配置： 1.REQUEST:默认值 浏览器直接请求资源 2.FORWARD:转发访问资源 3.INCLUDE:包含访问资源 4.ERROR:错误跳转 5.ASYNC:异步访问资源 过滤器先后顺序问题1.注解配置:按照类名的字符串比较规则比较，值小的先执行 2.web.xml配置:&lt;filter-mappping&gt;谁定义在前面，谁先执行登录案例判断是否登录分析1.判断是否是登录的相关资源 * 是 直接放行 * 不是 判断是否登录 2.判断当前用户是否登录，判断Session是否有user * 有 已经登录 放行 * 没有 没有登录 跳转到登录页面代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;&#x2F;** * 登录验证的过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class loginFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;0.强制转换 HttpServletRequest request &#x3D; (HttpServletRequest) req; &#x2F;&#x2F;1.获取请求资源的路径 String uri &#x3D; request.getRequestURI(); &#x2F;&#x2F;2.判断是否包含登录相关的路径 if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;&#x2F;loginServlet&quot;) || uri.contains(&quot;&#x2F;checkcodeServlet&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;))&#123; &#x2F;&#x2F;放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;不包含 需要验证用户是否登录 &#x2F;&#x2F;从Session获取user Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;); if (user!&#x3D;null)&#123; &#x2F;&#x2F;登录了 放行 chain.doFilter(req, resp); &#125;else &#123; &#x2F;&#x2F;没有登录 跳转登录页面 request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp); &#125; &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 敏感词汇过滤分析1.对request对象进行增强。增强获取参数相关方法 2.放行。爨地代理对象增强对象的功能设计模式：一些通用的解决固定问题的方式 * 1.装饰模式 * 2.代理模式 实现步骤： - 1.代理对象和真实对象实现相同的接口 - 2.代理对象 = Proxy.newProxyInstance(); - 3.使用代理对象调用方法 - 4.增强方法 增强方式： - 1.增强参数列表 - 2.增强返回值类型 - 3.增强方法体执行逻辑代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.test.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.*;&#x2F;** * 敏感词汇过滤器 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class sensitiveWordsFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; &#x2F;&#x2F;创建代理对象，增强getParameter方法 ServletRequest proxy_req &#x3D; (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; &#x2F;&#x2F;判断是否是getParameter if (method.getName().equals(&quot;getParameter&quot;))&#123; &#x2F;&#x2F;增强返回值 &#x2F;&#x2F;获取返回值 String value &#x3D; (String) method.invoke(req,args); if (value !&#x3D; null)&#123; for (String str:list)&#123; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); &#125; &#125; &#125; return value; &#125; &#x2F;&#x2F;判断是否是getParameterMap if (method.getName().equals(&quot;getParameterMap&quot;))&#123; &#x2F;&#x2F;由request得到的原数组不可改变，他是被锁住的，所以这里创建一个新数组来复制原数组，返回新的数组 &#x2F;&#x2F;其实想法很想简单，既然传递进来的映射不可改变，那么自己new一个出来不就行了 Map&lt;String,String[]&gt; map1 &#x3D; new HashMap&lt;&gt;(); Map&lt;String,String[]&gt; map &#x3D; (Map&lt;String, String[]&gt;) method.invoke(req,args); Set&lt;String&gt; keySet &#x3D; map.keySet(); if (keySet !&#x3D; null)&#123; for (String str:list)&#123; for (String key:keySet)&#123; String[] values &#x3D; map.get(key); for (int i&#x3D;0;i&lt;values.length;i++)&#123; String value &#x3D; values[i]; if (value.contains(str))&#123; value &#x3D; value.replaceAll(str,&quot;***&quot;); values[i] &#x3D; value; &#125; &#125;map1.put(key,values); &#125; &#125; &#125; return map1; &#125; return method.invoke(req,args); &#125; &#125;); &#x2F;&#x2F;放行 chain.doFilter(proxy_req, resp); &#125; private List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F;敏感词汇 public void init(FilterConfig config) throws ServletException &#123; try &#123; &#x2F;&#x2F;获取文件真实路径 ServletContext context &#x3D; config.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;敏感词汇.txt&quot;); &#x2F;&#x2F;读取文件 BufferedReader br &#x3D; new BufferedReader(new FileReader(realPath)); &#x2F;&#x2F;将文件的每一行数据添加到list集合中 String line &#x3D; null; while ((line&#x3D;br.readLine())!&#x3D;null)&#123; list.add(line); &#125; br.close();&#x2F;&#x2F;释放资源 System.out.println(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Jetbrains系列产品2020.1最新激活方法","slug":"Jetbrains系列产品2020-1最新激活方法","date":"2020-04-15T03:56:11.000Z","updated":"2020-05-17T07:43:23.388Z","comments":true,"path":"2020/04/15/Jetbrains系列产品2020-1最新激活方法/","link":"","permalink":"http://yoursite.com/2020/04/15/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812020-1%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/","excerpt":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。","text":"本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。 大家熟知Jetbrains的话应该知道：他们家的所有产品升级到2018.2.1及以上版本后，先前可用的注册服务器都失效了，无法激活升级到最新版本体验最新黑科技。 这次要送的这份礼就是： Jetbrains全系列产品2020.1及以下版本（理论上适用于目前所有新老版本）最新注册服务器（License Server）的破解，可使用它来激活你手头上的Jetbrains IDE，具体支持产品和版本见下文的列表。 传送门: 百度云下载 提取码：w26y 使用方法: 0.先下载压缩包解压后得到jetbrains-agent.jar。 1.启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。 2.将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。（事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题） 3.在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。 4.重启IDE，搞定。 x. 支持两种注册方式：License server 和 Activation code: 1). 选择License server方式，地址填入：https://fls.jetbrains-agent.com （HTTP也可用，网络不佳用第2种方式） 2). 选择Activation code方式离线激活，请使用：ACTIVATION_CODE.txt 内的注册码激活 License key is in legacy format == Key invalid，表示agent配置未生效。 如果你需要自定义License name，请访问：https://zhile.io/custom-license.html 3). 现在你可以使用jetbrains-agent + activation code/license server激活jetbrains平台的付费插件了！ 现有Jetbrains付费插件Activation code: https://zhile.io/jetbrains-paid-plugins-license.html 现在有这些付费插件：https://plugins.jetbrains.com/search?isPaid=true 本项目在最新2020.1上测试通过。理论上适用于目前Jetbrains全系列所有新老版本。IDE升级会从旧版本导入以上设置，导入配置后可能提示未注册（因为刚导入的vmoptions未生效），直接重启IDE即可，无需其他操作。 本项目只做学习研究之用，不得用于商业用途！","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"BeanUtils工具类的使用","slug":"BeanUtils工具类的使用","date":"2020-04-11T07:17:27.000Z","updated":"2020-07-19T07:33:52.661Z","comments":true,"path":"2020/04/11/BeanUtils工具类的使用/","link":"","permalink":"http://yoursite.com/2020/04/11/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"BeanUtils工具类，简化数据封装","text":"BeanUtils工具类，简化数据封装 用于封装JavaBean的JavaBean：标准Java类要求： 1.类必须被public修饰 2.必须提供空参的构造器 3.成员变量必须使用private修饰 4.提供公共的setter和getter方法功能：封装数据下载点解链接下载 BeanUtils工具常用工具类有两个：BeanUtils、ConvertUtils。BeanUtils用于封装数据 方法 描述 BeanUtils对象 populate(Object bean, Map&lt;String,String[]&gt;properties) 将Map数据封装到指定Javabean中，一般用于将表单的所有数据封装到javabean setProperty(Object obj,String name,Object value) 设置属性值 getProperty(Object obj,String name) 获得属性值 代码123456789101112&#x2F;&#x2F;获取所有请求参数 Map&lt;String,String[]&gt; map &#x3D; req.getParameterMap (); &#x2F;&#x2F;创建User对象 User loginuser &#x3D; new User(); &#x2F;&#x2F;使用BeanUtils try &#123; BeanUtils.populate(loginuser,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"http的request对象和response对象","slug":"http","date":"2020-04-10T04:53:03.000Z","updated":"2020-07-19T07:34:01.435Z","comments":true,"path":"2020/04/10/http/","link":"","permalink":"http://yoursite.com/2020/04/10/http/","excerpt":"http的request对象和response对象","text":"http的request对象和response对象 概念：Hyper Text Transfer Protocol 超文本传输协议特点： 1.基于TCP/IP的高级协议 2.默认端口号8080 3.基于请求/相应模型：一次请求对应一次相应 4.无状态的：每次请求直接相互独立 请求消息的数据格式 1.请求行 请求方式 请求url 请求协议/版本 请求方式： GET 1.请求参数在请求行中，在url后面 2.请求url的长度有限 3.不太安全 POST 1.请求参数在请求体中 2.请求url长度没有限制 3.相对安全 2.请求头 3.请求空行 4.请求体 请求消息数据格式Request request和response对象的原理 1.request和response对象由服务器创建，我蛮来使用他们 2.request对象是来获取请求消息，response是来设置相应消息 request获取请求消息 获取请求行的数据 GET /test/demo1?name=zhangsan HTTP/1.1 1.获取请求方式 GET String getMethod() 2.获取虚拟目录 /test String getContextPath() 3.获取Servlet路径 /demo1 String getServletPath() 4.获取get方式请求传参 name=zhangsan String getQueryString() 5.获取URI /test/demo1 String getRequestURI() 6.获取协议及版本 HTTP/1.1 String getProtocol() 7.获取客户机的ip地址 String getRemoteAddr() 获取请求头的方法 String getHeader(String name)通过获取请求头的名称，获取请求头的值 获取请求体数据 只有post请求方式，才有请求体，在请求体中封装了post请求的请求参数 步骤： 1.获取流对象 BufferedReader getReader():获取字符输入流 ServletInputStream getInputStream():获取字节输入流 2.再从流对象中拿数据 获取请求参数的通用方法 1.String getParameter(String name):根据参数名称获取参数值 2.String[] getParameterValues(String name):根据参数名称获取参数值的数组 3.Enumeration&lt;String&gt; getParameterNames():获取所有请参数的名称 4.Map&lt;String,String[]&gt; getParameterMap():获取参数的所有Map集合12&#x2F;&#x2F;设置流的编码 防止乱码 req.setCharacterEncoding(&quot;utf-8&quot;); 请求转发：一种在服务器内部资源的跳转方式 步骤： 1.通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2.使用RequestDispatcher对象进行转发，forword(ServletRequest req,ServletRespnonse resp) 特点： 1.浏览器地址栏不发生变化 2.只能转发到当前服务器内部资源中 3.转发是一次请求 数据共享域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用域请求转发的多个资源中共享数据 方法： 1.void setAttribute(String name,Object obj):存储数据 2.Object getAttribute(String name):通过键获取值 3.void removeAttribute(String name):通过键来移除键值对获取ServletContext对象ServletContext getServletContext()响应消息相应消息的数据格式 1.相应行 组成：协议/版本 相应状态码 状态码描述 状态码分类： 1.1XX:服务器接收客户端消息，但没有接收完全，等待一段时间后，发送1XX 2.2XX:成功。200 3.3XX:重定向 302(重定向) 304(访问缓存) 4.4XX:客户端错误 404(请求路径没有对应的资源) 405(请求方式没有对应的doXXX方法) 5.5XX:服务器端错误 500(服务器内部出现异常) 2.相应头 1.格式:头名称:值 2.常见的相应头: 1.Content-Type:服务器告诉客户端本次相应体数据格式以及编码格式 2.Content-disposition:服务器告诉客户端以什么格式打开相应数据 3.相应空行 4.相应体 Response对象功能:设置相应消息 设置相应行 设置状态码:setStatus(int sc) 设置相应头 setHeader(String name,string value) 设置相应体 使用步骤: 1.获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutputStream() 2.使用输出流，将数据输出到客户端浏览器 完成重定向代码实现 12&#x2F;&#x2F;简单的重定向的方法 resp.sendRedirect(&quot;&#x2F;ReaponseDemo_war_exploded&#x2F;responseDemo2&quot;); 特点: 1.地址栏发生变化 2.重定向可以访问其他站点 3.重定向是两次请求，不能使用request对象来共享数据 路径的写法 相对路径:不可以确定唯一资源 规则:.开头 找到当前资源和目标资源之间的相对位置关系 据对路径:可以确定唯一资源 服务器输出字符数据到浏览器步骤: 1.获取字符输出流 2.输出数据防止乱码 1234resp.setHeader(&quot;content-type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);&#x2F;&#x2F;简单的形式设计编码 resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); ServletContext对象1.概念:代表整个web应用，可以和程序的容器(服务器)通信 2.获取: 1.通过request对象获取request.getServletContext() 2.通过HttpServlet获取this.getServletContext 3.功能: 1.获取MIME类型 MIME类型:在互联网通信过程中定义的一种文件类型 格式:大类型/小类型 text/html 获取: `String getMineType(String file)` 代码示例 12345678ServletContext context &#x3D; this.getServletContext(); &#x2F;&#x2F;定义文件名称String filename &#x3D; &quot;a.jpg&quot;; &#x2F;&#x2F;获取MIME类型String MimeType &#x3D; context.getMimeType(filename);System.out.println(MimeType); 2.域对象:共享数据 1.setAttribute(String name,String value) 2.getAttribute(String name) 3.removeAttribute(String name) ServletContext对象范围:所有用户请求的数据 3.获取文件的真实服务器路径 1.方法:String getRealPath() 案例文件下载需求: 1.页面显示超链接 2.点击链接后弹出下载提示框 3.完成图片文件下载123456789101112131415161718192021222324@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; &#x2F;&#x2F;获取请求参数 文件名称 String filename &#x3D; req.getParameter(&quot;filename&quot;); &#x2F;&#x2F;使用字节输入流，加载文件进内存 ServletContext context &#x3D; this.getServletContext(); String realPath &#x3D; context.getRealPath(&quot;&#x2F;img&#x2F;&quot;+filename);&#x2F;&#x2F;获取文件真实路径 FileInputStream fis &#x3D; new FileInputStream(realPath); &#x2F;&#x2F;设置Response的相应头 String mineType &#x3D; context.getMimeType(filename);&#x2F;&#x2F;获取文件的MIME类型 resp.setHeader(&quot;content-type&quot;,mineType); resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename); &#x2F;&#x2F;将输入流的数据写出到输出流 ServletOutputStream sos &#x3D; resp.getOutputStream(); byte[] bytes &#x3D; new byte[1024]; int len &#x3D; 0; while ((len&#x3D;fis.read(bytes))!&#x3D;-1)&#123; sos.write(bytes,0,len); &#125; fis.close(); &#125;","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"tomcat及Servlet","slug":"tomcat及Servlet","date":"2020-04-08T06:47:13.000Z","updated":"2020-07-19T07:35:33.300Z","comments":true,"path":"2020/04/08/tomcat及Servlet/","link":"","permalink":"http://yoursite.com/2020/04/08/tomcat%E5%8F%8AServlet/","excerpt":"Tomcat","text":"Tomcat 安装tomcat进入官网，个人推荐下载解压版，方便快捷 解压到工作目录后就可以使用了 进入bin目录 双击startup.bat linux打开.sh 可能遇到的两个问题 双击之后没有启动tomcat 黑窗口秒关闭—-JAVA_HOME的环境变量没有没配置好 运行日志乱码—-打开cd到tomcat/conf/目录下修改logging.properties找到 java.util.logging.ConsoleHandler.encoding = utf-8 这行将utf-8改为GBK 部署项目 1.直接将项目放到webapps目录下即可 /hello :项目访问的路径—-&gt;虚拟目录将项目打包成一个war包，再将war包放到webapps目录下 war包会自动解压 2.配置conf/server.xml 在标签体中配置 docBase：项目存放的路径 path:虚拟目录 3.在conf\\Catalina\\localhost创建任意名称的xml文件，在文件中编写 `&lt;Context docBase=&quot;D:\\hello&quot;&gt;` 虚拟目录就是文件的名称 静态项目和动态项目：目录结构： --项目的根目录 --WEB-INF目录 --web.xml:web项目的核心配置文件 --classes目录：放置字节码文件的目录 --lib目录：防止依赖的jar包Servlet 概念：server applet 运行在服务器端的小程序 servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则步骤：1.创建javaEE项目 2.定义一个类，实现Servlet接口 3.实现接口中的抽象方法 4.配置 Servlet---- 在web.xml中配置 配置代码12345678&lt;servlet&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;servlet-class&gt;cn.test.web.Servlet.ServletDemo1&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;&lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 执行原理 1.当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的Servlet的资源路径 2.查找web.xml文件，是否有对应的标签体内容 3.如果有，则再找到对应的全类名 4.tomcat会将字节码文件加载进内存，并创建其对象 5.调用方法Servlet的生命周期 1.被创建：执行init方法，只执行一次 2.提供服务：执行servlet方法，执行多次 3.被销毁：执行destroy方法，执行一次 Servlet3.0支持注解文件配置，可以不需要web.xml 步骤： 1.创建javaEE的项目，选择Servlet的版本 3.0以上，可以不勾选web.xml 2.定义一个类，实现Servlet接口 3.重写方法 4.在类上使用一个注解 @WebServlet(&quot;资源路径&quot;)Servlet的体系结构 Servlet 接口 GenericServlet 抽象类 将Servlet接口的其他方法做了默认实现，只将service()方法作为抽象 HttpServlet 抽象类 对HTPP协议的一种封装，简化操作 1.定义类继承HttpServlet 2.复写doGet/doPost方法 Servlet相关配置 1.urlpartten：Servlet访问的路径 1.一个Servlet可以定义多个访问路径:WebServlet({&quot;/d4&quot;,&quot;Demo4&quot;}) 2.路径的定义规则：/XXX，/XXX，*.do","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"XML解析器","slug":"XML解析器","date":"2020-04-07T11:24:23.000Z","updated":"2020-07-19T07:35:41.363Z","comments":true,"path":"2020/04/07/XML解析器/","link":"","permalink":"http://yoursite.com/2020/04/07/XML%E8%A7%A3%E6%9E%90%E5%99%A8/","excerpt":"解析：操作xml文档，将文档中的数据读取到内存中","text":"解析：操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式： DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树* 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 SAX：逐行读取，基于事件驱动的。* 优点：不占内存。 * 缺点：只能读取，不能增删改 xml常见的解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。快速入门：步骤： 1.导入jar包—-链接：https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw提取码：6sg6 下载完成后解压，将jsoup-1.11.2.jar 和 JsoupXpath-0.3.2.jar(后面Jsoup_Xpath查询会用到，现在一块导入) ，压缩包包括jsoup-1.11.2-javadoc、jsoup-1.11.2.jar、jsoup-1.11.2-javadoc.jar、jsoup-1.11.2-sources.jar、JsoupXpath-0.3.2.jar 2 获取Document对象 3.获取对应的标签Element对象 4.获取数据 代码 123456789101112131415161718192021222324import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;public class Demo1 &#123; public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F;获取Document对象，根据XML文档获取 &#x2F;&#x2F;获取student.xml的path String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); &#x2F;&#x2F;获取元素对象 Element Elements elements &#x3D; document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); &#x2F;&#x2F;获取第一个name的Element对象 Element element &#x3D; elements.get(0); &#x2F;&#x2F;获取数据 String name &#x3D; element.text(); System.out.println(name); &#125;&#125; studen.xml文件中的代码 version123456789101112&lt;users&gt; &lt;user id&#x3D;&#39;1&#39;&gt; &lt;name id&#x3D;&quot;0001&quot;&gt;张三&lt;&#x2F;name&gt; &lt;age&gt;23&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt; &lt;user id&#x3D;&#39;2&#39;&gt; &lt;name&gt;李四&lt;&#x2F;name&gt; &lt;age&gt;30&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt;&lt;&#x2F;users&gt; 对象的使用：1. Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。 parse​(String html)：解析xml或html字符串 parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList来使用4. Element：元素对象 1.获取子元素对象 getElementById​(String id)：根据id属性值获取唯一的element对象 getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式： selector:选择器 使用的方法：Elements select​(String cssQuery)cssQuery按照以前css选择器名字来做 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 示例代码： 1234567891011121314151617181920212223242526272829package Jsoup;import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;import cn.wanghaomiao.xpath.model.JXDocument;import cn.wanghaomiao.xpath.model.JXNode;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import java.io.File;import java.io.IOException;import java.util.List;public class Demo5 &#123; public static void main(String[] args) throws IOException, XpathSyntaxErrorException &#123; String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象 Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;); JXDocument jxDocument &#x3D; new JXDocument(document);&#x2F;&#x2F; List&lt;JXNode&gt; users &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;);&#x2F;&#x2F; for (JXNode j:users)&#123;&#x2F;&#x2F; System.out.println(j);&#x2F;&#x2F; &#125; List&lt;JXNode&gt; list &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;); for (JXNode jxNode:list)&#123; System.out.println(jxNode); &#125; &#125;&#125; ```","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"python爬虫","slug":"python爬虫","date":"2020-04-06T10:21:00.000Z","updated":"2020-05-17T07:43:40.587Z","comments":true,"path":"2020/04/06/python爬虫/","link":"","permalink":"http://yoursite.com/2020/04/06/python%E7%88%AC%E8%99%AB/","excerpt":"scrapy爬虫框架的安装","text":"scrapy爬虫框架的安装 用pip install scrapy命令安装会提示失败，是因为缺少twisted程序进入官网 按住ctrl+f 查找关键字下载好与python版本配对的文件用命令安装下载好的文件 注意路径最好不要太长 否则容易报错安装好插件以后用命令pip install scrapy安装框架安装好以后用命令’scrapy’查看版本出现以上代码说明安装成功","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"搭建个人博客及其部署","slug":"安装Hexo环境","date":"2020-04-06T08:17:01.000Z","updated":"2020-05-18T12:17:57.429Z","comments":true,"path":"2020/04/06/安装Hexo环境/","link":"","permalink":"http://yoursite.com/2020/04/06/%E5%AE%89%E8%A3%85Hexo%E7%8E%AF%E5%A2%83/","excerpt":"特别鸣up主CodeSheep","text":"特别鸣up主CodeSheep 基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。安装Node.js官网建议下载第一个安装步骤非常简单，一直next，下一步就可以了，默认安装就行。 安装git官网然后我们选择windows版本的下载安装也是一直点下一步，安装官方默认的来就行，安装完了，在开始菜单可以看到 安装hexo创建一个工作目录 比如在c盘建一个blog文件夹用管理员属性打开cmd cd到工作目录使用npm 安装hexonpm install -g hexo-cli输入hexo -v判断hexo是否安装成功输入hexo init初始化一个博客这里是hexo常用的命令 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 输入hexo s之后可以进入http://localhost:4000/这个地址查看我们的博客 部署服务器这里我们选用的部署到github上面首先新建一个github的仓库这里的name一定要填自己的用户名.github.io 不然会出问题去工作目录找到_config.yml这个文件 双击打开 我这里使用vscode打开的 用notepad++ 文本打开都可以红线换成自己的github用户名就行了 其他两行按照这个填写安装 hexo-deployer-git。npm install hexo-deployer-git --save部署一下就好了 123hexo cleanhexo ghexo d 这样你就可以通过自己的git仓库的域名访问你自己的博客了同样还可以部署在码云和coding上这个可以加快访问的速度 开启github pages服务，绑定域名如果你觉域名比较难记，可以自己去申请一个域名 这里我们以腾讯云为例，前提是我已经申请好了点击解析域名最好添加一个主机记录为@记录类型为CNAME类型，记录值写自己github仓库的地址名。 接下来配置github的 pages服务 找到博客对应的仓库，点击setting 下滑找到Github Pages，填入自己的域名，点击save保存 这样就可以通过自己的域名访问呢了","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"JWT","slug":"JWT","permalink":"http://yoursite.com/tags/JWT/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}