<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BeanUtils工具类的使用</title>
    <url>/2020/04/11/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="BeanUtils工具类，简化数据封装"><a href="#BeanUtils工具类，简化数据封装" class="headerlink" title="BeanUtils工具类，简化数据封装"></a>BeanUtils工具类，简化数据封装</h3><a id="more"></a>
<h4 id="用于封装JavaBean的"><a href="#用于封装JavaBean的" class="headerlink" title="用于封装JavaBean的"></a>用于封装JavaBean的</h4><pre><code>JavaBean：标准Java类</code></pre><h4 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h4><ul>
<li>1.类必须被public修饰</li>
<li>2.必须提供空参的构造器</li>
<li>3.成员变量必须使用private修饰</li>
<li>4.提供公共的setter和getter方法<h4 id="功能：封装数据"><a href="#功能：封装数据" class="headerlink" title="功能：封装数据"></a>功能：封装数据</h4><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4>点解<a href="http://commons.apache.org/proper/commons-beanutils/download_beanutils.cgi" target="_blank" rel="noopener">链接</a>下载<br><img src="/img/BeanUtils1.png" alt="点这个"></li>
</ul>
<p>BeanUtils工具常用工具类有两个：BeanUtils、ConvertUtils。BeanUtils用于封装数据</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BeanUtils对象</td>
<td>populate(Object bean, Map&lt;String,String[]&gt;properties)</td>
<td>将Map数据封装到指定Javabean中，一般用于将表单的所有数据封装到javabean</td>
</tr>
<tr>
<td></td>
<td>setProperty(Object obj,String name,Object value)</td>
<td>设置属性值</td>
</tr>
<tr>
<td></td>
<td>getProperty(Object obj,String name)</td>
<td>获得属性值</td>
</tr>
</tbody></table>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取所有请求参数</span><br><span class="line">        Map&lt;String,String[]&gt; map &#x3D; req.getParameterMap ();</span><br><span class="line">        &#x2F;&#x2F;创建User对象</span><br><span class="line">        User loginuser &#x3D; new User();</span><br><span class="line">        &#x2F;&#x2F;使用BeanUtils</span><br><span class="line">        try &#123;</span><br><span class="line">            BeanUtils.populate(loginuser,map);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter过滤器</title>
    <url>/2020/04/23/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h2><a id="more"></a>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul>
<li>1.定义一个类，实现Filter</li>
<li>2.复写方法</li>
<li>3.配置拦截路径</li>
</ul>
<h5 id="web-xml的配置"><a href="#web-xml的配置" class="headerlink" title="web.xml的配置"></a>web.xml的配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;cn.filter.demo1&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&#x2F;&#x2F;拦截路径</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h4 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h4><ul>
<li>1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次用于加载资源</li>
<li>2.doFilter:每次拦截资源时被执行，执行很多次。</li>
<li>3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。执行一次，用于释放资源。</li>
</ul>
<h4 id="拦截路径的配置"><a href="#拦截路径的配置" class="headerlink" title="拦截路径的配置"></a>拦截路径的配置</h4><ul>
<li>1.具体的资源路径:/index.jsp    只有访问index.jsp资源时，过滤器才会被执行</li>
<li>2.目录拦截:  /user/*    访问/user下的所有资源时，过滤器都会被执行</li>
<li>3.后缀名拦截： *.jsp   访问所有后缀名为jsp的资源时，过滤器都会被执行</li>
<li>4.拦截所有资源： /*    访问所有资源时，过滤器都会被执行</li>
</ul>
<h4 id="拦截方式的配置"><a href="#拦截方式的配置" class="headerlink" title="拦截方式的配置"></a>拦截方式的配置</h4><pre><code>注解配置：
    1.REQUEST:默认值 浏览器直接请求资源
    2.FORWARD:转发访问资源
    3.INCLUDE:包含访问资源
    4.ERROR:错误跳转
    5.ASYNC:异步访问资源 </code></pre><h4 id="过滤器先后顺序问题"><a href="#过滤器先后顺序问题" class="headerlink" title="过滤器先后顺序问题"></a>过滤器先后顺序问题</h4><pre><code>1.注解配置:按照类名的字符串比较规则比较，值小的先执行
2.web.xml配置:&lt;filter-mappping&gt;谁定义在前面，谁先执行</code></pre><h4 id="登录案例"><a href="#登录案例" class="headerlink" title="登录案例"></a>登录案例</h4><h5 id="判断是否登录"><a href="#判断是否登录" class="headerlink" title="判断是否登录"></a>判断是否登录</h5><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><pre><code>1.判断是否是登录的相关资源
* 是 直接放行
* 不是 判断是否登录
2.判断当前用户是否登录，判断Session是否有user
* 有  已经登录  放行
* 没有  没有登录   跳转到登录页面</code></pre><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.test.web.filter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 登录验证的过滤器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@WebFilter(&quot;&#x2F;*&quot;)</span><br><span class="line">public class loginFilter implements Filter &#123;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;0.强制转换</span><br><span class="line">        HttpServletRequest request &#x3D; (HttpServletRequest) req;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.获取请求资源的路径</span><br><span class="line">        String uri &#x3D; request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.判断是否包含登录相关的路径</span><br><span class="line">        if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;&#x2F;loginServlet&quot;) || uri.contains(&quot;&#x2F;checkcodeServlet&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;))&#123;</span><br><span class="line">            &#x2F;&#x2F;放行</span><br><span class="line">            chain.doFilter(req, resp);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;不包含  需要验证用户是否登录</span><br><span class="line">            &#x2F;&#x2F;从Session获取user</span><br><span class="line">            Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">            if (user!&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;登录了  放行</span><br><span class="line">                chain.doFilter(req, resp);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                &#x2F;&#x2F;没有登录  跳转登录页面</span><br><span class="line">                request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;);</span><br><span class="line">                request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="敏感词汇过滤"><a href="#敏感词汇过滤" class="headerlink" title="敏感词汇过滤"></a>敏感词汇过滤</h4><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><pre><code>1.对request对象进行增强。增强获取参数相关方法
2.放行。爨地代理对象</code></pre><h5 id="增强对象的功能"><a href="#增强对象的功能" class="headerlink" title="增强对象的功能"></a>增强对象的功能</h5><pre><code>设计模式：一些通用的解决固定问题的方式
* 1.装饰模式
* 2.代理模式

实现步骤：
    - 1.代理对象和真实对象实现相同的接口
    - 2.代理对象  =  Proxy.newProxyInstance();
    - 3.使用代理对象调用方法
    - 4.增强方法 
增强方式：
    - 1.增强参数列表
    - 2.增强返回值类型
    - 3.增强方法体执行逻辑</code></pre><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.test.web.filter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 敏感词汇过滤器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@WebFilter(&quot;&#x2F;*&quot;)</span><br><span class="line">public class sensitiveWordsFilter implements Filter &#123;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建代理对象，增强getParameter方法</span><br><span class="line">        ServletRequest proxy_req &#x3D; (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                &#x2F;&#x2F;判断是否是getParameter</span><br><span class="line">                if (method.getName().equals(&quot;getParameter&quot;))&#123;</span><br><span class="line">                    &#x2F;&#x2F;增强返回值</span><br><span class="line">                    &#x2F;&#x2F;获取返回值</span><br><span class="line">                    String value &#x3D; (String) method.invoke(req,args);</span><br><span class="line">                    if (value !&#x3D; null)&#123;</span><br><span class="line">                        for (String str:list)&#123;</span><br><span class="line">                            if (value.contains(str))&#123;</span><br><span class="line">                                value &#x3D; value.replaceAll(str,&quot;***&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return value;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;判断是否是getParameterMap</span><br><span class="line">                if (method.getName().equals(&quot;getParameterMap&quot;))&#123;</span><br><span class="line">                    &#x2F;&#x2F;由request得到的原数组不可改变，他是被锁住的，所以这里创建一个新数组来复制原数组，返回新的数组</span><br><span class="line">                    &#x2F;&#x2F;其实想法很想简单，既然传递进来的映射不可改变，那么自己new一个出来不就行了</span><br><span class="line">                    Map&lt;String,String[]&gt; map1 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                    Map&lt;String,String[]&gt; map &#x3D; (Map&lt;String, String[]&gt;) method.invoke(req,args);</span><br><span class="line">                    Set&lt;String&gt; keySet &#x3D; map.keySet();</span><br><span class="line"></span><br><span class="line">                    if (keySet !&#x3D; null)&#123;</span><br><span class="line">                        for (String str:list)&#123;</span><br><span class="line">                            for (String key:keySet)&#123;</span><br><span class="line">                                String[] values &#x3D; map.get(key);</span><br><span class="line">                                for (int i&#x3D;0;i&lt;values.length;i++)&#123;</span><br><span class="line">                                    String value &#x3D; values[i];</span><br><span class="line">                                    if (value.contains(str))&#123;</span><br><span class="line">                                        value &#x3D; value.replaceAll(str,&quot;***&quot;);</span><br><span class="line">                                        values[i] &#x3D; value;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;map1.put(key,values);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return map1;</span><br><span class="line">                &#125;</span><br><span class="line">                return method.invoke(req,args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;放行</span><br><span class="line">        chain.doFilter(proxy_req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    private List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F;敏感词汇</span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;获取文件真实路径</span><br><span class="line">            ServletContext context &#x3D; config.getServletContext();</span><br><span class="line">            String realPath &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;敏感词汇.txt&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;读取文件</span><br><span class="line">            BufferedReader br &#x3D; new BufferedReader(new FileReader(realPath));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将文件的每一行数据添加到list集合中</span><br><span class="line">            String line &#x3D; null;</span><br><span class="line">            while ((line&#x3D;br.readLine())!&#x3D;null)&#123;</span><br><span class="line">                list.add(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            br.close();&#x2F;&#x2F;释放资源</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery笔记</title>
    <url>/2020/04/26/JQuery%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="JQuery笔记"><a href="#JQuery笔记" class="headerlink" title="JQuery笔记"></a>JQuery笔记</h2><a id="more"></a>
<pre><code>概念：一个JavaScript框架，简化JS开发
使用步骤：
    1.下载JQuery
    2.导入JQuery的js文件  导入min.js
    3.使用
JQuery对象和JS对象的区别
    方法不互通
    转换：
        jq -&gt; js  : jq对象[索引] 或者 jp对象.get(索引)
        js -&gt; jq  : $(js对象)</code></pre><h3 id="选择器：筛选具有相似特征的元素-标签"><a href="#选择器：筛选具有相似特征的元素-标签" class="headerlink" title="选择器：筛选具有相似特征的元素(标签)"></a>选择器：筛选具有相似特征的元素(标签)</h3><h4 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1.基本选择器"></a>1.基本选择器</h4><ul>
<li><p>1.标签选择器(元素选择器)</p>
<pre><code>`$(&quot;html标签名&quot;)`  获得所有匹配标签名称的元素</code></pre></li>
<li><p>2.id选择器</p>
<pre><code>`$(&quot;#id的属性值&quot;)`  获得与指定id值匹配的元素</code></pre></li>
<li><p>3.类选择器</p>
<pre><code>`$(&quot;.class的属性&quot;)`   获得与指定的class属性值相匹配的元素</code></pre><h4 id="2-层级选择器"><a href="#2-层级选择器" class="headerlink" title="2.层级选择器"></a>2.层级选择器</h4></li>
<li><p>1.后代选择器：</p>
<pre><code>`$(&quot;A B&quot;)`  选择A元素所有内部的B元素</code></pre></li>
<li><p>2.子选择器</p>
<pre><code>`$(&quot;A &gt; B&quot;)` 选择A元素内部的所有B子元素</code></pre></li>
<li><p>3.属性选择器</p>
<pre><code>1.属性名称选择器
$(&quot;A[属性名]&quot;)    包含指定属性的选择器
2.属性选择器
$(&quot;A[属性名=&apos;值&apos;]&quot;)   包含指定属性等于指定值的选择器
3.符合属性选择器
$(&quot;A[属性名=&apos;值&apos;][ ]...&quot;)   包含多个属性条件的选择器</code></pre></li>
<li><p>4.过滤选择器</p>
<pre><code>1.首元素选择器
    :first  获得选择的元素中第一个元素
2.尾元素选择器
    :last  获得选择的元素中最后一个元素
3.非元素选择器
    not(.selector)   不包括指定内容的元素
4.偶数选择器
    even   偶数，从0开始计数
5.奇数选择器
    odd  奇数 ，从0开始
6.等于索引选择器
    eq(index)  指定索引元素
7.大于索引选择器
    gt(index)  大于指定索引选择器
8.小于索引选择器
    lt(index)  小于指定索引选择器
9.标题选择器
    header  获得标题(h1-h6)元素，固定写法</code></pre></li>
<li><p>5.表单过滤选择器</p>
<pre><code>1.可用元素选择器
    :enabled  获得可用元素
2.不可以用元素选择器
    :disabled  获得不可用元素
3.选中选择器
    :checked  获得单选，复选框中的元素
4.选中选择器
    :selected   获得下拉框中选中的元素</code></pre></li>
</ul>
<h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><h4 id="1-内容操作"><a href="#1-内容操作" class="headerlink" title="1.内容操作"></a>1.内容操作</h4><ul>
<li><p>1.<code>html()</code> ： 获取/设置元素的标签体内容， <a><font>内容</font></a> –&gt;  <font>内容</font></p>
</li>
<li><p>2.<code>text()</code>  ： 获取/设置元素标签体纯文本内容  <a><font>内容</font></a> –&gt;  内容</p>
</li>
<li><p>3.<code>val()</code>  :   获取/设置元素的属性值</p>
<h4 id="2-属性操作"><a href="#2-属性操作" class="headerlink" title="2.属性操作"></a>2.属性操作</h4></li>
<li><p>1.通用属性操作</p>
<pre><code>1.attr()                  获取/设置元素的属性
2.removeAttr()     删除属性
3.prop()                获取/设置元素的属性
4.removeProp()    删除属性
*attr和prop的区别
    如果操作的是元素的固有属性，则建议使用prop
    如果操作的是元素的自定义属性，则建议是attr</code></pre></li>
<li><p>2.对class属性操作 </p>
<pre><code>    1.addClass()      添加class属性值
    2.removeClass() 删除class属性值
    3.toggleClass()   切换class属性值
3.CRUD操作
    1.append(): 父元素将子元素追加到末尾
            - 对象1.append(对象2)：将对象2添加到对象1元素内部，并且在末尾
    2.prepend():父元素将子元素追加到开头
            -对象1.prepend(对象2)：将对象2添加到对象1元素内部，并且在开头
    3.appendto():
    4.prependto():

    5.after():添加元素到元素后边
    6.before()：将元素添加到元素前边
    7.insertAfter():
    8.insertBrfore():
    9.remove()：删除元素
    10.empty()：清空元素的所有后代元素</code></pre><h3 id="JQuery高级"><a href="#JQuery高级" class="headerlink" title="JQuery高级"></a>JQuery高级</h3><h4 id="1-动画"><a href="#1-动画" class="headerlink" title="1.动画"></a>1.动画</h4></li>
<li><p>1.三种方式显示和隐藏元素</p>
<pre><code>1.show([speed,[easing],[fn]])
2.hide([speed,[easing],[fn]])
3.toggle([speed],[easing],[fn])</code></pre></li>
<li><p>2.滑动显示和隐藏方式</p>
<pre><code>1.slideDown([speed],[easing],[fn])
2.slideUp([speed,[easing],[fn]])
3.slieToggle([speed],[easing],[fn])</code></pre></li>
<li><p>3.淡入淡出的显示和隐藏方式</p>
<pre><code>1.fadeIn([speed],[easing],[fn])
2.fadeOut([speed],[easing],[fn])
3.fadeToggle([speed,[easing],[fn]])</code></pre><h4 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h4></li>
<li><p>1.<code>jq对象.each(callback)</code></p>
</li>
<li><p>2.<code>$.each(object,[callback])</code></p>
</li>
<li><p>3.<code>for..of:</code></p>
<h4 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3.事件绑定"></a>3.事件绑定</h4><pre><code> 1.jquery标准的绑定方式
     jq对象.事件方法(回调函数)
 2.on绑定事件/off绑定事件
     jq对象.on(&quot;事件名称&quot;,回调函数)
     jq对象.off(&quot;事件名称&quot;)
3.事件切换
     jq对象.toggle(fn1,fn2...)</code></pre></li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><pre><code>1.当页面加载完后。3秒后，自动显示广告
2.当广告显示5秒后自动消失</code></pre><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;*需求：</span><br><span class="line">         1.当页面加载完后。3秒后，自动显示广告</span><br><span class="line">         2.当广告显示5秒后自动消失</span><br><span class="line">         分析：</span><br><span class="line">         1.使用定时器来完成。setTimeout(执行一次)</span><br><span class="line">         2.JQuery的动画效果就是控制display属性</span><br><span class="line">        *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;入口函数，在页面加载完成后定义定时器，调用这两个方法</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            &#x2F;&#x2F;定时器 调用adShow()方法</span><br><span class="line">            setTimeout(adShow,3000);</span><br><span class="line"></span><br><span class="line">            setTimeout(adHide,8000);</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F;显示广告方法</span><br><span class="line">        function adShow() &#123;</span><br><span class="line">            &#x2F;&#x2F;获取广告div 调用show方法</span><br><span class="line">            $(&quot;#ad&quot;).show(&quot;slow&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;隐藏广告方法</span><br><span class="line">        function adHide() &#123;</span><br><span class="line">            $(&quot;#ad&quot;).hide(&quot;slow&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;ad&quot; style&#x3D;&quot;display: none;&quot;&gt;</span><br><span class="line">        &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;广告.jpg&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id&#x3D;&quot;content&quot;&gt;</span><br><span class="line">        正文部分</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="需求：-1"><a href="#需求：-1" class="headerlink" title="需求："></a>需求：</h4><p>抽奖案例</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;抽奖&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        分析：</span><br><span class="line">        1.给开始按钮绑定单击事件</span><br><span class="line">            1.1定义循环定时器</span><br><span class="line">            1.2切换小相框的src属性</span><br><span class="line">                定义一个数组，存放图片资源的路径</span><br><span class="line">                生成随机数 数组索引</span><br><span class="line">        2.给结束按钮绑定单击事件</span><br><span class="line">            2.1停止定时器</span><br><span class="line">            2.2给大相框设置src属性</span><br><span class="line">         *&#x2F;</span><br><span class="line">        var imgs &#x3D; [&quot;..&#x2F;img&#x2F;1.jpg&quot;,&quot;..&#x2F;img&#x2F;2.jpg&quot;,&quot;..&#x2F;img&#x2F;3.jpg&quot;,&quot;..&#x2F;img&#x2F;4.jpg&quot;,&quot;..&#x2F;img&#x2F;5.jpg&quot;,&quot;..&#x2F;img&#x2F;6.jpg&quot;,&quot;..&#x2F;img&#x2F;0.jpg&quot;]</span><br><span class="line">        var startId;&#x2F;&#x2F;开始定时器的一个Id</span><br><span class="line">        var index;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            &#x2F;&#x2F;开始按钮</span><br><span class="line">            $(&quot;#startID&quot;).click(function () &#123;</span><br><span class="line">                startId &#x3D; setInterval(function () &#123;</span><br><span class="line">                    &#x2F;&#x2F;生成随机角标</span><br><span class="line">                    index &#x3D; Math.floor(Math.random() * 7)</span><br><span class="line">                    &#x2F;&#x2F;设置小相框的src属性</span><br><span class="line">                    $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);</span><br><span class="line">                &#125;,20)</span><br><span class="line">            &#125;)</span><br><span class="line">            &#x2F;&#x2F;结束按钮</span><br><span class="line">            $(&quot;#stopID&quot;).click(function () &#123;</span><br><span class="line">                $(&quot;#stopID&quot;).click(function () &#123;</span><br><span class="line">                    &#x2F;&#x2F;停止定时器</span><br><span class="line">                    clearInterval(startId)</span><br><span class="line">                    $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--小相框--&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;border-style: dotted;width: 160px;height: 100px;&quot;&gt;</span><br><span class="line">    &lt;img id&#x3D;&quot;img1ID&quot; style&#x3D;&quot;width: 160px;height: 100px&quot; src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--大相框--&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;border-style: dotted;height: 500px;position: absolute;left: 500px;top: 10px&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot; id&#x3D;&quot;img2ID&quot; width&#x3D;&quot;800px&quot;height&#x3D;&quot;600px&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--开始按钮--&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;startID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击开始&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--停止按钮--&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;stopID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击停止&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains系列产品2020.1最新激活方法</title>
    <url>/2020/04/15/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812020-1%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。</p>
<a id="more"></a>

<p>大家熟知Jetbrains的话应该知道：他们家的所有产品升级到2018.2.1及以上版本后，先前可用的注册服务器都失效了，无法激活升级到最新版本体验最新黑科技。</p>
<p>这次要送的这份礼就是： Jetbrains全系列产品2020.1及以下版本（理论上适用于目前所有新老版本）最新注册服务器（License Server）的破解，可使用它来激活你手头上的Jetbrains IDE，具体支持产品和版本见下文的列表。</p>
<p>传送门:</p>
<p><a href="https://pan.baidu.com/s/1W7NDVhEd6J6mpN3-PoXFQA" target="_blank" rel="noopener">百度云下载</a>    提取码：w26y </p>
<hr>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><ul>
<li><p>0.先下载压缩包解压后得到jetbrains-agent.jar。</p>
</li>
<li><p>1.启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。</p>
<ul>
<li>2.将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。（事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题）</li>
<li>3.在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。</li>
<li>4.重启IDE，搞定。</li>
<li>x. 支持两种注册方式：License server 和 Activation code:<ul>
<li>1). 选择License server方式，地址填入：<a href="https://fls.jetbrains-agent.com" target="_blank" rel="noopener">https://fls.jetbrains-agent.com</a> （HTTP也可用，网络不佳用第2种方式）</li>
<li>2). 选择Activation code方式离线激活，请使用：ACTIVATION_CODE.txt 内的注册码激活<br>  License key is in legacy format == Key invalid，表示agent配置未生效。<br>  如果你需要自定义License name，请访问：<a href="https://zhile.io/custom-license.html" target="_blank" rel="noopener">https://zhile.io/custom-license.html</a></li>
<li>3). 现在你可以使用jetbrains-agent + activation code/license server激活jetbrains平台的付费插件了！<br>  现有Jetbrains付费插件Activation code: <a href="https://zhile.io/jetbrains-paid-plugins-license.html" target="_blank" rel="noopener">https://zhile.io/jetbrains-paid-plugins-license.html</a><br>  现在有这些付费插件：<a href="https://plugins.jetbrains.com/search?isPaid=true" target="_blank" rel="noopener">https://plugins.jetbrains.com/search?isPaid=true</a></li>
</ul>
</li>
</ul>
<p>本项目在最新2020.1上测试通过。<br>理论上适用于目前Jetbrains全系列所有新老版本。<br>IDE升级会从旧版本导入以上设置，导入配置后可能提示未注册（因为刚导入的vmoptions未生效），直接重启IDE即可，无需其他操作。</p>
</li>
</ul>
<p> 本项目只做学习研究之用，不得用于商业用途！</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>XML解析器</title>
    <url>/2020/04/07/XML%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h3 id="解析：操作xml文档，将文档中的数据读取到内存中"><a href="#解析：操作xml文档，将文档中的数据读取到内存中" class="headerlink" title="解析：操作xml文档，将文档中的数据读取到内存中"></a>解析：操作xml文档，将文档中的数据读取到内存中</h3><a id="more"></a>
<h4 id="操作xml文档"><a href="#操作xml文档" class="headerlink" title="操作xml文档"></a>操作xml文档</h4><ul>
<li><ol>
<li>解析(读取)：将文档中的数据读取到内存中</li>
</ol>
</li>
<li><ol start="2">
<li>写入：将内存中的数据保存到xml文档中。持久化的存储</li>
</ol>
</li>
</ul>
<h3 id="解析xml的方式："><a href="#解析xml的方式：" class="headerlink" title="解析xml的方式："></a>解析xml的方式：</h3><ul>
<li><ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<pre><code>* 优点：操作方便，可以对文档进行CRUD的所有操作
* 缺点：占内存</code></pre></li>
</ol>
</li>
<li><ol start="2">
<li>SAX：逐行读取，基于事件驱动的。<pre><code>* 优点：不占内存。
* 缺点：只能读取，不能增删改</code></pre></li>
</ol>
</li>
</ul>
<h3 id="xml常见的解析器："><a href="#xml常见的解析器：" class="headerlink" title="xml常见的解析器："></a>xml常见的解析器：</h3><ul>
<li><ol>
<li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li>
</ol>
</li>
<li><ol start="2">
<li>DOM4J：一款非常优秀的解析器</li>
</ol>
</li>
<li><ol start="3">
<li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li>
</ol>
</li>
<li><ol start="4">
<li>PULL：Android操作系统内置的解析器，sax方式的。</li>
</ol>
</li>
</ul>
<ul>
<li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<h4 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h4><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5></li>
</ul>
<ul>
<li>1.导入jar包—-链接：<a href="https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw" target="_blank" rel="noopener">https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw</a><br>提取码：6sg6 下载完成后解压，将jsoup-1.11.2.jar 和 JsoupXpath-0.3.2.jar(后面Jsoup_Xpath查询会用到，现在一块导入)   ，压缩包包括jsoup-1.11.2-javadoc、jsoup-1.11.2.jar、jsoup-1.11.2-javadoc.jar、jsoup-1.11.2-sources.jar、JsoupXpath-0.3.2.jar   </li>
<li>2 获取Document对象</li>
<li>3.获取对应的标签Element对象</li>
<li>4.获取数据     </li>
</ul>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.jsoup.nodes.Document;</span><br><span class="line">import org.jsoup.nodes.Element;</span><br><span class="line">import org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;获取Document对象，根据XML文档获取</span><br><span class="line">        &#x2F;&#x2F;获取student.xml的path</span><br><span class="line">        String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();</span><br><span class="line">        &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象</span><br><span class="line">        Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取元素对象  Element</span><br><span class="line">        Elements elements &#x3D; document.getElementsByTag(&quot;name&quot;);</span><br><span class="line">        System.out.println(elements.size());</span><br><span class="line">        &#x2F;&#x2F;获取第一个name的Element对象</span><br><span class="line">        Element element &#x3D; elements.get(0);</span><br><span class="line">        &#x2F;&#x2F;获取数据</span><br><span class="line">        String name &#x3D; element.text();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line">studen.xml文件中的代码</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;utf-8&#39;?&gt;</span><br><span class="line">&lt;users&gt;</span><br><span class="line">    &lt;user id&#x3D;&#39;1&#39;&gt;</span><br><span class="line">        &lt;name id&#x3D;&quot;0001&quot;&gt;张三&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;23&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;gender&gt;男&lt;&#x2F;gender&gt;</span><br><span class="line">    &lt;&#x2F;user&gt;</span><br><span class="line">    &lt;user id&#x3D;&#39;2&#39;&gt;</span><br><span class="line">        &lt;name&gt;李四&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;30&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;gender&gt;男&lt;&#x2F;gender&gt;</span><br><span class="line">    &lt;&#x2F;user&gt;</span><br><span class="line">&lt;&#x2F;users&gt;</span><br></pre></td></tr></table></figure>


<h3 id="对象的使用："><a href="#对象的使用：" class="headerlink" title="对象的使用："></a>对象的使用：</h3><h4 id="1-Jsoup：工具类，可以解析html或xml文档，返回Document"><a href="#1-Jsoup：工具类，可以解析html或xml文档，返回Document" class="headerlink" title="1. Jsoup：工具类，可以解析html或xml文档，返回Document"></a>1. Jsoup：工具类，可以解析html或xml文档，返回Document</h4><ul>
<li><p>parse：解析html或xml文档，返回Document</p>
</li>
<li><p>parse​(File in, String charsetName)：解析xml或html文件的。</p>
</li>
<li><p>parse​(String html)：解析xml或html字符串</p>
</li>
<li><p>parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象</p>
<h4 id="2-Document：文档对象。代表内存中的dom树"><a href="#2-Document：文档对象。代表内存中的dom树" class="headerlink" title="2. Document：文档对象。代表内存中的dom树"></a>2. Document：文档对象。代表内存中的dom树</h4></li>
<li><p>获取Element对象</p>
</li>
<li><p>getElementById​(String id)：根据id属性值获取唯一的element对象</p>
</li>
<li><p>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</p>
<h4 id="3-Elements：元素Element对象的集合。可以当做-ArrayList来使用"><a href="#3-Elements：元素Element对象的集合。可以当做-ArrayList来使用" class="headerlink" title="3. Elements：元素Element对象的集合。可以当做 ArrayList来使用"></a>3. Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用</h4><h4 id="4-Element：元素对象"><a href="#4-Element：元素对象" class="headerlink" title="4. Element：元素对象"></a>4. Element：元素对象</h4></li>
<li><p>1.获取子元素对象</p>
</li>
<li><p>getElementById​(String id)：根据id属性值获取唯一的element对象</p>
</li>
<li><p>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</p>
</li>
<li><p>获取属性值</p>
</li>
</ul>
<ul>
<li>String attr(String key)：根据属性名称获取属性值</li>
</ul>
<ul>
<li><ol start="3">
<li>获取文本内容</li>
</ol>
</li>
</ul>
<ul>
<li>String text():获取文本内容</li>
<li>String html():获取标签体的所有内容(包括字标签的字符串内容)</li>
</ul>
<ul>
<li><ol start="5">
<li>Node：节点对象</li>
</ol>
</li>
</ul>
<ul>
<li>是Document和Element的父类</li>
</ul>
<h4 id="快捷查询方式："><a href="#快捷查询方式：" class="headerlink" title="快捷查询方式："></a>快捷查询方式：</h4><ul>
<li><ol>
<li>selector:选择器</li>
</ol>
</li>
</ul>
<ul>
<li>使用的方法：Elements    select​(String cssQuery)<br>cssQuery按照以前css选择器名字来做</li>
</ul>
<ul>
<li>语法：参考Selector类中定义的语法</li>
</ul>
<ul>
<li><ol start="2">
<li>XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</li>
</ol>
</li>
</ul>
<ul>
<li>使用Jsoup的Xpath需要额外导入jar包。</li>
<li>查询w3cshool参考手册，使用xpath的语法完成查询</li>
<li>示例代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package Jsoup;</span><br><span class="line"></span><br><span class="line">import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;</span><br><span class="line">import cn.wanghaomiao.xpath.model.JXDocument;</span><br><span class="line">import cn.wanghaomiao.xpath.model.JXNode;</span><br><span class="line">import org.jsoup.Jsoup;</span><br><span class="line">import org.jsoup.nodes.Document;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, XpathSyntaxErrorException &#123;</span><br><span class="line">        String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();</span><br><span class="line">        &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象</span><br><span class="line">        Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;);</span><br><span class="line">        JXDocument jxDocument &#x3D; new JXDocument(document);</span><br><span class="line">&#x2F;&#x2F;        List&lt;JXNode&gt; users &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;);</span><br><span class="line">&#x2F;&#x2F;        for (JXNode j:users)&#123;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(j);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        List&lt;JXNode&gt; list &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;);</span><br><span class="line">        for (JXNode jxNode:list)&#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>http的request对象和response对象</title>
    <url>/2020/04/10/http/</url>
    <content><![CDATA[<h2 id="http的request对象和response对象"><a href="#http的request对象和response对象" class="headerlink" title="http的request对象和response对象"></a>http的request对象和response对象</h2><a id="more"></a>
<h3 id="概念：Hyper-Text-Transfer-Protocol-超文本传输协议"><a href="#概念：Hyper-Text-Transfer-Protocol-超文本传输协议" class="headerlink" title="概念：Hyper Text Transfer Protocol 超文本传输协议"></a>概念：Hyper Text Transfer Protocol 超文本传输协议</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><p>1.基于TCP/IP的高级协议</p>
</li>
<li><p>2.默认端口号8080</p>
</li>
<li><p>3.基于请求/相应模型：一次请求对应一次相应</p>
</li>
<li><p>4.无状态的：每次请求直接相互独立</p>
<h3 id="请求消息的数据格式"><a href="#请求消息的数据格式" class="headerlink" title="请求消息的数据格式"></a>请求消息的数据格式</h3></li>
<li><p>1.请求行</p>
<pre><code>请求方式  请求url  请求协议/版本
请求方式：
    GET
        1.请求参数在请求行中，在url后面
        2.请求url的长度有限
        3.不太安全
    POST
        1.请求参数在请求体中
        2.请求url长度没有限制
        3.相对安全</code></pre></li>
<li><p>2.请求头</p>
</li>
<li><p>3.请求空行</p>
</li>
<li><p>4.请求体 </p>
</li>
</ul>
<h3 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h3><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><ul>
<li><p>request和response对象的原理</p>
<pre><code>1.request和response对象由服务器创建，我蛮来使用他们
2.request对象是来获取请求消息，response是来设置相应消息</code></pre></li>
</ul>
<h5 id="request获取请求消息"><a href="#request获取请求消息" class="headerlink" title="request获取请求消息"></a>request获取请求消息</h5><ul>
<li><p>获取请求行的数据</p>
<pre><code>GET /test/demo1?name=zhangsan HTTP/1.1
1.获取请求方式 GET
String getMethod()
2.获取虚拟目录 /test
String getContextPath()
3.获取Servlet路径 /demo1
String getServletPath()
4.获取get方式请求传参 name=zhangsan 
String getQueryString()
5.获取URI /test/demo1
String getRequestURI()
6.获取协议及版本 HTTP/1.1
String getProtocol()
7.获取客户机的ip地址
String getRemoteAddr()</code></pre></li>
<li><p>获取请求头的方法</p>
<pre><code>String getHeader(String name)通过获取请求头的名称，获取请求头的值 </code></pre></li>
<li><p>获取请求体数据</p>
<pre><code>只有post请求方式，才有请求体，在请求体中封装了post请求的请求参数</code></pre><p>  步骤：</p>
<ul>
<li><p>1.获取流对象</p>
<pre><code>BufferedReader getReader():获取字符输入流
ServletInputStream getInputStream():获取字节输入流</code></pre></li>
<li><p>2.再从流对象中拿数据</p>
</li>
</ul>
</li>
<li><p>获取请求参数的通用方法</p>
<pre><code>1.String getParameter(String name):根据参数名称获取参数值
2.String[] getParameterValues(String name):根据参数名称获取参数值的数组
3.Enumeration&lt;String&gt;  getParameterNames():获取所有请参数的名称
4.Map&lt;String,String[]&gt; getParameterMap():获取参数的所有Map集合</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置流的编码 防止乱码</span><br><span class="line">        req.setCharacterEncoding(&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="请求转发：一种在服务器内部资源的跳转方式"><a href="#请求转发：一种在服务器内部资源的跳转方式" class="headerlink" title="请求转发：一种在服务器内部资源的跳转方式"></a>请求转发：一种在服务器内部资源的跳转方式</h4><ul>
<li><p>步骤：</p>
<pre><code>1.通过request对象获取请求转发器对象：RequestDispatcher  getRequestDispatcher(String path)
2.使用RequestDispatcher对象进行转发，forword(ServletRequest req,ServletRespnonse resp)</code></pre></li>
<li><p>特点：</p>
<pre><code>1.浏览器地址栏不发生变化
2.只能转发到当前服务器内部资源中
3.转发是一次请求</code></pre></li>
</ul>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><pre><code>域对象：一个有作用范围的对象，可以在范围内共享数据
request域：代表一次请求的范围，一般用域请求转发的多个资源中共享数据

方法：
1.void setAttribute(String name,Object obj):存储数据
2.Object  getAttribute(String name):通过键获取值
3.void removeAttribute(String name):通过键来移除键值对</code></pre><h4 id="获取ServletContext对象"><a href="#获取ServletContext对象" class="headerlink" title="获取ServletContext对象"></a>获取ServletContext对象</h4><pre><code>ServletContext getServletContext()</code></pre><h3 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h3><h4 id="相应消息的数据格式"><a href="#相应消息的数据格式" class="headerlink" title="相应消息的数据格式"></a>相应消息的数据格式</h4><ul>
<li><p>1.相应行</p>
<pre><code>组成：协议/版本 相应状态码  状态码描述
状态码分类：
        1.1XX:服务器接收客户端消息，但没有接收完全，等待一段时间后，发送1XX
        2.2XX:成功。200
        3.3XX:重定向  302(重定向) 304(访问缓存)
        4.4XX:客户端错误 404(请求路径没有对应的资源) 405(请求方式没有对应的doXXX方法)
        5.5XX:服务器端错误 500(服务器内部出现异常)</code></pre></li>
<li><p>2.相应头</p>
<pre><code>1.格式:头名称:值
2.常见的相应头:
        1.Content-Type:服务器告诉客户端本次相应体数据格式以及编码格式
        2.Content-disposition:服务器告诉客户端以什么格式打开相应数据</code></pre></li>
<li><p>3.相应空行</p>
</li>
<li><p>4.相应体</p>
</li>
</ul>
<h4 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h4><h5 id="功能-设置相应消息"><a href="#功能-设置相应消息" class="headerlink" title="功能:设置相应消息"></a>功能:设置相应消息</h5><ul>
<li><p>设置相应行</p>
<pre><code>设置状态码:setStatus(int sc)</code></pre></li>
<li><p>设置相应头</p>
<pre><code>setHeader(String name,string value)</code></pre></li>
<li><p>设置相应体</p>
<pre><code>使用步骤:
1.获取输出流
字符输出流:PrintWriter getWriter()
字节输出流:ServletOutputStream  getOutputStream()
2.使用输出流，将数据输出到客户端浏览器</code></pre></li>
</ul>
<h5 id="完成重定向"><a href="#完成重定向" class="headerlink" title="完成重定向"></a>完成重定向</h5><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;简单的重定向的方法</span><br><span class="line">        resp.sendRedirect(&quot;&#x2F;ReaponseDemo_war_exploded&#x2F;responseDemo2&quot;);</span><br></pre></td></tr></table></figure>
<p>特点:</p>
<ul>
<li>1.地址栏发生变化</li>
<li>2.重定向可以访问其他站点</li>
<li>3.重定向是两次请求，不能使用request对象来共享数据</li>
</ul>
<h4 id="路径的写法"><a href="#路径的写法" class="headerlink" title="路径的写法"></a>路径的写法</h4><ul>
<li><p>相对路径:不可以确定唯一资源</p>
<pre><code>规则:.开头  找到当前资源和目标资源之间的相对位置关系</code></pre></li>
<li><p>据对路径:可以确定唯一资源</p>
</li>
</ul>
<h4 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h4><pre><code>步骤:
1.获取字符输出流
2.输出数据</code></pre><p>防止乱码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resp.setHeader(&quot;content-type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;简单的形式设计编码</span><br><span class="line">        resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h4><p>1.概念:代表整个web应用，可以和程序的容器(服务器)通信</p>
<p>2.获取:</p>
<ul>
<li>1.通过request对象获取<br><code>request.getServletContext()</code></li>
<li>2.通过HttpServlet获取<br><code>this.getServletContext</code></li>
</ul>
<p>3.功能:</p>
<ul>
<li><p>1.获取MIME类型</p>
<pre><code>MIME类型:在互联网通信过程中定义的一种文件类型
格式:大类型/小类型   text/html
获取:
`String getMineType(String file)`
代码示例
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletContext context &#x3D; this.getServletContext();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义文件名称</span><br><span class="line">String filename &#x3D; &quot;a.jpg&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取MIME类型</span><br><span class="line">String MimeType &#x3D; context.getMimeType(filename);</span><br><span class="line">System.out.println(MimeType);</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>2.域对象:共享数据</p>
<pre><code>1.setAttribute(String name,String value)
2.getAttribute(String name)
3.removeAttribute(String name)
ServletContext对象范围:所有用户请求的数据</code></pre></li>
<li><p>3.获取文件的真实服务器路径</p>
<pre><code>1.方法:String getRealPath()</code></pre></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>文件下载需求:</p>
<ul>
<li>1.页面显示超链接</li>
<li>2.点击链接后弹出下载提示框</li>
<li>3.完成图片文件下载<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       &#x2F;&#x2F;获取请求参数  文件名称</span><br><span class="line">       String filename &#x3D; req.getParameter(&quot;filename&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;使用字节输入流，加载文件进内存</span><br><span class="line">       ServletContext context &#x3D; this.getServletContext();</span><br><span class="line">       String realPath &#x3D; context.getRealPath(&quot;&#x2F;img&#x2F;&quot;+filename);&#x2F;&#x2F;获取文件真实路径</span><br><span class="line">       FileInputStream fis &#x3D; new FileInputStream(realPath);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;设置Response的相应头</span><br><span class="line">       String mineType &#x3D; context.getMimeType(filename);&#x2F;&#x2F;获取文件的MIME类型</span><br><span class="line">       resp.setHeader(&quot;content-type&quot;,mineType);</span><br><span class="line">       resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;将输入流的数据写出到输出流</span><br><span class="line">       ServletOutputStream sos &#x3D; resp.getOutputStream();</span><br><span class="line">       byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">       int len &#x3D; 0;</span><br><span class="line">       while ((len&#x3D;fis.read(bytes))!&#x3D;-1)&#123;</span><br><span class="line">           sos.write(bytes,0,len);</span><br><span class="line">       &#125;</span><br><span class="line">       fis.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX和JSON</title>
    <url>/2020/04/28/ajax%E5%92%8CJSON/</url>
    <content><![CDATA[<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><a id="more"></a>
<h4 id="概念：ASynchronous-JavaScript-And-XML-异步的javascript和xml"><a href="#概念：ASynchronous-JavaScript-And-XML-异步的javascript和xml" class="headerlink" title="概念：ASynchronous JavaScript And XML   异步的javascript和xml"></a>概念：ASynchronous JavaScript And XML   异步的javascript和xml</h4><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式:"></a>实现方式:</h4><ul>
<li><p>1.原生的JS实现方式</p>
</li>
<li><p>2.JQuery实现方式</p>
<p>  1.<font color="#DC143C">$.ajax()}</font></p>
<pre><code>$.ajax({键值对});</code></pre><p>  2.<font color="#DC143C">$.get()</font></p>
<p>  3.<font color="#DC143C">$.post()</font></p>
</li>
</ul>
<h3 id="JOSN"><a href="#JOSN" class="headerlink" title="JOSN"></a>JOSN</h3><h4 id="概念：JavaScript-Object-Notation-JavaScript对象表示法"><a href="#概念：JavaScript-Object-Notation-JavaScript对象表示法" class="headerlink" title="概念：JavaScript Object Notation      JavaScript对象表示法"></a>概念：JavaScript Object Notation      JavaScript对象表示法</h4><h4 id="基本规则："><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h4><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据:"></a>获取数据:</h4><p><font color="#DC143C">json对象.键名</font></p>
<p><font color="#DC143C">json对象[“键名”]</font></p>
<p><font color="#DC143C">数组对象[索引]</font></p>
<h4 id="遍历JSON"><a href="#遍历JSON" class="headerlink" title="遍历JSON"></a>遍历JSON</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var key in person)&#123;</span><br><span class="line">    alert(key+&quot;:&quot;+person[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JSON数据和Java对象的相互转换"><a href="#JSON数据和Java对象的相互转换" class="headerlink" title="JSON数据和Java对象的相互转换"></a>JSON数据和Java对象的相互转换</h4><pre><code>1.JSON转为Java
    1.导入jar包
    2.创建jackson核心对象   ObjectMapper
    3.调用ObjectMapper的相关方法进行转换</code></pre><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String json &#x3D; &quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:20,\&quot;gender\&quot;:\&quot;男\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建ObjectMappper</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span><br><span class="line">&#x2F;&#x2F;转换为Java的对象</span><br><span class="line">Person person &#x3D; mapper.readValue(json,Person.class);</span><br><span class="line">System.out.println(person);</span><br></pre></td></tr></table></figure>
<h5 id="2-Java转为JSON"><a href="#2-Java转为JSON" class="headerlink" title="2.Java转为JSON"></a>2.Java转为JSON</h5><pre><code>1.导入jar包
2.创建jackson核心对象   ObjectMapper
3.调用ObjectMapper的相关方法进行转换</code></pre><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test1() throws Exception &#123;</span><br><span class="line">    Person p &#x3D; new Person();</span><br><span class="line">    p.setName(&quot;张三&quot;);</span><br><span class="line">    p.setAge(23);</span><br><span class="line">    p.setGendeer(&quot;男&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Jackson的核心对象  ObjectMapper</span><br><span class="line">    ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">    &#x2F;&#x2F;调用方法 转换</span><br><span class="line">    String JSON &#x3D; mapper.writeValueAsString(p);</span><br><span class="line">    System.out.println(JSON);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;wirterValue  将数据写入到D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt中</span><br><span class="line">    &#x2F;&#x2F;mapper.writeValue(new File(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt&quot;),p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;writeValue将数据关联到Writer中</span><br><span class="line">    mapper.writeValue(new FileWriter(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;b.txt&quot;),p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h5><pre><code>1.@JsonIgnore:排除属性
2.@JsonFormat:属性值格式化</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>校验用户是否存在</p>
<p>html代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;注册&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;JS&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;页面加载完成后 给文本框绑定离开焦点事件</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(&quot;#username&quot;).blur(function () &#123;</span><br><span class="line">                &#x2F;&#x2F;获取username获取文本输入框的值</span><br><span class="line">                var username &#x3D; $(this).val();</span><br><span class="line">                &#x2F;&#x2F;发送ajax请求</span><br><span class="line">                $.get(&quot;findUserServlet&quot;,&#123;username:username&#125;,function (data) &#123;</span><br><span class="line">                    var span &#x3D; $(&quot;#s_username&quot;)</span><br><span class="line">                    if (data.userExsit)&#123;</span><br><span class="line">                        &#x2F;&#x2F;用户名存在</span><br><span class="line">                        span.css(&quot;color&quot;,&quot;red&quot;)</span><br><span class="line">                        span.html(data.msg)</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &#x2F;&#x2F;用户名不存在</span><br><span class="line">                        span.css(&quot;color&quot;,&quot;green&quot;)</span><br><span class="line">                        span.html(data.msg)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,&quot;json&quot;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input id&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt;</span><br><span class="line">    &lt;span id&#x3D;&quot;s_username&quot;&gt;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;注册&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>Servlet代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.test.web.servlet;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;findUserServlet&quot;)</span><br><span class="line">public class findUserServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String username &#x3D; request.getParameter(&quot;username&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置响应数据为JSON</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        if (&quot;Tom&quot;.equals(username))&#123;</span><br><span class="line">            &#x2F;&#x2F;存在</span><br><span class="line">            map.put(&quot;userExsit&quot;,true);</span><br><span class="line">            map.put(&quot;msg&quot;,&quot;用户名已经存在&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;不存在</span><br><span class="line">            map.put(&quot;userExsit&quot;,false);</span><br><span class="line">            map.put(&quot;msg&quot;,&quot;用户名可用&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将map转为json，并且传递给客户端</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        mapper.writeValue(response.getWriter(),map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2020/04/06/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="scrapy爬虫框架的安装"><a href="#scrapy爬虫框架的安装" class="headerlink" title="scrapy爬虫框架的安装"></a>scrapy爬虫框架的安装</h1><a id="more"></a>
<p>用<code>pip install scrapy</code>命令安装会提示失败，是因为缺少twisted程序<br>进入<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">官网</a> 按住ctrl+f 查找关键字<br><img src="/img/%E7%88%AC%E8%99%AB1.png" alt="图片"><br>下载好与python版本配对的文件<br><img src="/img/%E7%88%AC%E8%99%AB2.png" alt="命令"><br>用命令安装下载好的文件  注意路径最好不要太长 否则容易报错<br>安装好插件以后用命令<br><code>pip install scrapy</code>安装框架<br>安装好以后用命令’scrapy’查看版本<br><img src="/img/%E7%88%AC%E8%99%AB3.png" alt="成功"><br>出现以上代码说明安装成功</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据库</title>
    <url>/2020/05/01/redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><a id="more"></a>
<h4 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h4><p><a href="https://pan.baidu.com/s/1FkHPTih-qGrGzFee0GW7QA" target="_blank" rel="noopener">百度云下载</a>       提取码：o1ui</p>
<p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">Github下载</a></p>
<h4 id="概念：一款高性能的NOSQL系列的非关系型数据库"><a href="#概念：一款高性能的NOSQL系列的非关系型数据库" class="headerlink" title="概念：一款高性能的NOSQL系列的非关系型数据库"></a>概念：一款高性能的NOSQL系列的非关系型数据库</h4><h4 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h4><pre><code>redis存储的是：key，value格式的数据，其中key都是字符串，value有5中不同的数据结构
value的数据结构
    1.字符串类型 string
    2.哈希类型  hash     ：相当于map集合
    3.列表集合  list        ：linkedlist格式
    4.集合类型  set        
    5.有序集合类型  sortedset</code></pre><h5 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h5><p>1.存储 <font color="#A52A2A">set key value</font></p>
<p>2.获取 <font color="#A52A2A">get key</font></p>
<p>3.删除 <font color="#A52A2A">del key</font>    </p>
<h5 id="哈希类型-hash"><a href="#哈希类型-hash" class="headerlink" title="哈希类型 hash"></a>哈希类型 hash</h5><p>1.存储  <font color="#A52A2A">hset key field value</font></p>
<p>2.获取 <font color="#A52A2A">hget key field                hgetall key  获取所有的键和值</font> </p>
<p>3.删除 <font color="#A52A2A">hdel key field</font> </p>
<h5 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型 list"></a>列表类型 list</h5><p>1.<font color="#A52A2A">lpush key value 将元素加入列表左边</font></p>
<p>2.<font color="#A52A2A">rpush key value 将元素加入列表右边</font></p>
<p>3.<font color="#A52A2A">lrange key start end  获取范围</font></p>
<p>4.<font color="#A52A2A">lpop key   删除列表最左边的元素，并将元素返回</font></p>
<p>5.<font color="#A52A2A">rpop key  删除列表最右边的元素</font></p>
<h5 id="集合类型-set"><a href="#集合类型-set" class="headerlink" title="集合类型 set"></a>集合类型 set</h5><p>1.<font color="#A52A2A">存储：sadd key value</font> </p>
<p>2.<font color="#A52A2A">获取：smembers key ：获取集合中所有元素</font></p>
<p>3.<font color="#A52A2A">删除：srem key value ：删除集合的某个元素</font></p>
<h5 id="有序集合类型-sortedset"><a href="#有序集合类型-sortedset" class="headerlink" title="有序集合类型 sortedset"></a>有序集合类型 sortedset</h5><p>1.存储：<font color="#A52A2A">zadd key score  value</font></p>
<p>2.获取：<font color="#A52A2A">zrange key start end</font></p>
<p>3.删除：<font color="#A52A2A">zrem key value</font></p>
<h5 id="通用命令："><a href="#通用命令：" class="headerlink" title="通用命令："></a>通用命令：</h5><p>1.<font color="#A52A2A">keys * ：查询所有的键</font></p>
<p>2.<font color="#A52A2A">type key：获取键对应的value的类型</font></p>
<p>3.<font color="#A52A2A">del key：删除指定的key value</font></p>
<h5 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h5><ul>
<li><p>1.redis是一个内存数据库，东redis服务器重启后，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘中</p>
</li>
<li><p>2.redis持久化机制</p>
<pre><code>1.RDB：默认方式。 在一定的间隔时间中，检测key的变化情况，然后去持久化数据            
2.AOF：日志记录的方式，可以检测每一条命令的操作。可以每一次命令操作后，持久化数据
        编辑redis.windows.conf文件    appendonly  no  给成yes</code></pre></li>
</ul>
<h3 id="Java客户端Jedis"><a href="#Java客户端Jedis" class="headerlink" title="Java客户端Jedis"></a>Java客户端Jedis</h3><pre><code>Jedis是一款java操作redis数据库的工具</code></pre><h3 id="Jedis连接池：JedisPool"><a href="#Jedis连接池：JedisPool" class="headerlink" title="Jedis连接池：JedisPool"></a>Jedis连接池：JedisPool</h3><pre><code>1.创建JedisPool连接池对象
2.调用getResource()方法获取Jedis的连接</code></pre><h4 id="工具类代码"><a href="#工具类代码" class="headerlink" title="工具类代码"></a>工具类代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.jedis.utlis;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">JedisPool工具类</span><br><span class="line">加载配置文件，配置连接池参数</span><br><span class="line">提供获取连接的方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JedisPoolUtils &#123;</span><br><span class="line">    private static JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F;读取配置文件</span><br><span class="line">        InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个Properties对象</span><br><span class="line">        Properties pro &#x3D; new Properties();</span><br><span class="line">        &#x2F;&#x2F;关联文件</span><br><span class="line">        try &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中</span><br><span class="line">        JedisPoolConfig config &#x3D; new JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化JedisPool</span><br><span class="line">        jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取连接</span><br><span class="line">    public static Jedis getJedis()&#123;</span><br><span class="line">        return jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat及Servlet</title>
    <url>/2020/04/08/tomcat%E5%8F%8AServlet/</url>
    <content><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><a id="more"></a>
<h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><p>进入官网，个人推荐下载解压版，方便快捷</p>
<p>解压到工作目录后就可以使用了 进入bin目录 双击startup.bat linux打开.sh<br><img src="/img/tomcat1.png" alt="路径"></p>
<h4 id="可能遇到的两个问题"><a href="#可能遇到的两个问题" class="headerlink" title="可能遇到的两个问题"></a>可能遇到的两个问题</h4><ul>
<li>双击之后没有启动tomcat 黑窗口秒关闭—-JAVA_HOME的环境变量没有没配置好</li>
<li>运行日志乱码—-打开cd到tomcat/conf/目录下修改logging.properties找到</li>
</ul>
<p><code>java.util.logging.ConsoleHandler.encoding = utf-8</code></p>
<p>这行将utf-8改为GBK</p>
<h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><ul>
<li>1.直接将项目放到webapps目录下即可<ul>
<li>/hello :项目访问的路径—-&gt;虚拟目录<pre><code>将项目打包成一个war包，再将war包放到webapps目录下 war包会自动解压</code></pre></li>
</ul>
</li>
<li>2.配置conf/server.xml<ul>
<li>在<Host>标签体中配置</li>
<li>docBase：项目存放的路径</li>
<li>path:虚拟目录</li>
</ul>
</li>
<li>3.在conf\Catalina\localhost创建任意名称的xml文件，在文件中编写<pre><code>    `&lt;Context docBase=&quot;D:\hello&quot;&gt;`
虚拟目录就是文件的名称</code></pre></li>
</ul>
<h4 id="静态项目和动态项目："><a href="#静态项目和动态项目：" class="headerlink" title="静态项目和动态项目："></a>静态项目和动态项目：</h4><pre><code>目录结构：
        --项目的根目录
            --WEB-INF目录
                --web.xml:web项目的核心配置文件
                --classes目录：放置字节码文件的目录
                --lib目录：防止依赖的jar包</code></pre><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><ul>
<li>概念：server applet  运行在服务器端的小程序</li>
<li>servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>1.创建javaEE项目
2.定义一个类，实现Servlet接口
3.实现接口中的抽象方法
4.配置 Servlet---- 在web.xml中配置</code></pre></li>
<li>配置代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;cn.test.web.Servlet.ServletDemo1&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4></li>
<li>1.当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的Servlet的资源路径</li>
<li>2.查找web.xml文件，是否有对应的<url-pattern>标签体内容</li>
<li>3.如果有，则再找到对应的<servlet-class>全类名</li>
<li>4.tomcat会将字节码文件加载进内存，并创建其对象</li>
<li>5.调用方法<h4 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h4>  1.被创建：执行init方法，只执行一次<br>  2.提供服务：执行servlet方法，执行多次<br>  3.被销毁：执行destroy方法，执行一次</li>
</ul>
<h4 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h4><pre><code>支持注解文件配置，可以不需要web.xml
步骤：
    1.创建javaEE的项目，选择Servlet的版本 3.0以上，可以不勾选web.xml
    2.定义一个类，实现Servlet接口
    3.重写方法
    4.在类上使用一个注解
        @WebServlet(&quot;资源路径&quot;)</code></pre><h4 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h4><ul>
<li><p>Servlet 接口</p>
</li>
<li><p>GenericServlet 抽象类</p>
<p>  将Servlet接口的其他方法做了默认实现，只将service()方法作为抽象</p>
</li>
<li><p>HttpServlet  抽象类 对HTPP协议的一种封装，简化操作</p>
<p>  1.定义类继承HttpServlet</p>
<p>  2.复写doGet/doPost方法</p>
</li>
</ul>
<h3 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h3><ul>
<li><p>1.urlpartten：Servlet访问的路径</p>
<pre><code>1.一个Servlet可以定义多个访问路径:WebServlet({&quot;/d4&quot;,&quot;Demo4&quot;})

2.路径的定义规则：/XXX，/XXX，*.do</code></pre></li>
</ul>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客及其部署</title>
    <url>/2020/04/06/%E5%AE%89%E8%A3%85Hexo%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="特别鸣up主CodeSheep"><a href="#特别鸣up主CodeSheep" class="headerlink" title="特别鸣up主CodeSheep"></a>特别鸣up主<a href="https://www.bilibili.com/video/BV1Yb411a7ty?t=26" target="_blank" rel="noopener">CodeSheep</a></h1><a id="more"></a>
<h2 id="基于b站视频-windows-10系统，所有以下在windows10-64位下进行演示。"><a href="#基于b站视频-windows-10系统，所有以下在windows10-64位下进行演示。" class="headerlink" title="基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。"></a>基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。</h2><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网</a><br><img src="/img/1.png" alt="图片">建议下载第一个<br>安装步骤非常简单，一直next，下一步就可以了，默认安装就行。</p>
<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a><br>然后我们选择windows版本的下载<br>安装也是一直点下一步，安装官方默认的来就行，<br>安装完了，在开始菜单可以看到<br><img src="/img/2.png" alt="图片"></p>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>创建一个工作目录  比如在c盘建一个blog文件夹<br>用管理员属性打开cmd  cd到工作目录<br>使用npm 安装hexo<br><code>npm install -g hexo-cli</code><br>输入<br><code>hexo -v</code><br>判断hexo是否安装成功<br><img src="/img/3.png" alt="表示成功"><br>输入<br><code>hexo init</code>初始化一个博客<br>这里是hexo常用的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #用来清理缓存文件</span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d   #上传到服务器</span><br></pre></td></tr></table></figure>
<p>输入<code>hexo s</code>之后可以进入<code>http://localhost:4000/</code>这个地址查看我们的博客</p>
<h1 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h1><p>这里我们选用的部署到github上面<br>首先新建一个github的仓库<br><img src="/img/4.png" alt="新建仓库"><br><img src="/img/5.png" alt="仓库名"><br>这里的name一定要填自己的用户名.github.io 不然会出问题<br>去工作目录找到_config.yml这个文件  双击打开  我这里使用vscode打开的 用notepad++ 文本打开都可以<br><img src="/img/6.png" alt="要求"><br>红线换成自己的github用户名就行了 其他两行按照这个填写<br>安装 hexo-deployer-git。<br><code>npm install hexo-deployer-git --save</code><br>部署一下就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>这样你就可以通过自己的git仓库的域名访问你自己的博客了<br>同样还可以部署在码云和coding上这个可以加快访问的速度</p>
<h1 id="开启github-pages服务，绑定域名"><a href="#开启github-pages服务，绑定域名" class="headerlink" title="开启github pages服务，绑定域名"></a>开启github pages服务，绑定域名</h1><p>如果你觉域名比较难记，可以自己去申请一个域名</p>
<p>这里我们以腾讯云为例，前提是我已经申请好了<br><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%911.png" alt=""><br>点击解析域名<br><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%912.png" alt=""><br>最好添加一个主机记录为@记录类型为<code>CNAME</code>类型，记录值写自己github仓库的地址名。</p>
<p>接下来配置github的 pages服务<br><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%913.png" alt=""></p>
<ul>
<li>找到博客对应的仓库，点击setting</li>
<li>下滑找到Github Pages，填入自己的域名，点击save保存</li>
</ul>
<p>这样就可以通过自己的域名访问呢了</p>
]]></content>
      <tags>
        <tag>软件</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>抽取Servlet</title>
    <url>/2020/05/13/%E6%8A%BD%E5%8F%96Servlet/</url>
    <content><![CDATA[<h3 id="BaseServlet代码"><a href="#BaseServlet代码" class="headerlink" title="BaseServlet代码"></a>BaseServlet代码</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.travel.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BaseServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;完成方法的分发</span><br><span class="line">        &#x2F;&#x2F;获取请求路径</span><br><span class="line">        String uri &#x3D; req.getRequestURI();</span><br><span class="line">        System.out.println(&quot;请求uri:&quot;+uri);</span><br><span class="line">        &#x2F;&#x2F;获取方法对象</span><br><span class="line">        String methodName &#x3D; uri.substring(uri.lastIndexOf(&quot;&#x2F;&quot;)+1);</span><br><span class="line">        System.out.println(&quot;方法名称：&quot;+methodName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取方法对象Method</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method &#x3D; this.getClass().getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">            &#x2F;&#x2F;暴力反射</span><br><span class="line">            &#x2F;&#x2F;method.setAccessible(true);</span><br><span class="line">            &#x2F;&#x2F;执行方法</span><br><span class="line">            method.invoke(this,req,resp);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UserServlet代码"><a href="#UserServlet代码" class="headerlink" title="UserServlet代码"></a>UserServlet代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.travel.web.servlet;</span><br><span class="line"></span><br><span class="line">import cn.travel.damain.ResultInfo;</span><br><span class="line">import cn.travel.damain.User;</span><br><span class="line">import cn.travel.service.UserService;</span><br><span class="line">import cn.travel.service.impl.UserServiceImpl;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;user&#x2F;*&quot;)</span><br><span class="line">public class UserServlet extends BaseServlet &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 注册功能</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void regist(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;验证码校验</span><br><span class="line">        String checkcode &#x3D; request.getParameter(&quot;checkcode&quot;);</span><br><span class="line">        String checkcode_session &#x3D; (String) request.getSession().getAttribute(&quot;checkcode_session&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;防止验证码复用 保证验证码只能使用一次</span><br><span class="line">        request.getSession().removeAttribute(&quot;checkcode_session&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;比较</span><br><span class="line">        if (checkcode_session &#x3D;&#x3D; null || !checkcode_session.equalsIgnoreCase(checkcode)) &#123;</span><br><span class="line">            ResultInfo info &#x3D; new ResultInfo();</span><br><span class="line">            info.setFlag(false);</span><br><span class="line">            info.setErrorMsg(&quot;验证码错误&quot;);</span><br><span class="line">            &#x2F;&#x2F;将info对象序列化为json</span><br><span class="line">            ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">            String json &#x3D; mapper.writeValueAsString(info);</span><br><span class="line">            response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取数据</span><br><span class="line">        String username &#x3D; request.getParameter(&quot;username&quot;);</span><br><span class="line">        String password &#x3D; request.getParameter(&quot;password&quot;);</span><br><span class="line">        String name &#x3D; request.getParameter(&quot;name&quot;);</span><br><span class="line">        String birthday &#x3D; request.getParameter(&quot;birthday&quot;);</span><br><span class="line">        String email &#x3D; request.getParameter(&quot;email&quot;);</span><br><span class="line">        &#x2F;&#x2F;封装对象</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setBirthday(birthday);</span><br><span class="line">        user.setEmail(email);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用service完成注册</span><br><span class="line">        UserService service &#x3D; new UserServiceImpl();</span><br><span class="line">        boolean flag &#x3D; service.regist(user);</span><br><span class="line">        &#x2F;&#x2F;响应结果</span><br><span class="line">        ResultInfo resultInfo &#x3D; new ResultInfo();</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            &#x2F;&#x2F;注册成功</span><br><span class="line">            resultInfo.setFlag(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;注册失败</span><br><span class="line">            resultInfo.setFlag(false);</span><br><span class="line">            resultInfo.setErrorMsg(&quot;注册失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将resultInfo对象序列化为JSON，并写回客户端</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        String json &#x3D; mapper.writeValueAsString(resultInfo);</span><br><span class="line">        &#x2F;&#x2F;将json数据写回客户端</span><br><span class="line">        &#x2F;&#x2F;设置content-type</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        response.getWriter().write(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 登录功能</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;获取用户名和密码数据</span><br><span class="line">        Map&lt;String, String[]&gt; map &#x3D; request.getParameterMap();</span><br><span class="line">        &#x2F;&#x2F;分装user对象</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        try &#123;</span><br><span class="line">            BeanUtils.populate(user, map);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用service查询</span><br><span class="line">        UserService service &#x3D; new UserServiceImpl();</span><br><span class="line">        User u &#x3D; service.login(user);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断</span><br><span class="line">        ResultInfo resultInfo &#x3D; new ResultInfo();</span><br><span class="line">        if (u &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;用户名密码错误</span><br><span class="line">            resultInfo.setFlag(false);</span><br><span class="line">            resultInfo.setErrorMsg(&quot;用户名或密码错误!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断用户是否激活</span><br><span class="line">        if (u !&#x3D; null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())) &#123;</span><br><span class="line">            &#x2F;&#x2F;用户尚未激活</span><br><span class="line">            resultInfo.setFlag(false);</span><br><span class="line">            resultInfo.setErrorMsg(&quot;您尚未激活，请前往邮箱激活!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;登录成功的判断</span><br><span class="line">        if (u !&#x3D; null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())) &#123;</span><br><span class="line">            &#x2F;&#x2F;登录成功</span><br><span class="line">            resultInfo.setFlag(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.getSession().setAttribute(&quot;user&quot;, u);</span><br><span class="line">        &#x2F;&#x2F;响应数据</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        String json &#x3D; mapper.writeValueAsString(resultInfo);</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        response.getWriter().write(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单个对象</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">        &#x2F;&#x2F;将user写回客户端</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        mapper.writeValue(response.getOutputStream(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退出</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void exit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;销毁session</span><br><span class="line">        request.getSession().invalidate();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;跳转页面  重定向</span><br><span class="line">        response.sendRedirect(request.getContextPath() + &quot;&#x2F;login.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 激活</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void active(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;获取激活码</span><br><span class="line">        String code &#x3D; request.getParameter(&quot;code&quot;);</span><br><span class="line">        if (code !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;调用service完成激活</span><br><span class="line">            UserService service &#x3D; new UserServiceImpl();</span><br><span class="line">            Boolean flag &#x3D; service.active(code);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;判断标记</span><br><span class="line">            String msg &#x3D; null;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                &#x2F;&#x2F;激活成功</span><br><span class="line">                msg &#x3D; &quot;激活成功，请&lt;a href&#x3D;&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;激活失败</span><br><span class="line">                msg &#x3D; &quot;激活失败，联系管理员&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line">            response.getWriter().write(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis框架(一)</title>
    <url>/2020/05/19/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%80/</url>
    <content><![CDATA[<p>mybatis笔记(一)</p>
<a id="more"></a>

<h3 id="mybatis概述"><a href="#mybatis概述" class="headerlink" title="mybatis概述"></a>mybatis概述</h3><p>mybatis是一个持久层框架，用java编写，封装了很多jdbc细节，开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程，它使用了ORM思想，实现了结果集的封装。</p>
<h3 id="ORM：Object-Relational-Mappging-对象关系映射"><a href="#ORM：Object-Relational-Mappging-对象关系映射" class="headerlink" title="ORM：Object Relational Mappging   对象关系映射"></a>ORM：Object Relational Mappging   对象关系映射</h3><p>简单的说：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类及实现操作数据库</p>
<h3 id="mybatis环境搭建"><a href="#mybatis环境搭建" class="headerlink" title="mybatis环境搭建"></a>mybatis环境搭建</h3><ul>
<li>1.创建maven工程并导入坐标<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;3.5.4&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;8.0.18&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>2.创建实体类和dao接口</li>
<li>3.创建mybatis的主配置文件SqlMapConfig.xml</li>
<li>4.创建映射配置文件<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></li>
<li>1.包在创建时 com.demomybatis.dao他是三级目录结构</li>
<li>2.mybatis的映射配置文件位置必须和dao接口的包结构相同</li>
<li>3.映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定而类名</li>
<li>4.映射配置文件的擦偶哦配置(select) id的取值必须是dao接口的方法名</li>
</ul>
<div class="note success"><p>当我们遵从2，3，4点之后，我们开发中就无需再写dao的实现类</p></div>

<h3 id="SqlMapConfig-xml代码"><a href="#SqlMapConfig-xml代码" class="headerlink" title="SqlMapConfig.xml代码"></a>SqlMapConfig.xml代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">            &lt;!--使用jdbc事务管理 --&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">            &lt;!-- 数据库连接池(数据源) --&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line">    &lt;!-- 引入映射配置文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;cn&#x2F;demomybatis&#x2F;dao&#x2F;StudentDao.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="StudentDao-xml代码"><a href="#StudentDao-xml代码" class="headerlink" title="StudentDao.xml代码"></a>StudentDao.xml代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- namespace：命名空间，用于隔离sql--&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;cn.demomybatis.dao.StudentDao&quot;&gt;</span><br><span class="line">    &lt;!--    配置查询所有 id为dao的方法名--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;cn.demomybatis.domain.Student&quot; parameterType&#x3D;&quot;cn.demomybatis.domain.Student&quot;&gt;</span><br><span class="line">		select * from student</span><br><span class="line">	&lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>
<h3 id="mybatis入门案例："><a href="#mybatis入门案例：" class="headerlink" title="mybatis入门案例："></a>mybatis入门案例：</h3><ul>
<li>1.读取配置文件</li>
<li>2.创建SqlSessionFactory工厂</li>
<li>3.创建SqlSession</li>
<li>4.创建Dao接口的代理</li>
<li>5.执行Dao中的方法</li>
<li>6.释放资源</li>
</ul>
<span class='p red'>注意：需要在映射配置中告知mybatis要封装到哪个实体类中，配置的方式：指定实体类的全类名</span>

<div class="note warning"><p>增删改需要提交事务</p></div>

<p><code>sqlSession.commit()</code></p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.demomybatis.test;</span><br><span class="line"></span><br><span class="line">import cn.demomybatis.dao.StudentDao;</span><br><span class="line">import cn.demomybatis.domain.Student;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * mybatis入门</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class mybatistest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;读取配置文件</span><br><span class="line">        InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建工厂</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;使用工厂生产SqlSession对象</span><br><span class="line">        SqlSession sqlSession &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;创建Dao接口的代理对象</span><br><span class="line">        StudentDao studentDao &#x3D; sqlSession.getMapper(StudentDao.class);</span><br><span class="line">        &#x2F;&#x2F;使用代理对象执行方法</span><br><span class="line">        List&lt;Student&gt; list &#x3D; studentDao.findAll();</span><br><span class="line">        for (Student student:list)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;释放资源</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>PicGo+GitHub图床，让Markdown飞</title>
    <url>/2020/05/21/PicGo-GitHub%E5%9B%BE%E5%BA%8A%EF%BC%8C%E8%AE%A9Markdown%E9%A3%9E/</url>
    <content><![CDATA[<p>PicGo+GitHub图床</p>
<a id="more"></a>

<p>一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种<strong>“轻量级标记语言”</strong>。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：<strong>Typora</strong>和<strong>马克飞象</strong>。</p>
<p>目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都<strong>近乎完美但是却又不能达到完美</strong>。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是<strong>将截图存放在本机电脑上</strong>，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。</p>
<p>这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：<strong>PicGo+GitHub图床</strong></p>
<blockquote>
<p>注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户）</p>
</blockquote>
<h1 id="PicGo介绍"><a href="#PicGo介绍" class="headerlink" title="PicGo介绍"></a><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo介绍</a></h1><p>这是一款图片上传的工具，目前支持<code>微博图床</code>，<code>七牛图床</code>，<code>腾讯云</code>，<code>又拍云</code>，<code>GitHub</code>等图床，未来将支持更多图床。</p>
<p>所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523183627.png" alt=""></p>
<p>Pic Go支持的图床</p>
<p>在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。</p>
<h1 id="创建自己的GitHub图床"><a href="#创建自己的GitHub图床" class="headerlink" title="创建自己的GitHub图床"></a>创建自己的GitHub图床</h1><h2 id="1-创建GitHub图床之前，需要注册-登陆GitHub账号"><a href="#1-创建GitHub图床之前，需要注册-登陆GitHub账号" class="headerlink" title="1. 创建GitHub图床之前，需要注册/登陆GitHub账号"></a>1. 创建GitHub图床之前，需要注册/登陆GitHub账号</h2><blockquote>
<p>申请GitHub账号很简单，我就不演示了</p>
</blockquote>
<h2 id="2-创建Repository"><a href="#2-创建Repository" class="headerlink" title="2. 创建Repository"></a>2. 创建Repository</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523183819.png" alt=""></p>
<p>点击”New repository”按钮</p>
<blockquote>
<ul>
<li>我已经建立过一个同名的repository的，所以第一步会显示红色</li>
<li>第三步，为repository初始化一个README.md文件可以根据需求选择，非必选</li>
</ul>
</blockquote>
<h2 id="3-生成一个Token用于操作GitHub-repository"><a href="#3-生成一个Token用于操作GitHub-repository" class="headerlink" title="3.生成一个Token用于操作GitHub repository"></a>3.生成一个Token用于操作GitHub repository</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523183947.png" alt=""></p>
<p>回到主页，点击”Settings”按钮</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184121.png" alt=""></p>
<p>进入页面后，点击”Developer settings”按钮</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184453.png" alt=""></p>
<p>点击”Personal access tokens”按钮</p>
<p>创建新的Token</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184607.png" alt=""><br>填写描述，选择”repo”,然后点击”Generate token”按钮</p>
<blockquote>
<p>注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存</p>
</blockquote>
<h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><h4 id="1-下载运行PicGo"><a href="#1-下载运行PicGo" class="headerlink" title="1. 下载运行PicGo"></a>1. 下载运行PicGo</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184734.png" alt=""></p>
<p>推荐下载exe可执行文件</p>
<h4 id="2-配置图床"><a href="#2-配置图床" class="headerlink" title="2. 配置图床"></a>2. 配置图床</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/img/20200521194551.png" alt=""></p>
<p>如图配置</p>
<blockquote>
<ul>
<li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li>
<li>分支名统一填写“master”</li>
<li>将之前的Token黏贴在这里</li>
<li>存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹</li>
<li>自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<code>https://raw.githubusercontent.com/用户名/RepositoryName/分支名，</code>，自定义域名需要按照这样去填写</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下<code>ctrl+shift+c</code>，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！<br>。</p>
<p>自己在本地用确实没有什么问题，但是提交到博客上发现图片加载失败，或者加载异常慢，于是我发现了一种加速的方法</p>
<h4 id="CDN-简介"><a href="#CDN-简介" class="headerlink" title="CDN 简介"></a><strong>CDN 简介</strong></h4><blockquote>
<p><strong>内容分发网络</strong>（英语：<strong>C</strong>ontent <strong>D</strong>elivery <strong>N</strong>etwork或<strong>C</strong>ontent <strong>D</strong>istribution <strong>N</strong>etwork，缩写：<strong>CDN</strong>）是指一种透过<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2">互联网</a>互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。<br>—— <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">Wikipedia</a></p>
</blockquote>
<p>简而言之就是让服务器距离大陆较远的 GitHub ，将托管在那里的<strong>静态</strong>资源缓存到一个近一点的服务器，从而加快访问。</p>
<p>看了这样的解释你应该能够理解，CDN 虽然能缓解互联压力，可也是要耗费一定的资源的，从而市面上的 CDN 大多是收费的。Cloudflare 虽然有免费 CDN ，可是国内节点致开放给专业版用户使用，价格偏高，而海外的节点又类似<strong>负优化</strong>，可能还会降低速度。</p>
<h3 id="jsDelivr"><a href="#jsDelivr" class="headerlink" title="jsDelivr"></a><strong>jsDelivr</strong></h3><p><a href="https://link.zhihu.com/?target=https%3A//www.jsdelivr.com/">jsDelivr</a>是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。</p>
<p>有搜索引擎，支持一键复制文件 URL 和标签，支持分发 NPM、GitHub、WordPress SVN 的文件</p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h3><p>可能看起来，官方的使用方法十分复杂，但其实就一句话：把仓库链接的域名替换成 jsDelivr 的域名。</p>
<p>如托管在 GitHub 的仓库链接都是 <code>https://github.com/username/repo/branch/file</code> 的形式，而我们就可以将前面的 <code>github.com</code> 改成 jsDelivr 提供加速 GitHub 仓库的域名 <code>cdn.jsdelivr.net/gh</code> 。</p>
<p>嗯，兴冲冲配置一发，发现什么都没有？其实还是有一点点小差别的。比如分支那里，jsDelivr 默认要直接在仓库名后面 <code>@</code> ，所以真正其实是 <code>https://cdn.jsdelivr.net/gh/username/repo@branch/file</code> 的形式。当然，如果你放在仓库的默认分支，还可以直接将 <code>branch</code> 这个关键字直接删了，变成 <code>https://cdn.jsdelivr.net/gh/username/repo/file</code> 一样能获取到！</p>
<p>另外，如果是一些比较稳定的文件，后面不会频繁地改动，还可以发布成一个版本，然后在 <code>repo</code> 后 <code>@version</code> 就可以引用对应的版本。</p>
<h3 id="加速图床"><a href="#加速图床" class="headerlink" title="加速图床"></a><strong>加速图床</strong></h3><p>如果你还记得笔者之前写的 <strong>PicGo + GitHub 搭建免费图床</strong> 的话，不难发现 jsDelivr 也是能加速这个图床（本质不还是一个 GitHub 仓库嘛）的。我们只需要在 <strong>GitHub 图床设置</strong> 中将链接设置为 <code>https://cdn.jsdelivr.net/gh/username/repo</code> 即可！前提是你上传到默认分支。</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>ngork内网穿透</title>
    <url>/2020/05/22/ngork%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>将本地的项目运行在公网上</p>
<a id="more"></a>

<h3 id="1-进入ngrok官网（http-www-ngrok-cc-），注册ngrok账号"><a href="#1-进入ngrok官网（http-www-ngrok-cc-），注册ngrok账号" class="headerlink" title="1.进入ngrok官网（http://www.ngrok.cc/），注册ngrok账号"></a>1.进入ngrok官网（<a href="http://www.ngrok.cc/），注册ngrok账号" target="_blank" rel="noopener">http://www.ngrok.cc/），注册ngrok账号</a></h3><h3 id="2-登录–-gt-隧道管理–-gt-开通隧道"><a href="#2-登录–-gt-隧道管理–-gt-开通隧道" class="headerlink" title="2.登录–&gt;隧道管理–&gt;开通隧道"></a>2.登录–&gt;隧道管理–&gt;开通隧道</h3><p>找到免费的</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522091915.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092038.png" alt=""></p>
<p>隧道名称和前置域名随便填就行了  端口填自己tomcat的端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092309.png" alt=""></p>
<p>点击客户端下载</p>
<p>下载完成之后点击启动工具</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092538.png" alt=""></p>
<p>输入隧道id</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092753.png" alt=""></p>
<p>显示这个就已经成功了  可以通过上边哪个域名访问自己本地的项目了</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis框架(二)</title>
    <url>/2020/05/22/mybatis%E6%A1%86%E6%9E%B6-%E4%BA%8C/</url>
    <content><![CDATA[<p>mybatis笔记(二)</p>
<a id="more"></a>

<h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><h4 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h4><ul>
<li>mybatis-config.xml  </li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：<ul>
<li>configuration（配置）<ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties" target="_blank" rel="noopener">properties（属性）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">settings（设置）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases（类型别名）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory" target="_blank" rel="noopener">objectFactory（对象工厂）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">plugins（插件）</a></li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider" target="_blank" rel="noopener">databaseIdProvider（数据库厂商标识）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">mappers（映射器）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>MyBatis可以配置成适应多种环境</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例智能选择一种环境。</strong></p>
<p>Mybatis默认的事务管理器就是JDBC，连接池POOLED</p>
<h4 id="属性-properties"><a href="#属性-properties" class="headerlink" title="属性(properties)"></a>属性(properties)</h4><p>我们可以通过properties属性实现引用配置文件</p>
<p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。</p>
<p>编写一个配置文件:db.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>在核心配置文件中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入外部配置文件--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  可以给实体类起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"cn.demomybatis.domain.Student"</span> <span class="attr">alias</span>=<span class="string">"Student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean</p>
<p>扫描实体类的包，他的默认别名就为这个类的类名首字母小写</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="left">是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td align="left">true|False</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>MapperRegistry:注册绑定我们的Mapper文件</p>
<p>方式一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"cn/demomybatis/dao/StudentDao.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"cn.demomybatis.dao.StudentDao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式三：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.demomybatis.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h3><p>生命周期和作用域是只管重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong></p>
<h3 id="解决属性名和字段名不一致问题"><a href="#解决属性名和字段名不一致问题" class="headerlink" title="解决属性名和字段名不一致问题"></a>解决属性名和字段名不一致问题</h3><h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    结果集映射--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentMap"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--        column是数据库中的字段，property是实体类中的字段--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"u_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>resultMap元素是MyBatis中最重要最强大的元素</p>
</li>
<li><p>ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，对于复杂一点的语句只需要猫叔他们的关系就行了</p>
</li>
<li><p>ResultMap最优秀的地方在于，虽然你已经对他相当了解了，但根本不需要显式的用到他们。</p>
</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h4><p>如果一个数据库操作出现了异常，我们需要排错。日志就是最好的帮手！</p>
<table>
<thead>
<tr>
<th align="center">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">logImpl</td>
<td align="left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td align="left">SLF4J，LOG4J，LOG4J2，JDK_LOGGING，COMMONS_LOGGING，STDOUT_LOGGING，NO_LOGGING</td>
<td align="left">未设置</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        标准的日志实现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="LOG4J"><a href="#LOG4J" class="headerlink" title="LOG4J"></a>LOG4J</h4><p>什么式log4j？</p>
<ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995" target="_blank" rel="noopener">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/控制台/2438626" target="_blank" rel="noopener">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI" target="_blank" rel="noopener">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>通过一个<a href="https://baike.baidu.com/item/配置文件/286550" target="_blank" rel="noopener">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p>1.先导入LOG4J的jar包</p>
<p>2.log4j.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#############################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Log4J 配置文件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#############################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义缺省的日志级别和输出对象</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,INFO, logfile,console</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定控制台输出模式</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[%d&#123;MM/dd HH:mm:ss&#125;] [%-3p] %c&#123;1&#125;: %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对package定义日志级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache</span>=<span class="string">WARN</span></span><br><span class="line"><span class="meta">log4j.logger.com.paic.pafademo</span>=<span class="string">DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定日志文件的输出模式</span></span><br><span class="line"><span class="meta">log4j.appender.logfile</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.DatePattern</span>=<span class="string">yyyyMMdd</span></span><br><span class="line"><span class="comment"># $&#123;pafa.log.home&#125;通过参数-D指定，比如启动WebLogic时加入参数-Dpafa.log.home=c:/</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.File</span>=<span class="string">$&#123;log.home&#125;/appdemo/pafa.log</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout.ConversionPattern</span>=<span class="string">%d&#123;MM/dd HH:mm:ss&#125; [%-3p] %c&#123;1&#125;: %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要查看iBATIS的SQL日志信息，确保有下面配置</span></span><br><span class="line"><span class="meta">log4j.logger.com.ibatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Connection</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>3.配置log4j为日志的实现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p>1.在要使用的Log4j的类中，导入import org.apache.log4j.Logger;</p>
<p>2.日志对象，参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(mybatistest<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h4 id="使用limit分类"><a href="#使用limit分类" class="headerlink" title="使用limit分类"></a>使用limit分类</h4><p>使用MyBatis实现分页，核心SQL</p>
<p>1.接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页</span></span><br><span class="line">   <span class="function">List&lt;Student&gt; <span class="title">getStudentByLimit</span><span class="params">(Map&lt;String,Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.StudentDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudentByLimit"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        select * from student limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentByLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        StudentDao studentDao = sqlSession.getMapper(StudentDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"startIndex"</span>,<span class="number">0</span>);</span><br><span class="line">        map.put(<span class="string">"pageSize"</span>,<span class="number">2</span>);</span><br><span class="line">        List&lt;Student&gt; studentList = studentDao.getStudentByLimit(map);</span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RowBounds分页"><a href="#RowBounds分页" class="headerlink" title="RowBounds分页"></a>RowBounds分页</h4>]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis框架(三)</title>
    <url>/2020/05/24/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%89/</url>
    <content><![CDATA[<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p>1.注解在接口上使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from student"</span>)</span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.需要在核心配置文件中绑定接口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource="cn/demomybatis/dao/StudentDao.xml"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper class="cn.demomybatis.dao.StudentDao"/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.demomybatis.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>本质：反射机制实现</p>
<p>底层：动态代理！</p>
<p><strong>MyBatis详细执行流程</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/asdasdas.jpg" style="zoom: 80%;" />

<h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p>我们可以在创建工具类的时候实现自动提交事务！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写接口，增加注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法存在多个参数，所有参数前面必须加上@Param注解</span></span><br><span class="line">   <span class="meta">@Select</span>(<span class="string">"select * from student where id = #&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function">Student <span class="title">getStudentById1</span><span class="params">(@Param(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Insert</span>(<span class="string">"insert into student(id,name,age,phone) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;phone&#125;)"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addStudent1</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Update</span>(<span class="string">"update student set name=#&#123;name&#125;,age=#&#123;age&#125;,phone=#&#123;phone&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">updateStudent1</span><span class="params">(Student student)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="关于-Param注解"><a href="#关于-Param注解" class="headerlink" title="关于@Param注解"></a>关于@Param注解</h4><ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议加上</li>
<li>我们在SQL中引用的就是我们这里的@Param()中设定的属性名！</li>
</ul>
<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>使用步骤：</p>
<p>1.在IDEA中安装Lombok插件</p>
<p>2.在项目导入Lombok的jar包</p>
<p>3.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>：生成无参构造，get，set，toString，hashcode，equals</span><br><span class="line"><span class="meta">@AllArgsConstructor</span>   有参构造方法</span><br><span class="line"><span class="meta">@NoArgsConstructor</span>    无参构造方法</span><br></pre></td></tr></table></figure>

<h3 id="多对一处理"><a href="#多对一处理" class="headerlink" title="多对一处理"></a>多对一处理</h3><h4 id="按照插叙嵌套处理"><a href="#按照插叙嵌套处理" class="headerlink" title="按照插叙嵌套处理"></a>按照插叙嵌套处理</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     思路：</span></span><br><span class="line"><span class="comment">            1.查询所有的学生信息</span></span><br><span class="line"><span class="comment">            2.根据查询出来的tid，寻找对应的老师！   子查询--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher"</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span> <span class="attr">select</span>=<span class="string">"getTeacher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">        select * from teacher where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent2"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher2"</span>&gt;</span></span><br><span class="line">       select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher2"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"sname"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"tname"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="一对多处理"><a href="#一对多处理" class="headerlink" title="一对多处理"></a>一对多处理</h3><p>同理</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.关联 - association 【多对一】</p>
<p>2.集合 - collection 【一对多】</p>
<p>3.javaTape：用来指定实体类中属性的类型</p>
<p>4.ofType：用来指定映射到List或者集合中的实体类类型，泛型中的约束类型</p>
]]></content>
      <tags>
        <tag>JavwWeb</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
