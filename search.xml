<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BeanUtils工具类的使用</title>
    <url>/2020/04/11/BeanUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="BeanUtils工具类，简化数据封装"><a href="#BeanUtils工具类，简化数据封装" class="headerlink" title="BeanUtils工具类，简化数据封装"></a>BeanUtils工具类，简化数据封装</h3><a id="more"></a>
<h4 id="用于封装JavaBean的"><a href="#用于封装JavaBean的" class="headerlink" title="用于封装JavaBean的"></a>用于封装JavaBean的</h4><pre><code>JavaBean：标准Java类</code></pre><h4 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h4><ul>
<li>1.类必须被public修饰</li>
<li>2.必须提供空参的构造器</li>
<li>3.成员变量必须使用private修饰</li>
<li>4.提供公共的setter和getter方法<h4 id="功能：封装数据"><a href="#功能：封装数据" class="headerlink" title="功能：封装数据"></a>功能：封装数据</h4><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4>点解<a href="http://commons.apache.org/proper/commons-beanutils/download_beanutils.cgi" target="_blank" rel="noopener">链接</a>下载<br><img src="/img/BeanUtils1.png" alt="点这个"></li>
</ul>
<p>BeanUtils工具常用工具类有两个：BeanUtils、ConvertUtils。BeanUtils用于封装数据</p>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BeanUtils对象</td>
<td>populate(Object bean, Map&lt;String,String[]&gt;properties)</td>
<td>将Map数据封装到指定Javabean中，一般用于将表单的所有数据封装到javabean</td>
</tr>
<tr>
<td></td>
<td>setProperty(Object obj,String name,Object value)</td>
<td>设置属性值</td>
</tr>
<tr>
<td></td>
<td>getProperty(Object obj,String name)</td>
<td>获得属性值</td>
</tr>
</tbody></table>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取所有请求参数</span><br><span class="line">        Map&lt;String,String[]&gt; map &#x3D; req.getParameterMap ();</span><br><span class="line">        &#x2F;&#x2F;创建User对象</span><br><span class="line">        User loginuser &#x3D; new User();</span><br><span class="line">        &#x2F;&#x2F;使用BeanUtils</span><br><span class="line">        try &#123;</span><br><span class="line">            BeanUtils.populate(loginuser,map);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter过滤器</title>
    <url>/2020/04/23/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h2><a id="more"></a>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul>
<li>1.定义一个类，实现Filter</li>
<li>2.复写方法</li>
<li>3.配置拦截路径</li>
</ul>
<h5 id="web-xml的配置"><a href="#web-xml的配置" class="headerlink" title="web.xml的配置"></a>web.xml的配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;cn.filter.demo1&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&#x2F;&#x2F;拦截路径</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h4 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h4><ul>
<li>1.init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次用于加载资源</li>
<li>2.doFilter:每次拦截资源时被执行，执行很多次。</li>
<li>3.destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。执行一次，用于释放资源。</li>
</ul>
<h4 id="拦截路径的配置"><a href="#拦截路径的配置" class="headerlink" title="拦截路径的配置"></a>拦截路径的配置</h4><ul>
<li>1.具体的资源路径:/index.jsp    只有访问index.jsp资源时，过滤器才会被执行</li>
<li>2.目录拦截:  /user/*    访问/user下的所有资源时，过滤器都会被执行</li>
<li>3.后缀名拦截： *.jsp   访问所有后缀名为jsp的资源时，过滤器都会被执行</li>
<li>4.拦截所有资源： /*    访问所有资源时，过滤器都会被执行</li>
</ul>
<h4 id="拦截方式的配置"><a href="#拦截方式的配置" class="headerlink" title="拦截方式的配置"></a>拦截方式的配置</h4><pre><code>注解配置：
    1.REQUEST:默认值 浏览器直接请求资源
    2.FORWARD:转发访问资源
    3.INCLUDE:包含访问资源
    4.ERROR:错误跳转
    5.ASYNC:异步访问资源 </code></pre><h4 id="过滤器先后顺序问题"><a href="#过滤器先后顺序问题" class="headerlink" title="过滤器先后顺序问题"></a>过滤器先后顺序问题</h4><pre><code>1.注解配置:按照类名的字符串比较规则比较，值小的先执行
2.web.xml配置:&lt;filter-mappping&gt;谁定义在前面，谁先执行</code></pre><h4 id="登录案例"><a href="#登录案例" class="headerlink" title="登录案例"></a>登录案例</h4><h5 id="判断是否登录"><a href="#判断是否登录" class="headerlink" title="判断是否登录"></a>判断是否登录</h5><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><pre><code>1.判断是否是登录的相关资源
* 是 直接放行
* 不是 判断是否登录
2.判断当前用户是否登录，判断Session是否有user
* 有  已经登录  放行
* 没有  没有登录   跳转到登录页面</code></pre><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.test.web.filter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 登录验证的过滤器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@WebFilter(&quot;&#x2F;*&quot;)</span><br><span class="line">public class loginFilter implements Filter &#123;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;0.强制转换</span><br><span class="line">        HttpServletRequest request &#x3D; (HttpServletRequest) req;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.获取请求资源的路径</span><br><span class="line">        String uri &#x3D; request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.判断是否包含登录相关的路径</span><br><span class="line">        if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;&#x2F;loginServlet&quot;) || uri.contains(&quot;&#x2F;checkcodeServlet&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;))&#123;</span><br><span class="line">            &#x2F;&#x2F;放行</span><br><span class="line">            chain.doFilter(req, resp);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;不包含  需要验证用户是否登录</span><br><span class="line">            &#x2F;&#x2F;从Session获取user</span><br><span class="line">            Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">            if (user!&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;登录了  放行</span><br><span class="line">                chain.doFilter(req, resp);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                &#x2F;&#x2F;没有登录  跳转登录页面</span><br><span class="line">                request.setAttribute(&quot;login_msg&quot;,&quot;您尚未登录，请登录&quot;);</span><br><span class="line">                request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="敏感词汇过滤"><a href="#敏感词汇过滤" class="headerlink" title="敏感词汇过滤"></a>敏感词汇过滤</h4><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><pre><code>1.对request对象进行增强。增强获取参数相关方法
2.放行。爨地代理对象</code></pre><h5 id="增强对象的功能"><a href="#增强对象的功能" class="headerlink" title="增强对象的功能"></a>增强对象的功能</h5><pre><code>设计模式：一些通用的解决固定问题的方式
* 1.装饰模式
* 2.代理模式

实现步骤：
    - 1.代理对象和真实对象实现相同的接口
    - 2.代理对象  =  Proxy.newProxyInstance();
    - 3.使用代理对象调用方法
    - 4.增强方法 
增强方式：
    - 1.增强参数列表
    - 2.增强返回值类型
    - 3.增强方法体执行逻辑</code></pre><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.test.web.filter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 敏感词汇过滤器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@WebFilter(&quot;&#x2F;*&quot;)</span><br><span class="line">public class sensitiveWordsFilter implements Filter &#123;</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;创建代理对象，增强getParameter方法</span><br><span class="line">        ServletRequest proxy_req &#x3D; (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                &#x2F;&#x2F;判断是否是getParameter</span><br><span class="line">                if (method.getName().equals(&quot;getParameter&quot;))&#123;</span><br><span class="line">                    &#x2F;&#x2F;增强返回值</span><br><span class="line">                    &#x2F;&#x2F;获取返回值</span><br><span class="line">                    String value &#x3D; (String) method.invoke(req,args);</span><br><span class="line">                    if (value !&#x3D; null)&#123;</span><br><span class="line">                        for (String str:list)&#123;</span><br><span class="line">                            if (value.contains(str))&#123;</span><br><span class="line">                                value &#x3D; value.replaceAll(str,&quot;***&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return value;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;判断是否是getParameterMap</span><br><span class="line">                if (method.getName().equals(&quot;getParameterMap&quot;))&#123;</span><br><span class="line">                    &#x2F;&#x2F;由request得到的原数组不可改变，他是被锁住的，所以这里创建一个新数组来复制原数组，返回新的数组</span><br><span class="line">                    &#x2F;&#x2F;其实想法很想简单，既然传递进来的映射不可改变，那么自己new一个出来不就行了</span><br><span class="line">                    Map&lt;String,String[]&gt; map1 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                    Map&lt;String,String[]&gt; map &#x3D; (Map&lt;String, String[]&gt;) method.invoke(req,args);</span><br><span class="line">                    Set&lt;String&gt; keySet &#x3D; map.keySet();</span><br><span class="line"></span><br><span class="line">                    if (keySet !&#x3D; null)&#123;</span><br><span class="line">                        for (String str:list)&#123;</span><br><span class="line">                            for (String key:keySet)&#123;</span><br><span class="line">                                String[] values &#x3D; map.get(key);</span><br><span class="line">                                for (int i&#x3D;0;i&lt;values.length;i++)&#123;</span><br><span class="line">                                    String value &#x3D; values[i];</span><br><span class="line">                                    if (value.contains(str))&#123;</span><br><span class="line">                                        value &#x3D; value.replaceAll(str,&quot;***&quot;);</span><br><span class="line">                                        values[i] &#x3D; value;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;map1.put(key,values);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return map1;</span><br><span class="line">                &#125;</span><br><span class="line">                return method.invoke(req,args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;放行</span><br><span class="line">        chain.doFilter(proxy_req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    private List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F;敏感词汇</span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;获取文件真实路径</span><br><span class="line">            ServletContext context &#x3D; config.getServletContext();</span><br><span class="line">            String realPath &#x3D; context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;敏感词汇.txt&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;读取文件</span><br><span class="line">            BufferedReader br &#x3D; new BufferedReader(new FileReader(realPath));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将文件的每一行数据添加到list集合中</span><br><span class="line">            String line &#x3D; null;</span><br><span class="line">            while ((line&#x3D;br.readLine())!&#x3D;null)&#123;</span><br><span class="line">                list.add(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            br.close();&#x2F;&#x2F;释放资源</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记(二)</title>
    <url>/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<p>Spring学习笔记</p>
<a id="more"></a>

<h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h3><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    别名，如果添加了别名，我们也可以使用别名获取到对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">alias</span>=<span class="string">"USER"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id：Bean的唯一标识符，也就是相当于我们的对象名</span></span><br><span class="line"><span class="comment">    class:对象对应的全限定名</span></span><br><span class="line"><span class="comment">    name：也是别名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>这个import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。</p>
<h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><h4 id="Set方式注入【重点】"><a href="#Set方式注入【重点】" class="headerlink" title="Set方式注入【重点】"></a>Set方式注入【重点】</h4><p>实体类属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br></pre></td></tr></table></figure>

<p>xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"books"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbys"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打篮球<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>敲代码<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"身份证"</span> <span class="attr">value</span>=<span class="string">"123456789"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"银行卡"</span> <span class="attr">value</span>=<span class="string">"987654321"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"games"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>CS<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>PUBG<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wife"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"学号"</span>&gt;</span>2019052531<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"性别"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="拓展方式注入"><a href="#拓展方式注入" class="headerlink" title="拓展方式注入"></a>拓展方式注入</h4><h5 id="P命名空间注入"><a href="#P命名空间注入" class="headerlink" title="P命名空间注入"></a>P命名空间注入</h5><p>需要添加xml约束</p>
<p><code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    p命名空间注入，可以直接注入属性的值:property--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.User"</span> <span class="attr">p:name</span>=<span class="string">"李四"</span> <span class="attr">p:age</span>=<span class="string">"23"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="C命名空间注入"><a href="#C命名空间注入" class="headerlink" title="C命名空间注入"></a>C命名空间注入</h5><p>需要添加xml约束</p>
<p><code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    c命名空间注入，通过构造器注入：construct-args--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.User"</span> <span class="attr">c:name</span>=<span class="string">"王五"</span> <span class="attr">c:age</span>=<span class="string">"38"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><table>
<thead>
<tr>
<th align="left">Scope</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a></td>
<td align="left">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-prototype" target="_blank" rel="noopener">prototype</a></td>
<td align="left">Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-request" target="_blank" rel="noopener">request</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-session" target="_blank" rel="noopener">session</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-application" target="_blank" rel="noopener">application</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/web.html#websocket-stomp-websocket-scope" target="_blank" rel="noopener">websocket</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody></table>
<p>1.单例模式(Spring默认机制)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.User"</span> <span class="attr">p:name</span>=<span class="string">"李四"</span> <span class="attr">p:age</span>=<span class="string">"23"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.原型模式：每次从容器get的时候，都会产生一个新对象！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.User"</span> <span class="attr">c:name</span>=<span class="string">"王五"</span> <span class="attr">c:age</span>=<span class="string">"38"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.其余的request，session，application这些只能在web开发中用到</p>
<h3 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h3><ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文中寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种装配的方式</p>
<ol>
<li>在xml中显式的配置</li>
<li>在java中显式的配置</li>
<li>隐式的自动装配bean【重要】</li>
</ol>
<h4 id="ByName自动装配"><a href="#ByName自动装配" class="headerlink" title="ByName自动装配"></a>ByName自动装配</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.People"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>autowire=&quot;byName&quot;</code></p>
<p>ByName：会自动在容器上下文中查找，和自己对象set方法后面的值对象的beanid！</p>
<hr>
<h4 id="Bytype自动装配"><a href="#Bytype自动装配" class="headerlink" title="Bytype自动装配"></a>Bytype自动装配</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.People"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>autowire=&quot;byType&quot;</code></p>
<p>ByType：会自动在容器上下文中查找，和自己对象属性类型相同的bean</p>
<p><strong>小结：</strong></p>
<ul>
<li>byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！</li>
<li>bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一样</li>
</ul>
<h4 id="使用注解实现自动装配"><a href="#使用注解实现自动装配" class="headerlink" title="使用注解实现自动装配"></a>使用注解实现自动装配</h4><p>1.导入约束：context约束</p>
<p>2.配置注解的支持：<a href="context:annotation-config/">context:annotation-config/</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>@Autowired</strong></p>
<p>直接在属性上使用即可！也可以在set方法上使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Cat cat;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<p>使用Autowird我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC容器存在</p>
<p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value=”xxxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！</p>
<h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><p>在Spring4之后，需要使用注解开发，必须要保证aop的包导入了</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200604155231.png" alt=""></p>
<p>使用注解需要导入context约束，增加注解的支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    指定要扫描的包，这个包下的注解就会生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.demospring"</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>@Component</strong>:组件，放在类上，说明这个类被Spring管理了，就是Bean！</p>
</blockquote>
<hr>
<p>注入属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/4 16:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于    &lt;bean id="user" class="com.demospring.pojo.User"&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//相当于&lt;property name="name" value="张三"/&gt;</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">public</span> String name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>衍生的注解</p>
<p>@Component有几个衍生注解，我们在web开发中，会按照MVC三成架构分层    </p>
<ul>
<li>dao【@Repository】</li>
<li>service【@Service】</li>
<li>controller【@Controller】</li>
</ul>
<p>这四个注解的功能都是一样的，都是代表将某个类注册到Spring容器中装配</p>
<hr>
<p>作用域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="使用Java的方式配置Spring"><a href="#使用Java的方式配置Spring" class="headerlink" title="使用Java的方式配置Spring"></a>使用Java的方式配置Spring</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demospring.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demospring.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/4 17:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这个也会被Spring容器托管，注册到容器中，因为它本来就是一个@Component</span></span><br><span class="line"><span class="comment">//@Configuration代表这是一个配置类，就和我们之前看的bean.xml</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册一个Bean，就相当于我们之前写的一个bean标签</span></span><br><span class="line">    <span class="comment">//这个方法的名字，就相当于bean标签中的id属性</span></span><br><span class="line">    <span class="comment">//这个方法的返回值，就相当于bena标签的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();<span class="comment">//就是返回要注入到bean的对象！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Spring框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/05/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>Java多线程笔记</p>
<a id="more"></a>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>说起进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念</li>
<li>而进程则是<strong>执行程序的一次执行过程</strong>，它是一个动态概念。是系统资源分配的单位</li>
<li>通常一个进程可以包含若干个<strong>线程</strong>，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位。</li>
</ul>
<h3 id="本章核心概念"><a href="#本章核心概念" class="headerlink" title="本章核心概念"></a>本章核心概念</h3><ul>
<li>线程就是独立的执行路径</li>
<li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程mian，gc线程</li>
<li>main()称为主线程，为系统入口，用于执行整个程序</li>
<li>在一个线程中，如果开辟了多个线程，线程的运行有调度器安排调度，调度器是与操作系统机密相关的，先后顺序是不能认为的干预的</li>
<li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如cpu调度时间，并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p><strong>三种创建方式：</strong></p>
<ul>
<li>继承Thread类(重点)</li>
<li>实现Runnable接口(重点)</li>
<li>实现Callable(了解)</li>
</ul>
<h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>1.自定义线程类继承Thread类</p>
<p>2.重写run()方法，编写线程执行体</p>
<p>3.创建线程对象，调用start()方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"run方法"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程对象，调用start方法开启线程</span></span><br><span class="line">        TestThread testThread = <span class="keyword">new</span> TestThread();</span><br><span class="line">        testThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程实现网图下载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联系Thread，实现多线程同步下载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">//网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//保存的文件名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载图片的线程执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">        webDownloader.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为："</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread2 testThread1 = <span class="keyword">new</span> TestThread2(<span class="string">"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%911.png"</span>,<span class="string">"D:/a_test/1.jpg"</span>);</span><br><span class="line">        TestThread2 testThread2 = <span class="keyword">new</span> TestThread2(<span class="string">"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%912.png"</span>,<span class="string">"D:/a_test/2.jpg"</span>);</span><br><span class="line">        TestThread2 testThread3 = <span class="keyword">new</span> TestThread2(<span class="string">"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%913.png"</span>,<span class="string">"D:/a_test/3.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        testThread1.start();</span><br><span class="line">        testThread2.start();</span><br><span class="line">        testThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span></span>&#123;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h4><p>1.实现MyRunnable类实现<strong>Runnable</strong>接口</p>
<p>2.实现run()方法，编写线程执行体</p>
<p>3.创建线程对象，调用start()方法启动线程 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run方法"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建runnable接口的实现类</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象开启线程，代理</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testThread3);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new Thread(new TestThread3()).start();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>继承Thread类<ul>
<li>子类继承Thread类具备多线程能力</li>
<li>启动线程：子类对象.start()</li>
<li>不建议使用：避免OOP单继承局限性</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>实现Runnable具有多线程能力</li>
<li>线程启动：传入目标对象+Thread对象.start()</li>
<li>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</li>
</ul>
</li>
</ul>
<h3 id="初识并发问题"><a href="#初识并发问题" class="headerlink" title="初识并发问题"></a>初识并发问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个线程操作一个对象</span></span><br><span class="line"><span class="comment"> * 买火车票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟延迟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"----&gt;拿到了第"</span>+ticketNums--+<span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread4 t4 = <span class="keyword">new</span> TestThread4();</span><br><span class="line">        <span class="keyword">new</span> Thread(t4,<span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t4,<span class="string">"老师"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t4,<span class="string">"黄牛"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200528183201.png" alt=""></p>
<p><strong>发现问题：</strong>多个线程操作同一个资源的情况下，线程不安全，数据紊乱</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200529163523.png" alt=""></p>
<p>Thread.State</p>
<ul>
<li><p>NEW</p>
<p>​    尚未启动的线程处于此状态</p>
</li>
<li><p>RUNNABLE</p>
<p>​    在Java虚拟机中执行的线程处于此状态</p>
</li>
<li><p>BLOCKED</p>
<p>​    阻塞等待监视器锁定的线程处于此状态</p>
</li>
<li><p>WAITTING</p>
<p>​    正在等待另一个线程执行特定动作的线程处于此状态</p>
</li>
<li><p>TIMED_WATTING</p>
<p>​    正在等待另一个线程执行动作达到指定等待时间的线程处于此状态</p>
</li>
<li><p>TERMINATED</p>
<p>​    已退出的线程处于此状态</p>
</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级来决定应该调度哪个线程先执行</p>
<p><strong>线程的优先级用数字表示,范围1~10</strong></p>
<ul>
<li>Thread.MIN_PRIORITY = 1;</li>
<li>Thread.MAX_PRIORITY = 10;</li>
<li>Thread.NORM_PRIORITY = 5;</li>
</ul>
<p>使用以下方式改变和获取优先级</p>
<p><code>getPriority()   setPriority(int xxx)</code></p>
<p><strong>注意：优先级低只是意味这获得调度的概率低，并不是优先级低就不会被调用了，这都看cpu的调度</strong></p>
<h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setPriority(int newPriority)</td>
<td>更改线程的优先级</td>
</tr>
<tr>
<td>static void sleep(long millis)</td>
<td>在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td>void join()</td>
<td>等待该线程终止</td>
</tr>
<tr>
<td>static void yield()</td>
<td>暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
<tr>
<td>void interrupt()</td>
<td>中断线程，别用这个方式</td>
</tr>
<tr>
<td>boolean isAlive()</td>
<td>测试线程是否处于活动状态</td>
</tr>
</tbody></table>
<h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><ul>
<li>不推荐使用JDK提供的stop()、destory()方法。【已废弃】</li>
<li>推荐线程自己停下来</li>
<li>建议用一个标志位进行终止变量，放flag = false，则终止线程运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试stop</span></span><br><span class="line"><span class="comment"> * 建议线程正常停止--&gt;利用次数，不建议死循环</span></span><br><span class="line"><span class="comment"> * 建议使用标志位--&gt;设置一个标志位</span></span><br><span class="line"><span class="comment"> * 不用使用stop或者destory等过时或者JDK不建议使用的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread5</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"run....Thread"</span>+i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个公开的方法停止线程，转换标志位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread5 thread5 = <span class="keyword">new</span> TestThread5();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread5).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">900</span>)&#123;</span><br><span class="line">                <span class="comment">//调用stop方法切换标志位，让线程停止</span></span><br><span class="line">                thread5.stop();</span><br><span class="line">                System.out.println(<span class="string">"线程该停止了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><ul>
<li>sleep(时间)指定当前路线阻塞的毫秒数</li>
<li>sleep存在异常InterruptedException</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>sleep可以模拟网络延迟，倒计时等</li>
<li>每一个对象都有一个锁，sleep不会释放锁</li>
</ul>
<h4 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h4><ul>
<li>线程礼让，让当前正在执行的线程暂停，但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li><strong>让CPU重新调度，礼让不一定成功！看CPU心情</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">"a"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">"b"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"线程开始执行"</span>);</span><br><span class="line">        Thread.yield();<span class="comment">//礼让</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"线程停止执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><ul>
<li>Join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞</li>
<li>可以想象成插队</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>虚拟机不用等待守护线程执行完毕，如后台记录操作日志，监控内存，垃圾回收等等。</li>
</ul>
<h3 id="线程同步-重点"><a href="#线程同步-重点" class="headerlink" title="线程同步(重点)"></a>线程同步(重点)</h3><p><strong>并发：多个线程操作同一个资源</strong></p>
<p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程池使用完毕，下一个线程再使用</p>
<p>由于同一进程的多个线程共享同一块存储空间，在带了方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入了<strong>锁机制synchronized</strong>,当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可，存在一下问题：</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题</li>
</ul>
<p>由于我们可以通private关键字来保证数据对象只能被方法访问，所有我们只需要对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块</p>
<p><code>同步方法：public synchronized void method(int args){}</code></p>
<p>synchronized方法控制对”对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。</p>
<div class="note warning"><p>缺陷：若将一个大的方法申明为synchronized将会影响效率</p></div>

<h4 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h4><p>synchronized(obj){ }</p>
<p>Obj称为<strong>同步监视器</strong></p>
<ul>
<li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。</li>
</ul>
<p>同步监视器的执行过程</p>
<ul>
<li>1.第一个线程访问，锁定同步监视器，执行其中代码</li>
<li>2.第二个线程访问，发现同步监视器被锁定，无法访问</li>
<li>3.第一个线程访问完毕，解锁同步监视器</li>
<li>4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程各自占有一些资源，并且相互等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情况。某一个同步块同时拥有“两个以上对象的锁”时就可能会发生“死锁问题”。</p>
<h4 id="死锁避免的方法"><a href="#死锁避免的方法" class="headerlink" title="死锁避免的方法"></a>死锁避免的方法</h4><p>产生死锁的四个必要条件</p>
<ul>
<li>1.互斥条件：一个资源每次只能被一个进程使用</li>
<li>2.请求与保持条件：一个进程因请求资源时而被阻塞，对己获得的资源保持不放</li>
<li>3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>4.循环等待条件：若干进程之间实现了一种头尾相接的循环等待资源关系</li>
</ul>
<div class="note success"><p>上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或者多个条件就可以避免死锁发生</p></div>



<h3 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h3><ul>
<li>从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象实现同步。同步锁使用Lock对象充当</li>
<li>java.util.concurrent.locks.Lock接口时控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</li>
<li>ReentrantLock实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比价常用的是ReentrantLock，可以显式加锁，释放锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/31 10:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket buyTicket = <span class="keyword">new</span> BuyTicket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket,<span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket,<span class="string">"小红"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(buyTicket,<span class="string">"黄牛"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticketNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();<span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> (ticketNum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"买到了"</span>+ticketNum--);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized与Lock的对比"><a href="#synchronized与Lock的对比" class="headerlink" title="synchronized与Lock的对比"></a>synchronized与Lock的对比</h4><ul>
<li>Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)synchronized是隐式锁，出了作用域会自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)</li>
<li>优先使用顺序<ul>
<li>Lock&gt;同步代码块(已经进入了方法体，分配相应资源)&gt;同步方法(在方法体之外)</li>
</ul>
</li>
</ul>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>Java提供了几个方法解决线程之间的通信问题</p>
<hr>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>wait()</td>
<td>表示线程一直等待，知道线程通知，与sleep不同，会释放锁</td>
</tr>
<tr>
<td>wait(long timeout)</td>
<td>指定等待的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个正处于等待状态的线程</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td>
</tr>
</tbody></table>
<div class="note "><p>注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常lllegalMonitorStateException</p></div>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>背景：经常创建和销毁使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p>
<p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁的创建和销毁、实现重复利用。类似生活中的交通工具</p>
<p>好处：</p>
<ul>
<li>提高相应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中的线程，不需要每次创建)</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后终止</li>
</ul>
</li>
</ul>
<h4 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h4><p>JDK5.0起提供了线程池相关API：<strong>ExecutorService</strong>和<strong>Executors</strong></p>
<ul>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExector<ul>
<li>void execute(Runnnable command):执行任务/命令，没有返回值，一般用于执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task):执行任务，有返回值，一般用于执行Callable</li>
<li>void shutdown()：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/31 14:58</span></span><br><span class="line"><span class="comment"> * 测试线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记(一)</title>
    <url>/2020/06/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<p>Spring学习笔记</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p><strong>简介</strong>：Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从</p>
</li>
<li><p><strong>Spring理念</strong>：使现有的技术更加容易使用，本身是一个大杂烩，整合现有的技术框架！</p>
</li>
<li><p><strong>SSM</strong>：SpringMvc + Spring +  Mybatis！</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：<ol>
<li>Spring是一个开源的免费的框架(容器)！</li>
<li>Spring一个轻量级的、非入侵式的框架</li>
<li>控制反转(IOC)，面向切面编程(AOP)</li>
<li>支持事务的处理,对框架整合的支持</li>
</ol>
</li>
<li>总结：Spring就是一个轻量级的控制反转(IOC)和切面编程的框架！</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200601152845.png" alt=""></p>
<p><strong>核心容器（Spring Core）</strong></p>
<p>　　核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</p>
<p><strong>应用上下文（Spring Context）</strong></p>
<p>　　Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p>
<p><strong>Spring面向切面编程（Spring AOP）</strong></p>
<p>　　通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
<p><strong>JDBC和DAO模块（Spring DAO）</strong></p>
<p>　　JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</p>
<p><strong>对象实体映射（Spring ORM）</strong></p>
<p>　　Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。</p>
<p><strong>Web模块（Spring Web）</strong></p>
<p>　　Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p>
<p><strong>MVC模块（Spring Web MVC）</strong></p>
<p>　　MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</p>
<h3 id="IOC理论"><a href="#IOC理论" class="headerlink" title="IOC理论"></a>IOC理论</h3><p>控制反转Ioc(Inversion of Control)，是一种设计思想，DI(依赖注入)式实现IoC的一种方法，也有人认为Di只是Ioc的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象创建转移给第三方，个人认为所谓的控制反转就是：获得依赖对象的方式反转了</p>
<p>采用XML配置Bean的时候，Bean的定义信息是和实现分离的，而采用注入的方式可以把二者和为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到零配置的目的</p>
<p><strong>控制反转是一种通过描述(XML或注解)并通过第三方去生产或者获取特定对象的方式。在Spring中实现控制反转的是Ioc容器，其实现方法是依赖注入(Dependency Injection,DI)</strong></p>
<p>由容器动态地将某种依赖关系注入到组件之间。<br>控制反转也称为”依赖注入“（Dependency Injection DI)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20180731111256629.jpg" alt=""></p>
<p>IoC/DI示例：<br>依赖注入是Java编程思想中”面向接口编程“的体现，因此在设计程序是，对于程序所依赖的组件往往以忌口的形式出现，而不直接使用具体的实现类</p>
<h3 id="第一个Spring程序"><a href="#第一个Spring程序" class="headerlink" title="第一个Spring程序"></a>第一个Spring程序</h3><ul>
<li><strong>besns.xml</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.demospring.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>测试代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.demospring.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/2 17:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        User user = (User) context.getBean(<span class="string">"user"</span>);</span><br><span class="line">        user.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实体类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demospring.pojo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/2 17:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name---&gt;"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：在配置文件加载的时候，容器中的管理对象就已经初始化了！</p>
]]></content>
      <tags>
        <tag>Spring框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains系列产品2020.1最新激活方法</title>
    <url>/2020/04/15/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%812020-1%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。</p>
<a id="more"></a>

<p>大家熟知Jetbrains的话应该知道：他们家的所有产品升级到2018.2.1及以上版本后，先前可用的注册服务器都失效了，无法激活升级到最新版本体验最新黑科技。</p>
<p>这次要送的这份礼就是： Jetbrains全系列产品2020.1及以下版本（理论上适用于目前所有新老版本）最新注册服务器（License Server）的破解，可使用它来激活你手头上的Jetbrains IDE，具体支持产品和版本见下文的列表。</p>
<p>传送门:</p>
<p><a href="https://pan.baidu.com/s/1W7NDVhEd6J6mpN3-PoXFQA" target="_blank" rel="noopener">百度云下载</a>    提取码：w26y </p>
<hr>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><ul>
<li><p>0.先下载压缩包解压后得到jetbrains-agent.jar。</p>
</li>
<li><p>1.启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。</p>
<ul>
<li>2.将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。（事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题）</li>
<li>3.在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮。</li>
<li>4.重启IDE，搞定。</li>
<li>x. 支持两种注册方式：License server 和 Activation code:<ul>
<li>1). 选择License server方式，地址填入：<a href="https://fls.jetbrains-agent.com" target="_blank" rel="noopener">https://fls.jetbrains-agent.com</a> （HTTP也可用，网络不佳用第2种方式）</li>
<li>2). 选择Activation code方式离线激活，请使用：ACTIVATION_CODE.txt 内的注册码激活<br>  License key is in legacy format == Key invalid，表示agent配置未生效。<br>  如果你需要自定义License name，请访问：<a href="https://zhile.io/custom-license.html" target="_blank" rel="noopener">https://zhile.io/custom-license.html</a></li>
<li>3). 现在你可以使用jetbrains-agent + activation code/license server激活jetbrains平台的付费插件了！<br>  现有Jetbrains付费插件Activation code: <a href="https://zhile.io/jetbrains-paid-plugins-license.html" target="_blank" rel="noopener">https://zhile.io/jetbrains-paid-plugins-license.html</a><br>  现在有这些付费插件：<a href="https://plugins.jetbrains.com/search?isPaid=true" target="_blank" rel="noopener">https://plugins.jetbrains.com/search?isPaid=true</a></li>
</ul>
</li>
</ul>
<p>本项目在最新2020.1上测试通过。<br>理论上适用于目前Jetbrains全系列所有新老版本。<br>IDE升级会从旧版本导入以上设置，导入配置后可能提示未注册（因为刚导入的vmoptions未生效），直接重启IDE即可，无需其他操作。</p>
</li>
</ul>
<p> 本项目只做学习研究之用，不得用于商业用途！</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery笔记</title>
    <url>/2020/04/26/JQuery%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="JQuery笔记"><a href="#JQuery笔记" class="headerlink" title="JQuery笔记"></a>JQuery笔记</h2><a id="more"></a>
<pre><code>概念：一个JavaScript框架，简化JS开发
使用步骤：
    1.下载JQuery
    2.导入JQuery的js文件  导入min.js
    3.使用
JQuery对象和JS对象的区别
    方法不互通
    转换：
        jq -&gt; js  : jq对象[索引] 或者 jp对象.get(索引)
        js -&gt; jq  : $(js对象)</code></pre><h3 id="选择器：筛选具有相似特征的元素-标签"><a href="#选择器：筛选具有相似特征的元素-标签" class="headerlink" title="选择器：筛选具有相似特征的元素(标签)"></a>选择器：筛选具有相似特征的元素(标签)</h3><h4 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1.基本选择器"></a>1.基本选择器</h4><ul>
<li><p>1.标签选择器(元素选择器)</p>
<pre><code>`$(&quot;html标签名&quot;)`  获得所有匹配标签名称的元素</code></pre></li>
<li><p>2.id选择器</p>
<pre><code>`$(&quot;#id的属性值&quot;)`  获得与指定id值匹配的元素</code></pre></li>
<li><p>3.类选择器</p>
<pre><code>`$(&quot;.class的属性&quot;)`   获得与指定的class属性值相匹配的元素</code></pre><h4 id="2-层级选择器"><a href="#2-层级选择器" class="headerlink" title="2.层级选择器"></a>2.层级选择器</h4></li>
<li><p>1.后代选择器：</p>
<pre><code>`$(&quot;A B&quot;)`  选择A元素所有内部的B元素</code></pre></li>
<li><p>2.子选择器</p>
<pre><code>`$(&quot;A &gt; B&quot;)` 选择A元素内部的所有B子元素</code></pre></li>
<li><p>3.属性选择器</p>
<pre><code>1.属性名称选择器
$(&quot;A[属性名]&quot;)    包含指定属性的选择器
2.属性选择器
$(&quot;A[属性名=&apos;值&apos;]&quot;)   包含指定属性等于指定值的选择器
3.符合属性选择器
$(&quot;A[属性名=&apos;值&apos;][ ]...&quot;)   包含多个属性条件的选择器</code></pre></li>
<li><p>4.过滤选择器</p>
<pre><code>1.首元素选择器
    :first  获得选择的元素中第一个元素
2.尾元素选择器
    :last  获得选择的元素中最后一个元素
3.非元素选择器
    not(.selector)   不包括指定内容的元素
4.偶数选择器
    even   偶数，从0开始计数
5.奇数选择器
    odd  奇数 ，从0开始
6.等于索引选择器
    eq(index)  指定索引元素
7.大于索引选择器
    gt(index)  大于指定索引选择器
8.小于索引选择器
    lt(index)  小于指定索引选择器
9.标题选择器
    header  获得标题(h1-h6)元素，固定写法</code></pre></li>
<li><p>5.表单过滤选择器</p>
<pre><code>1.可用元素选择器
    :enabled  获得可用元素
2.不可以用元素选择器
    :disabled  获得不可用元素
3.选中选择器
    :checked  获得单选，复选框中的元素
4.选中选择器
    :selected   获得下拉框中选中的元素</code></pre></li>
</ul>
<h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><h4 id="1-内容操作"><a href="#1-内容操作" class="headerlink" title="1.内容操作"></a>1.内容操作</h4><ul>
<li><p>1.<code>html()</code> ： 获取/设置元素的标签体内容， <a><font>内容</font></a> –&gt;  <font>内容</font></p>
</li>
<li><p>2.<code>text()</code>  ： 获取/设置元素标签体纯文本内容  <a><font>内容</font></a> –&gt;  内容</p>
</li>
<li><p>3.<code>val()</code>  :   获取/设置元素的属性值</p>
<h4 id="2-属性操作"><a href="#2-属性操作" class="headerlink" title="2.属性操作"></a>2.属性操作</h4></li>
<li><p>1.通用属性操作</p>
<pre><code>1.attr()                  获取/设置元素的属性
2.removeAttr()     删除属性
3.prop()                获取/设置元素的属性
4.removeProp()    删除属性
*attr和prop的区别
    如果操作的是元素的固有属性，则建议使用prop
    如果操作的是元素的自定义属性，则建议是attr</code></pre></li>
<li><p>2.对class属性操作 </p>
<pre><code>    1.addClass()      添加class属性值
    2.removeClass() 删除class属性值
    3.toggleClass()   切换class属性值
3.CRUD操作
    1.append(): 父元素将子元素追加到末尾
            - 对象1.append(对象2)：将对象2添加到对象1元素内部，并且在末尾
    2.prepend():父元素将子元素追加到开头
            -对象1.prepend(对象2)：将对象2添加到对象1元素内部，并且在开头
    3.appendto():
    4.prependto():

    5.after():添加元素到元素后边
    6.before()：将元素添加到元素前边
    7.insertAfter():
    8.insertBrfore():
    9.remove()：删除元素
    10.empty()：清空元素的所有后代元素</code></pre><h3 id="JQuery高级"><a href="#JQuery高级" class="headerlink" title="JQuery高级"></a>JQuery高级</h3><h4 id="1-动画"><a href="#1-动画" class="headerlink" title="1.动画"></a>1.动画</h4></li>
<li><p>1.三种方式显示和隐藏元素</p>
<pre><code>1.show([speed,[easing],[fn]])
2.hide([speed,[easing],[fn]])
3.toggle([speed],[easing],[fn])</code></pre></li>
<li><p>2.滑动显示和隐藏方式</p>
<pre><code>1.slideDown([speed],[easing],[fn])
2.slideUp([speed,[easing],[fn]])
3.slieToggle([speed],[easing],[fn])</code></pre></li>
<li><p>3.淡入淡出的显示和隐藏方式</p>
<pre><code>1.fadeIn([speed],[easing],[fn])
2.fadeOut([speed],[easing],[fn])
3.fadeToggle([speed,[easing],[fn]])</code></pre><h4 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h4></li>
<li><p>1.<code>jq对象.each(callback)</code></p>
</li>
<li><p>2.<code>$.each(object,[callback])</code></p>
</li>
<li><p>3.<code>for..of:</code></p>
<h4 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3.事件绑定"></a>3.事件绑定</h4><pre><code> 1.jquery标准的绑定方式
     jq对象.事件方法(回调函数)
 2.on绑定事件/off绑定事件
     jq对象.on(&quot;事件名称&quot;,回调函数)
     jq对象.off(&quot;事件名称&quot;)
3.事件切换
     jq对象.toggle(fn1,fn2...)</code></pre></li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><pre><code>1.当页面加载完后。3秒后，自动显示广告
2.当广告显示5秒后自动消失</code></pre><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;*需求：</span><br><span class="line">         1.当页面加载完后。3秒后，自动显示广告</span><br><span class="line">         2.当广告显示5秒后自动消失</span><br><span class="line">         分析：</span><br><span class="line">         1.使用定时器来完成。setTimeout(执行一次)</span><br><span class="line">         2.JQuery的动画效果就是控制display属性</span><br><span class="line">        *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;入口函数，在页面加载完成后定义定时器，调用这两个方法</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            &#x2F;&#x2F;定时器 调用adShow()方法</span><br><span class="line">            setTimeout(adShow,3000);</span><br><span class="line"></span><br><span class="line">            setTimeout(adHide,8000);</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F;显示广告方法</span><br><span class="line">        function adShow() &#123;</span><br><span class="line">            &#x2F;&#x2F;获取广告div 调用show方法</span><br><span class="line">            $(&quot;#ad&quot;).show(&quot;slow&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;隐藏广告方法</span><br><span class="line">        function adHide() &#123;</span><br><span class="line">            $(&quot;#ad&quot;).hide(&quot;slow&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;ad&quot; style&#x3D;&quot;display: none;&quot;&gt;</span><br><span class="line">        &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;广告.jpg&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id&#x3D;&quot;content&quot;&gt;</span><br><span class="line">        正文部分</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="需求：-1"><a href="#需求：-1" class="headerlink" title="需求："></a>需求：</h4><p>抽奖案例</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;抽奖&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        分析：</span><br><span class="line">        1.给开始按钮绑定单击事件</span><br><span class="line">            1.1定义循环定时器</span><br><span class="line">            1.2切换小相框的src属性</span><br><span class="line">                定义一个数组，存放图片资源的路径</span><br><span class="line">                生成随机数 数组索引</span><br><span class="line">        2.给结束按钮绑定单击事件</span><br><span class="line">            2.1停止定时器</span><br><span class="line">            2.2给大相框设置src属性</span><br><span class="line">         *&#x2F;</span><br><span class="line">        var imgs &#x3D; [&quot;..&#x2F;img&#x2F;1.jpg&quot;,&quot;..&#x2F;img&#x2F;2.jpg&quot;,&quot;..&#x2F;img&#x2F;3.jpg&quot;,&quot;..&#x2F;img&#x2F;4.jpg&quot;,&quot;..&#x2F;img&#x2F;5.jpg&quot;,&quot;..&#x2F;img&#x2F;6.jpg&quot;,&quot;..&#x2F;img&#x2F;0.jpg&quot;]</span><br><span class="line">        var startId;&#x2F;&#x2F;开始定时器的一个Id</span><br><span class="line">        var index;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            &#x2F;&#x2F;开始按钮</span><br><span class="line">            $(&quot;#startID&quot;).click(function () &#123;</span><br><span class="line">                startId &#x3D; setInterval(function () &#123;</span><br><span class="line">                    &#x2F;&#x2F;生成随机角标</span><br><span class="line">                    index &#x3D; Math.floor(Math.random() * 7)</span><br><span class="line">                    &#x2F;&#x2F;设置小相框的src属性</span><br><span class="line">                    $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);</span><br><span class="line">                &#125;,20)</span><br><span class="line">            &#125;)</span><br><span class="line">            &#x2F;&#x2F;结束按钮</span><br><span class="line">            $(&quot;#stopID&quot;).click(function () &#123;</span><br><span class="line">                $(&quot;#stopID&quot;).click(function () &#123;</span><br><span class="line">                    &#x2F;&#x2F;停止定时器</span><br><span class="line">                    clearInterval(startId)</span><br><span class="line">                    $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--小相框--&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;border-style: dotted;width: 160px;height: 100px;&quot;&gt;</span><br><span class="line">    &lt;img id&#x3D;&quot;img1ID&quot; style&#x3D;&quot;width: 160px;height: 100px&quot; src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--大相框--&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;border-style: dotted;height: 500px;position: absolute;left: 500px;top: 10px&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;..&#x2F;img&#x2F;1.jpg&quot; id&#x3D;&quot;img2ID&quot; width&#x3D;&quot;800px&quot;height&#x3D;&quot;600px&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--开始按钮--&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;startID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击开始&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--停止按钮--&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;stopID&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;点击停止&quot; style&#x3D;&quot;width: 150px;height: 50px;font-size: 22px&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>PicGo+GitHub图床，让Markdown飞</title>
    <url>/2020/05/21/PicGo-GitHub%E5%9B%BE%E5%BA%8A%EF%BC%8C%E8%AE%A9Markdown%E9%A3%9E/</url>
    <content><![CDATA[<p>PicGo+GitHub图床</p>
<a id="more"></a>

<p>一次偶然的机会让我接触到Markdown语法，随后便疯狂地爱上了这种<strong>“轻量级标记语言”</strong>。笔记、文章、技术评审文档、业务逻辑文档等等，我都想要使用Markdown去记录。几次寻觅，我找到了两款能够大部分符合我的需求的Markdown编辑器：<strong>Typora</strong>和<strong>马克飞象</strong>。</p>
<p>目前我是两款编辑器混合时候，当编写的Markdown文档需要和印象笔记对接的时候，则使用马克飞象；至于其他用途的文档就使用Typora。则两款编辑器都<strong>近乎完美但是却又不能达到完美</strong>。我写文档的时候经常需要截图，然后从剪贴板从直接黏贴放进文档，则两款编辑器虽然都能满足这种操作，但是其实现原理不过是<strong>将截图存放在本机电脑上</strong>，所以，一旦文档中有了截图，将Markdown文档的迁移到别的电脑上展示的成本就大大增加（图片也要一并复制过去）。</p>
<p>这两款编辑器对图片处理的方法简直是丧尽天良，也是我在使用过程中唯一觉得不爽的一点。辛苦搜寻之下，终于让我找到了一种解决方案：<strong>PicGo+GitHub图床</strong></p>
<blockquote>
<p>注：实际上，Mac OS 上的Typora编辑器已经支持将本地图片或者截图先上传到服务器生成访问链接后，在存放到Markdown文档中，简单点说，Mac OS上的Typora是完美的（😭无奈我是Windows用户）</p>
</blockquote>
<h1 id="PicGo介绍"><a href="#PicGo介绍" class="headerlink" title="PicGo介绍"></a><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo介绍</a></h1><p>这是一款图片上传的工具，目前支持<code>微博图床</code>，<code>七牛图床</code>，<code>腾讯云</code>，<code>又拍云</code>，<code>GitHub</code>等图床，未来将支持更多图床。</p>
<p>所以解决问题的思路就是，将本地的文件，或者剪切板上面的截图发送图床，然后生成在线图片的链接，这样就可以让Markdown文档飞起来了，走到哪就可以用到哪😊。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523183627.png" alt=""></p>
<p>Pic Go支持的图床</p>
<p>在众多的图床中，我选择的GitHub图床，其它类型的图床如果你们有兴趣的话可以试一下。</p>
<h1 id="创建自己的GitHub图床"><a href="#创建自己的GitHub图床" class="headerlink" title="创建自己的GitHub图床"></a>创建自己的GitHub图床</h1><h2 id="1-创建GitHub图床之前，需要注册-登陆GitHub账号"><a href="#1-创建GitHub图床之前，需要注册-登陆GitHub账号" class="headerlink" title="1. 创建GitHub图床之前，需要注册/登陆GitHub账号"></a>1. 创建GitHub图床之前，需要注册/登陆GitHub账号</h2><blockquote>
<p>申请GitHub账号很简单，我就不演示了</p>
</blockquote>
<h2 id="2-创建Repository"><a href="#2-创建Repository" class="headerlink" title="2. 创建Repository"></a>2. 创建Repository</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523183819.png" alt=""></p>
<p>点击”New repository”按钮</p>
<blockquote>
<ul>
<li>我已经建立过一个同名的repository的，所以第一步会显示红色</li>
<li>第三步，为repository初始化一个README.md文件可以根据需求选择，非必选</li>
</ul>
</blockquote>
<h2 id="3-生成一个Token用于操作GitHub-repository"><a href="#3-生成一个Token用于操作GitHub-repository" class="headerlink" title="3.生成一个Token用于操作GitHub repository"></a>3.生成一个Token用于操作GitHub repository</h2><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523183947.png" alt=""></p>
<p>回到主页，点击”Settings”按钮</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184121.png" alt=""></p>
<p>进入页面后，点击”Developer settings”按钮</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184453.png" alt=""></p>
<p>点击”Personal access tokens”按钮</p>
<p>创建新的Token</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184607.png" alt=""><br>填写描述，选择”repo”,然后点击”Generate token”按钮</p>
<blockquote>
<p>注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存</p>
</blockquote>
<h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><h4 id="1-下载运行PicGo"><a href="#1-下载运行PicGo" class="headerlink" title="1. 下载运行PicGo"></a>1. 下载运行PicGo</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200523184734.png" alt=""></p>
<p>推荐下载exe可执行文件</p>
<h4 id="2-配置图床"><a href="#2-配置图床" class="headerlink" title="2. 配置图床"></a>2. 配置图床</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/img/20200521194551.png" alt=""></p>
<p>如图配置</p>
<blockquote>
<ul>
<li>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</li>
<li>分支名统一填写“master”</li>
<li>将之前的Token黏贴在这里</li>
<li>存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹</li>
<li>自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<code>https://raw.githubusercontent.com/用户名/RepositoryName/分支名，</code>，自定义域名需要按照这样去填写</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将上面的步骤都设置好之后，就可以让自己的Markdown文档飞起来了，每次截图之后，都可以按一下<code>ctrl+shift+c</code>，这样就会将剪切板上面的截图转化为在线网络图片链接，简直就是爽的不要不要的！！<br>。</p>
<p>自己在本地用确实没有什么问题，但是提交到博客上发现图片加载失败，或者加载异常慢，于是我发现了一种加速的方法</p>
<h4 id="CDN-简介"><a href="#CDN-简介" class="headerlink" title="CDN 简介"></a><strong>CDN 简介</strong></h4><blockquote>
<p><strong>内容分发网络</strong>（英语：<strong>C</strong>ontent <strong>D</strong>elivery <strong>N</strong>etwork或<strong>C</strong>ontent <strong>D</strong>istribution <strong>N</strong>etwork，缩写：<strong>CDN</strong>）是指一种透过<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2">互联网</a>互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。<br>—— <a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">Wikipedia</a></p>
</blockquote>
<p>简而言之就是让服务器距离大陆较远的 GitHub ，将托管在那里的<strong>静态</strong>资源缓存到一个近一点的服务器，从而加快访问。</p>
<p>看了这样的解释你应该能够理解，CDN 虽然能缓解互联压力，可也是要耗费一定的资源的，从而市面上的 CDN 大多是收费的。Cloudflare 虽然有免费 CDN ，可是国内节点致开放给专业版用户使用，价格偏高，而海外的节点又类似<strong>负优化</strong>，可能还会降低速度。</p>
<h3 id="jsDelivr"><a href="#jsDelivr" class="headerlink" title="jsDelivr"></a><strong>jsDelivr</strong></h3><p><a href="https://link.zhihu.com/?target=https%3A//www.jsdelivr.com/">jsDelivr</a>是一款公共免费 CDN ，调用多家 CDN 保证全球服务质量、拥有多层缓存和灾后保障 SLA 100 。也是为数不多的有 ICP 备案，提供许多中国节点的海外 CDN 服务商。</p>
<p>有搜索引擎，支持一键复制文件 URL 和标签，支持分发 NPM、GitHub、WordPress SVN 的文件</p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h3><p>可能看起来，官方的使用方法十分复杂，但其实就一句话：把仓库链接的域名替换成 jsDelivr 的域名。</p>
<p>如托管在 GitHub 的仓库链接都是 <code>https://github.com/username/repo/branch/file</code> 的形式，而我们就可以将前面的 <code>github.com</code> 改成 jsDelivr 提供加速 GitHub 仓库的域名 <code>cdn.jsdelivr.net/gh</code> 。</p>
<p>嗯，兴冲冲配置一发，发现什么都没有？其实还是有一点点小差别的。比如分支那里，jsDelivr 默认要直接在仓库名后面 <code>@</code> ，所以真正其实是 <code>https://cdn.jsdelivr.net/gh/username/repo@branch/file</code> 的形式。当然，如果你放在仓库的默认分支，还可以直接将 <code>branch</code> 这个关键字直接删了，变成 <code>https://cdn.jsdelivr.net/gh/username/repo/file</code> 一样能获取到！</p>
<p>另外，如果是一些比较稳定的文件，后面不会频繁地改动，还可以发布成一个版本，然后在 <code>repo</code> 后 <code>@version</code> 就可以引用对应的版本。</p>
<h3 id="加速图床"><a href="#加速图床" class="headerlink" title="加速图床"></a><strong>加速图床</strong></h3><p>如果你还记得笔者之前写的 <strong>PicGo + GitHub 搭建免费图床</strong> 的话，不难发现 jsDelivr 也是能加速这个图床（本质不还是一个 GitHub 仓库嘛）的。我们只需要在 <strong>GitHub 图床设置</strong> 中将链接设置为 <code>https://cdn.jsdelivr.net/gh/username/repo</code> 即可！前提是你上传到默认分支。</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>XML解析器</title>
    <url>/2020/04/07/XML%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h3 id="解析：操作xml文档，将文档中的数据读取到内存中"><a href="#解析：操作xml文档，将文档中的数据读取到内存中" class="headerlink" title="解析：操作xml文档，将文档中的数据读取到内存中"></a>解析：操作xml文档，将文档中的数据读取到内存中</h3><a id="more"></a>
<h4 id="操作xml文档"><a href="#操作xml文档" class="headerlink" title="操作xml文档"></a>操作xml文档</h4><ul>
<li><ol>
<li>解析(读取)：将文档中的数据读取到内存中</li>
</ol>
</li>
<li><ol start="2">
<li>写入：将内存中的数据保存到xml文档中。持久化的存储</li>
</ol>
</li>
</ul>
<h3 id="解析xml的方式："><a href="#解析xml的方式：" class="headerlink" title="解析xml的方式："></a>解析xml的方式：</h3><ul>
<li><ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<pre><code>* 优点：操作方便，可以对文档进行CRUD的所有操作
* 缺点：占内存</code></pre></li>
</ol>
</li>
<li><ol start="2">
<li>SAX：逐行读取，基于事件驱动的。<pre><code>* 优点：不占内存。
* 缺点：只能读取，不能增删改</code></pre></li>
</ol>
</li>
</ul>
<h3 id="xml常见的解析器："><a href="#xml常见的解析器：" class="headerlink" title="xml常见的解析器："></a>xml常见的解析器：</h3><ul>
<li><ol>
<li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li>
</ol>
</li>
<li><ol start="2">
<li>DOM4J：一款非常优秀的解析器</li>
</ol>
</li>
<li><ol start="3">
<li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li>
</ol>
</li>
<li><ol start="4">
<li>PULL：Android操作系统内置的解析器，sax方式的。</li>
</ol>
</li>
</ul>
<ul>
<li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。<h4 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h4><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5></li>
</ul>
<ul>
<li>1.导入jar包—-链接：<a href="https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw" target="_blank" rel="noopener">https://pan.baidu.com/s/1-x81_JxGHvdMF-8Kc_7ECw</a><br>提取码：6sg6 下载完成后解压，将jsoup-1.11.2.jar 和 JsoupXpath-0.3.2.jar(后面Jsoup_Xpath查询会用到，现在一块导入)   ，压缩包包括jsoup-1.11.2-javadoc、jsoup-1.11.2.jar、jsoup-1.11.2-javadoc.jar、jsoup-1.11.2-sources.jar、JsoupXpath-0.3.2.jar   </li>
<li>2 获取Document对象</li>
<li>3.获取对应的标签Element对象</li>
<li>4.获取数据     </li>
</ul>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.jsoup.nodes.Document;</span><br><span class="line">import org.jsoup.nodes.Element;</span><br><span class="line">import org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;获取Document对象，根据XML文档获取</span><br><span class="line">        &#x2F;&#x2F;获取student.xml的path</span><br><span class="line">        String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();</span><br><span class="line">        &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象</span><br><span class="line">        Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取元素对象  Element</span><br><span class="line">        Elements elements &#x3D; document.getElementsByTag(&quot;name&quot;);</span><br><span class="line">        System.out.println(elements.size());</span><br><span class="line">        &#x2F;&#x2F;获取第一个name的Element对象</span><br><span class="line">        Element element &#x3D; elements.get(0);</span><br><span class="line">        &#x2F;&#x2F;获取数据</span><br><span class="line">        String name &#x3D; element.text();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>studen.xml文件中的代码</p>
<figure class="highlight plain"><figcaption><span>version</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;users&gt;</span><br><span class="line">    &lt;user id&#x3D;&#39;1&#39;&gt;</span><br><span class="line">        &lt;name id&#x3D;&quot;0001&quot;&gt;张三&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;23&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;gender&gt;男&lt;&#x2F;gender&gt;</span><br><span class="line">    &lt;&#x2F;user&gt;</span><br><span class="line">    &lt;user id&#x3D;&#39;2&#39;&gt;</span><br><span class="line">        &lt;name&gt;李四&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;age&gt;30&lt;&#x2F;age&gt;</span><br><span class="line">        &lt;gender&gt;男&lt;&#x2F;gender&gt;</span><br><span class="line">    &lt;&#x2F;user&gt;</span><br><span class="line">&lt;&#x2F;users&gt;</span><br></pre></td></tr></table></figure>


<h3 id="对象的使用："><a href="#对象的使用：" class="headerlink" title="对象的使用："></a>对象的使用：</h3><h4 id="1-Jsoup：工具类，可以解析html或xml文档，返回Document"><a href="#1-Jsoup：工具类，可以解析html或xml文档，返回Document" class="headerlink" title="1. Jsoup：工具类，可以解析html或xml文档，返回Document"></a>1. Jsoup：工具类，可以解析html或xml文档，返回Document</h4><ul>
<li><p>parse：解析html或xml文档，返回Document</p>
</li>
<li><p>parse​(File in, String charsetName)：解析xml或html文件的。</p>
</li>
<li><p>parse​(String html)：解析xml或html字符串</p>
</li>
<li><p>parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象</p>
<h4 id="2-Document：文档对象。代表内存中的dom树"><a href="#2-Document：文档对象。代表内存中的dom树" class="headerlink" title="2. Document：文档对象。代表内存中的dom树"></a>2. Document：文档对象。代表内存中的dom树</h4></li>
<li><p>获取Element对象</p>
</li>
<li><p>getElementById​(String id)：根据id属性值获取唯一的element对象</p>
</li>
<li><p>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</p>
<h4 id="3-Elements：元素Element对象的集合。可以当做-ArrayList来使用"><a href="#3-Elements：元素Element对象的集合。可以当做-ArrayList来使用" class="headerlink" title="3. Elements：元素Element对象的集合。可以当做 ArrayList来使用"></a>3. Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用</h4><h4 id="4-Element：元素对象"><a href="#4-Element：元素对象" class="headerlink" title="4. Element：元素对象"></a>4. Element：元素对象</h4></li>
<li><p>1.获取子元素对象</p>
</li>
<li><p>getElementById​(String id)：根据id属性值获取唯一的element对象</p>
</li>
<li><p>getElementsByTag​(String tagName)：根据标签名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttribute​(String key)：根据属性名称获取元素对象集合</p>
</li>
<li><p>getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合</p>
</li>
<li><p>获取属性值</p>
</li>
</ul>
<ul>
<li>String attr(String key)：根据属性名称获取属性值</li>
</ul>
<ul>
<li><ol start="3">
<li>获取文本内容</li>
</ol>
</li>
</ul>
<ul>
<li>String text():获取文本内容</li>
<li>String html():获取标签体的所有内容(包括字标签的字符串内容)</li>
</ul>
<ul>
<li><ol start="5">
<li>Node：节点对象</li>
</ol>
</li>
</ul>
<ul>
<li>是Document和Element的父类</li>
</ul>
<h4 id="快捷查询方式："><a href="#快捷查询方式：" class="headerlink" title="快捷查询方式："></a>快捷查询方式：</h4><ul>
<li><ol>
<li>selector:选择器</li>
</ol>
</li>
</ul>
<ul>
<li>使用的方法：Elements    select​(String cssQuery)<br>cssQuery按照以前css选择器名字来做</li>
</ul>
<ul>
<li>语法：参考Selector类中定义的语法</li>
</ul>
<ul>
<li><ol start="2">
<li>XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</li>
</ol>
</li>
</ul>
<ul>
<li>使用Jsoup的Xpath需要额外导入jar包。</li>
<li>查询w3cshool参考手册，使用xpath的语法完成查询</li>
<li>示例代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package Jsoup;</span><br><span class="line"></span><br><span class="line">import cn.wanghaomiao.xpath.exception.XpathSyntaxErrorException;</span><br><span class="line">import cn.wanghaomiao.xpath.model.JXDocument;</span><br><span class="line">import cn.wanghaomiao.xpath.model.JXNode;</span><br><span class="line">import org.jsoup.Jsoup;</span><br><span class="line">import org.jsoup.nodes.Document;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, XpathSyntaxErrorException &#123;</span><br><span class="line">        String path &#x3D; Demo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();</span><br><span class="line">        &#x2F;&#x2F;解析xlm文档，加载文档进内存，获取dom树----&gt;document对象</span><br><span class="line">        Document document &#x3D; Jsoup.parse(new File(path),&quot;utf-8&quot;);</span><br><span class="line">        JXDocument jxDocument &#x3D; new JXDocument(document);</span><br><span class="line">&#x2F;&#x2F;        List&lt;JXNode&gt; users &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;);</span><br><span class="line">&#x2F;&#x2F;        for (JXNode j:users)&#123;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(j);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        List&lt;JXNode&gt; list &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;);</span><br><span class="line">        for (JXNode jxNode:list)&#123;</span><br><span class="line">            System.out.println(jxNode);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>```</p>
]]></content>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>http的request对象和response对象</title>
    <url>/2020/04/10/http/</url>
    <content><![CDATA[<h2 id="http的request对象和response对象"><a href="#http的request对象和response对象" class="headerlink" title="http的request对象和response对象"></a>http的request对象和response对象</h2><a id="more"></a>
<h3 id="概念：Hyper-Text-Transfer-Protocol-超文本传输协议"><a href="#概念：Hyper-Text-Transfer-Protocol-超文本传输协议" class="headerlink" title="概念：Hyper Text Transfer Protocol 超文本传输协议"></a>概念：Hyper Text Transfer Protocol 超文本传输协议</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><p>1.基于TCP/IP的高级协议</p>
</li>
<li><p>2.默认端口号8080</p>
</li>
<li><p>3.基于请求/相应模型：一次请求对应一次相应</p>
</li>
<li><p>4.无状态的：每次请求直接相互独立</p>
<h3 id="请求消息的数据格式"><a href="#请求消息的数据格式" class="headerlink" title="请求消息的数据格式"></a>请求消息的数据格式</h3></li>
<li><p>1.请求行</p>
<pre><code>请求方式  请求url  请求协议/版本
请求方式：
    GET
        1.请求参数在请求行中，在url后面
        2.请求url的长度有限
        3.不太安全
    POST
        1.请求参数在请求体中
        2.请求url长度没有限制
        3.相对安全</code></pre></li>
<li><p>2.请求头</p>
</li>
<li><p>3.请求空行</p>
</li>
<li><p>4.请求体 </p>
</li>
</ul>
<h3 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h3><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><ul>
<li><p>request和response对象的原理</p>
<pre><code>1.request和response对象由服务器创建，我蛮来使用他们
2.request对象是来获取请求消息，response是来设置相应消息</code></pre></li>
</ul>
<h5 id="request获取请求消息"><a href="#request获取请求消息" class="headerlink" title="request获取请求消息"></a>request获取请求消息</h5><ul>
<li><p>获取请求行的数据</p>
<pre><code>GET /test/demo1?name=zhangsan HTTP/1.1
1.获取请求方式 GET
String getMethod()
2.获取虚拟目录 /test
String getContextPath()
3.获取Servlet路径 /demo1
String getServletPath()
4.获取get方式请求传参 name=zhangsan 
String getQueryString()
5.获取URI /test/demo1
String getRequestURI()
6.获取协议及版本 HTTP/1.1
String getProtocol()
7.获取客户机的ip地址
String getRemoteAddr()</code></pre></li>
<li><p>获取请求头的方法</p>
<pre><code>String getHeader(String name)通过获取请求头的名称，获取请求头的值 </code></pre></li>
<li><p>获取请求体数据</p>
<pre><code>只有post请求方式，才有请求体，在请求体中封装了post请求的请求参数</code></pre><p>  步骤：</p>
<ul>
<li><p>1.获取流对象</p>
<pre><code>BufferedReader getReader():获取字符输入流
ServletInputStream getInputStream():获取字节输入流</code></pre></li>
<li><p>2.再从流对象中拿数据</p>
</li>
</ul>
</li>
<li><p>获取请求参数的通用方法</p>
<pre><code>1.String getParameter(String name):根据参数名称获取参数值
2.String[] getParameterValues(String name):根据参数名称获取参数值的数组
3.Enumeration&lt;String&gt;  getParameterNames():获取所有请参数的名称
4.Map&lt;String,String[]&gt; getParameterMap():获取参数的所有Map集合</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置流的编码 防止乱码</span><br><span class="line">        req.setCharacterEncoding(&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="请求转发：一种在服务器内部资源的跳转方式"><a href="#请求转发：一种在服务器内部资源的跳转方式" class="headerlink" title="请求转发：一种在服务器内部资源的跳转方式"></a>请求转发：一种在服务器内部资源的跳转方式</h4><ul>
<li><p>步骤：</p>
<pre><code>1.通过request对象获取请求转发器对象：RequestDispatcher  getRequestDispatcher(String path)
2.使用RequestDispatcher对象进行转发，forword(ServletRequest req,ServletRespnonse resp)</code></pre></li>
<li><p>特点：</p>
<pre><code>1.浏览器地址栏不发生变化
2.只能转发到当前服务器内部资源中
3.转发是一次请求</code></pre></li>
</ul>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><pre><code>域对象：一个有作用范围的对象，可以在范围内共享数据
request域：代表一次请求的范围，一般用域请求转发的多个资源中共享数据

方法：
1.void setAttribute(String name,Object obj):存储数据
2.Object  getAttribute(String name):通过键获取值
3.void removeAttribute(String name):通过键来移除键值对</code></pre><h4 id="获取ServletContext对象"><a href="#获取ServletContext对象" class="headerlink" title="获取ServletContext对象"></a>获取ServletContext对象</h4><pre><code>ServletContext getServletContext()</code></pre><h3 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h3><h4 id="相应消息的数据格式"><a href="#相应消息的数据格式" class="headerlink" title="相应消息的数据格式"></a>相应消息的数据格式</h4><ul>
<li><p>1.相应行</p>
<pre><code>组成：协议/版本 相应状态码  状态码描述
状态码分类：
        1.1XX:服务器接收客户端消息，但没有接收完全，等待一段时间后，发送1XX
        2.2XX:成功。200
        3.3XX:重定向  302(重定向) 304(访问缓存)
        4.4XX:客户端错误 404(请求路径没有对应的资源) 405(请求方式没有对应的doXXX方法)
        5.5XX:服务器端错误 500(服务器内部出现异常)</code></pre></li>
<li><p>2.相应头</p>
<pre><code>1.格式:头名称:值
2.常见的相应头:
        1.Content-Type:服务器告诉客户端本次相应体数据格式以及编码格式
        2.Content-disposition:服务器告诉客户端以什么格式打开相应数据</code></pre></li>
<li><p>3.相应空行</p>
</li>
<li><p>4.相应体</p>
</li>
</ul>
<h4 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h4><h5 id="功能-设置相应消息"><a href="#功能-设置相应消息" class="headerlink" title="功能:设置相应消息"></a>功能:设置相应消息</h5><ul>
<li><p>设置相应行</p>
<pre><code>设置状态码:setStatus(int sc)</code></pre></li>
<li><p>设置相应头</p>
<pre><code>setHeader(String name,string value)</code></pre></li>
<li><p>设置相应体</p>
<pre><code>使用步骤:
1.获取输出流
字符输出流:PrintWriter getWriter()
字节输出流:ServletOutputStream  getOutputStream()
2.使用输出流，将数据输出到客户端浏览器</code></pre></li>
</ul>
<h5 id="完成重定向"><a href="#完成重定向" class="headerlink" title="完成重定向"></a>完成重定向</h5><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;简单的重定向的方法</span><br><span class="line">        resp.sendRedirect(&quot;&#x2F;ReaponseDemo_war_exploded&#x2F;responseDemo2&quot;);</span><br></pre></td></tr></table></figure>
<p>特点:</p>
<ul>
<li>1.地址栏发生变化</li>
<li>2.重定向可以访问其他站点</li>
<li>3.重定向是两次请求，不能使用request对象来共享数据</li>
</ul>
<h4 id="路径的写法"><a href="#路径的写法" class="headerlink" title="路径的写法"></a>路径的写法</h4><ul>
<li><p>相对路径:不可以确定唯一资源</p>
<pre><code>规则:.开头  找到当前资源和目标资源之间的相对位置关系</code></pre></li>
<li><p>据对路径:可以确定唯一资源</p>
</li>
</ul>
<h4 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h4><pre><code>步骤:
1.获取字符输出流
2.输出数据</code></pre><p>防止乱码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resp.setHeader(&quot;content-type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;简单的形式设计编码</span><br><span class="line">        resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h4><p>1.概念:代表整个web应用，可以和程序的容器(服务器)通信</p>
<p>2.获取:</p>
<ul>
<li>1.通过request对象获取<br><code>request.getServletContext()</code></li>
<li>2.通过HttpServlet获取<br><code>this.getServletContext</code></li>
</ul>
<p>3.功能:</p>
<ul>
<li><p>1.获取MIME类型</p>
<pre><code>MIME类型:在互联网通信过程中定义的一种文件类型
格式:大类型/小类型   text/html
获取:
`String getMineType(String file)`
代码示例
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletContext context &#x3D; this.getServletContext();</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;定义文件名称</span><br><span class="line">String filename &#x3D; &quot;a.jpg&quot;;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;获取MIME类型</span><br><span class="line">String MimeType &#x3D; context.getMimeType(filename);</span><br><span class="line">System.out.println(MimeType);</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>2.域对象:共享数据</p>
<pre><code>1.setAttribute(String name,String value)
2.getAttribute(String name)
3.removeAttribute(String name)
ServletContext对象范围:所有用户请求的数据</code></pre></li>
<li><p>3.获取文件的真实服务器路径</p>
<pre><code>1.方法:String getRealPath()</code></pre></li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>文件下载需求:</p>
<ul>
<li>1.页面显示超链接</li>
<li>2.点击链接后弹出下载提示框</li>
<li>3.完成图片文件下载<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       &#x2F;&#x2F;获取请求参数  文件名称</span><br><span class="line">       String filename &#x3D; req.getParameter(&quot;filename&quot;);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;使用字节输入流，加载文件进内存</span><br><span class="line">       ServletContext context &#x3D; this.getServletContext();</span><br><span class="line">       String realPath &#x3D; context.getRealPath(&quot;&#x2F;img&#x2F;&quot;+filename);&#x2F;&#x2F;获取文件真实路径</span><br><span class="line">       FileInputStream fis &#x3D; new FileInputStream(realPath);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;设置Response的相应头</span><br><span class="line">       String mineType &#x3D; context.getMimeType(filename);&#x2F;&#x2F;获取文件的MIME类型</span><br><span class="line">       resp.setHeader(&quot;content-type&quot;,mineType);</span><br><span class="line">       resp.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;将输入流的数据写出到输出流</span><br><span class="line">       ServletOutputStream sos &#x3D; resp.getOutputStream();</span><br><span class="line">       byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">       int len &#x3D; 0;</span><br><span class="line">       while ((len&#x3D;fis.read(bytes))!&#x3D;-1)&#123;</span><br><span class="line">           sos.write(bytes,0,len);</span><br><span class="line">       &#125;</span><br><span class="line">       fis.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis框架(二)</title>
    <url>/2020/05/22/mybatis%E6%A1%86%E6%9E%B6-%E4%BA%8C/</url>
    <content><![CDATA[<p>mybatis笔记(二)</p>
<a id="more"></a>

<h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><h4 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h4><ul>
<li>mybatis-config.xml  </li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：<ul>
<li>configuration（配置）<ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties" target="_blank" rel="noopener">properties（属性）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">settings（设置）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases（类型别名）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory" target="_blank" rel="noopener">objectFactory（对象工厂）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">plugins（插件）</a></li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider" target="_blank" rel="noopener">databaseIdProvider（数据库厂商标识）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">mappers（映射器）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>MyBatis可以配置成适应多种环境</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例智能选择一种环境。</strong></p>
<p>Mybatis默认的事务管理器就是JDBC，连接池POOLED</p>
<h4 id="属性-properties"><a href="#属性-properties" class="headerlink" title="属性(properties)"></a>属性(properties)</h4><p>我们可以通过properties属性实现引用配置文件</p>
<p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。</p>
<p>编写一个配置文件:db.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>在核心配置文件中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入外部配置文件--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  可以给实体类起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"cn.demomybatis.domain.Student"</span> <span class="attr">alias</span>=<span class="string">"Student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean</p>
<p>扫描实体类的包，他的默认别名就为这个类的类名首字母小写</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="left">是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td align="left">true|False</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>MapperRegistry:注册绑定我们的Mapper文件</p>
<p>方式一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"cn/demomybatis/dao/StudentDao.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"cn.demomybatis.dao.StudentDao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式三：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.demomybatis.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h3><p>生命周期和作用域是只管重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong></p>
<h3 id="解决属性名和字段名不一致问题"><a href="#解决属性名和字段名不一致问题" class="headerlink" title="解决属性名和字段名不一致问题"></a>解决属性名和字段名不一致问题</h3><h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    结果集映射--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentMap"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--        column是数据库中的字段，property是实体类中的字段--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"u_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>resultMap元素是MyBatis中最重要最强大的元素</p>
</li>
<li><p>ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，对于复杂一点的语句只需要猫叔他们的关系就行了</p>
</li>
<li><p>ResultMap最优秀的地方在于，虽然你已经对他相当了解了，但根本不需要显式的用到他们。</p>
</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h4><p>如果一个数据库操作出现了异常，我们需要排错。日志就是最好的帮手！</p>
<table>
<thead>
<tr>
<th align="center">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">logImpl</td>
<td align="left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td align="left">SLF4J，LOG4J，LOG4J2，JDK_LOGGING，COMMONS_LOGGING，STDOUT_LOGGING，NO_LOGGING</td>
<td align="left">未设置</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        标准的日志实现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="LOG4J"><a href="#LOG4J" class="headerlink" title="LOG4J"></a>LOG4J</h4><p>什么式log4j？</p>
<ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995" target="_blank" rel="noopener">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/控制台/2438626" target="_blank" rel="noopener">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI" target="_blank" rel="noopener">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>通过一个<a href="https://baike.baidu.com/item/配置文件/286550" target="_blank" rel="noopener">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p>1.先导入LOG4J的jar包</p>
<p>2.log4j.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#############################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Log4J 配置文件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#############################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义缺省的日志级别和输出对象</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,INFO, logfile,console</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定控制台输出模式</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[%d&#123;MM/dd HH:mm:ss&#125;] [%-3p] %c&#123;1&#125;: %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对package定义日志级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache</span>=<span class="string">WARN</span></span><br><span class="line"><span class="meta">log4j.logger.com.paic.pafademo</span>=<span class="string">DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定日志文件的输出模式</span></span><br><span class="line"><span class="meta">log4j.appender.logfile</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.DatePattern</span>=<span class="string">yyyyMMdd</span></span><br><span class="line"><span class="comment"># $&#123;pafa.log.home&#125;通过参数-D指定，比如启动WebLogic时加入参数-Dpafa.log.home=c:/</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.File</span>=<span class="string">$&#123;log.home&#125;/appdemo/pafa.log</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.layout.ConversionPattern</span>=<span class="string">%d&#123;MM/dd HH:mm:ss&#125; [%-3p] %c&#123;1&#125;: %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要查看iBATIS的SQL日志信息，确保有下面配置</span></span><br><span class="line"><span class="meta">log4j.logger.com.ibatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Connection</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>3.配置log4j为日志的实现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p>1.在要使用的Log4j的类中，导入import org.apache.log4j.Logger;</p>
<p>2.日志对象，参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(mybatistest<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h4 id="使用limit分类"><a href="#使用limit分类" class="headerlink" title="使用limit分类"></a>使用limit分类</h4><p>使用MyBatis实现分页，核心SQL</p>
<p>1.接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页</span></span><br><span class="line">   <span class="function">List&lt;Student&gt; <span class="title">getStudentByLimit</span><span class="params">(Map&lt;String,Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.StudentDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudentByLimit"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        select * from student limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentByLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        StudentDao studentDao = sqlSession.getMapper(StudentDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"startIndex"</span>,<span class="number">0</span>);</span><br><span class="line">        map.put(<span class="string">"pageSize"</span>,<span class="number">2</span>);</span><br><span class="line">        List&lt;Student&gt; studentList = studentDao.getStudentByLimit(map);</span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RowBounds分页"><a href="#RowBounds分页" class="headerlink" title="RowBounds分页"></a>RowBounds分页</h4>]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX和JSON</title>
    <url>/2020/04/28/ajax%E5%92%8CJSON/</url>
    <content><![CDATA[<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><a id="more"></a>
<h4 id="概念：ASynchronous-JavaScript-And-XML-异步的javascript和xml"><a href="#概念：ASynchronous-JavaScript-And-XML-异步的javascript和xml" class="headerlink" title="概念：ASynchronous JavaScript And XML   异步的javascript和xml"></a>概念：ASynchronous JavaScript And XML   异步的javascript和xml</h4><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式:"></a>实现方式:</h4><ul>
<li><p>1.原生的JS实现方式</p>
</li>
<li><p>2.JQuery实现方式</p>
<p>  1.<font color="#DC143C">$.ajax()}</font></p>
<pre><code>$.ajax({键值对});</code></pre><p>  2.<font color="#DC143C">$.get()</font></p>
<p>  3.<font color="#DC143C">$.post()</font></p>
</li>
</ul>
<h3 id="JOSN"><a href="#JOSN" class="headerlink" title="JOSN"></a>JOSN</h3><h4 id="概念：JavaScript-Object-Notation-JavaScript对象表示法"><a href="#概念：JavaScript-Object-Notation-JavaScript对象表示法" class="headerlink" title="概念：JavaScript Object Notation      JavaScript对象表示法"></a>概念：JavaScript Object Notation      JavaScript对象表示法</h4><h4 id="基本规则："><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h4><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据:"></a>获取数据:</h4><p><font color="#DC143C">json对象.键名</font></p>
<p><font color="#DC143C">json对象[“键名”]</font></p>
<p><font color="#DC143C">数组对象[索引]</font></p>
<h4 id="遍历JSON"><a href="#遍历JSON" class="headerlink" title="遍历JSON"></a>遍历JSON</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var key in person)&#123;</span><br><span class="line">    alert(key+&quot;:&quot;+person[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JSON数据和Java对象的相互转换"><a href="#JSON数据和Java对象的相互转换" class="headerlink" title="JSON数据和Java对象的相互转换"></a>JSON数据和Java对象的相互转换</h4><pre><code>1.JSON转为Java
    1.导入jar包
    2.创建jackson核心对象   ObjectMapper
    3.调用ObjectMapper的相关方法进行转换</code></pre><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String json &#x3D; &quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:20,\&quot;gender\&quot;:\&quot;男\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建ObjectMappper</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span><br><span class="line">&#x2F;&#x2F;转换为Java的对象</span><br><span class="line">Person person &#x3D; mapper.readValue(json,Person.class);</span><br><span class="line">System.out.println(person);</span><br></pre></td></tr></table></figure>
<h5 id="2-Java转为JSON"><a href="#2-Java转为JSON" class="headerlink" title="2.Java转为JSON"></a>2.Java转为JSON</h5><pre><code>1.导入jar包
2.创建jackson核心对象   ObjectMapper
3.调用ObjectMapper的相关方法进行转换</code></pre><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test1() throws Exception &#123;</span><br><span class="line">    Person p &#x3D; new Person();</span><br><span class="line">    p.setName(&quot;张三&quot;);</span><br><span class="line">    p.setAge(23);</span><br><span class="line">    p.setGendeer(&quot;男&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建Jackson的核心对象  ObjectMapper</span><br><span class="line">    ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">    &#x2F;&#x2F;调用方法 转换</span><br><span class="line">    String JSON &#x3D; mapper.writeValueAsString(p);</span><br><span class="line">    System.out.println(JSON);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;wirterValue  将数据写入到D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt中</span><br><span class="line">    &#x2F;&#x2F;mapper.writeValue(new File(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;a.txt&quot;),p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;writeValue将数据关联到Writer中</span><br><span class="line">    mapper.writeValue(new FileWriter(&quot;D:&#x2F;&#x2F;a_test&#x2F;&#x2F;b.txt&quot;),p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h5><pre><code>1.@JsonIgnore:排除属性
2.@JsonFormat:属性值格式化</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>校验用户是否存在</p>
<p>html代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;注册&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;JS&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;页面加载完成后 给文本框绑定离开焦点事件</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(&quot;#username&quot;).blur(function () &#123;</span><br><span class="line">                &#x2F;&#x2F;获取username获取文本输入框的值</span><br><span class="line">                var username &#x3D; $(this).val();</span><br><span class="line">                &#x2F;&#x2F;发送ajax请求</span><br><span class="line">                $.get(&quot;findUserServlet&quot;,&#123;username:username&#125;,function (data) &#123;</span><br><span class="line">                    var span &#x3D; $(&quot;#s_username&quot;)</span><br><span class="line">                    if (data.userExsit)&#123;</span><br><span class="line">                        &#x2F;&#x2F;用户名存在</span><br><span class="line">                        span.css(&quot;color&quot;,&quot;red&quot;)</span><br><span class="line">                        span.html(data.msg)</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        &#x2F;&#x2F;用户名不存在</span><br><span class="line">                        span.css(&quot;color&quot;,&quot;green&quot;)</span><br><span class="line">                        span.html(data.msg)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,&quot;json&quot;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input id&#x3D;&quot;username&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt;</span><br><span class="line">    &lt;span id&#x3D;&quot;s_username&quot;&gt;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;注册&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>Servlet代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.test.web.servlet;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;findUserServlet&quot;)</span><br><span class="line">public class findUserServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String username &#x3D; request.getParameter(&quot;username&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置响应数据为JSON</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        if (&quot;Tom&quot;.equals(username))&#123;</span><br><span class="line">            &#x2F;&#x2F;存在</span><br><span class="line">            map.put(&quot;userExsit&quot;,true);</span><br><span class="line">            map.put(&quot;msg&quot;,&quot;用户名已经存在&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;不存在</span><br><span class="line">            map.put(&quot;userExsit&quot;,false);</span><br><span class="line">            map.put(&quot;msg&quot;,&quot;用户名可用&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将map转为json，并且传递给客户端</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        mapper.writeValue(response.getWriter(),map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis框架(三)</title>
    <url>/2020/05/24/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%89/</url>
    <content><![CDATA[<p>mybatis笔记(三)</p>
<a id="more"></a>

<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p>1.注解在接口上使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from student"</span>)</span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.需要在核心配置文件中绑定接口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource="cn/demomybatis/dao/StudentDao.xml"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper class="cn.demomybatis.dao.StudentDao"/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.demomybatis.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>本质：反射机制实现</p>
<p>底层：动态代理！</p>
<p><strong>MyBatis详细执行流程</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/asdasdas.jpg" style="zoom: 80%;" />

<h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p>我们可以在创建工具类的时候实现自动提交事务！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写接口，增加注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法存在多个参数，所有参数前面必须加上@Param注解</span></span><br><span class="line">   <span class="meta">@Select</span>(<span class="string">"select * from student where id = #&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function">Student <span class="title">getStudentById1</span><span class="params">(@Param(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Insert</span>(<span class="string">"insert into student(id,name,age,phone) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;phone&#125;)"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addStudent1</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Update</span>(<span class="string">"update student set name=#&#123;name&#125;,age=#&#123;age&#125;,phone=#&#123;phone&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">updateStudent1</span><span class="params">(Student student)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="关于-Param注解"><a href="#关于-Param注解" class="headerlink" title="关于@Param注解"></a>关于@Param注解</h4><ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议加上</li>
<li>我们在SQL中引用的就是我们这里的@Param()中设定的属性名！</li>
</ul>
<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>使用步骤：</p>
<p>1.在IDEA中安装Lombok插件</p>
<p>2.在项目导入Lombok的jar包</p>
<p>3.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>：生成无参构造，get，set，toString，hashcode，equals</span><br><span class="line"><span class="meta">@AllArgsConstructor</span>   有参构造方法</span><br><span class="line"><span class="meta">@NoArgsConstructor</span>    无参构造方法</span><br></pre></td></tr></table></figure>

<h3 id="多对一处理"><a href="#多对一处理" class="headerlink" title="多对一处理"></a>多对一处理</h3><h4 id="按照插叙嵌套处理"><a href="#按照插叙嵌套处理" class="headerlink" title="按照插叙嵌套处理"></a>按照插叙嵌套处理</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     思路：</span></span><br><span class="line"><span class="comment">            1.查询所有的学生信息</span></span><br><span class="line"><span class="comment">            2.根据查询出来的tid，寻找对应的老师！   子查询--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher"</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span> <span class="attr">select</span>=<span class="string">"getTeacher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">        select * from teacher where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent2"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher2"</span>&gt;</span></span><br><span class="line">       select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher2"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"sname"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"tname"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="一对多处理"><a href="#一对多处理" class="headerlink" title="一对多处理"></a>一对多处理</h3><p>同理</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.关联 - association 【多对一】</p>
<p>2.集合 - collection 【一对多】</p>
<p>3.javaTape：用来指定实体类中属性的类型</p>
<p>4.ofType：用来指定映射到List或者集合中的实体类类型，泛型中的约束类型</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis框架(一)</title>
    <url>/2020/05/19/mybatis%E6%A1%86%E6%9E%B6-%E4%B8%80/</url>
    <content><![CDATA[<p>mybatis笔记(一)</p>
<a id="more"></a>

<h3 id="mybatis概述"><a href="#mybatis概述" class="headerlink" title="mybatis概述"></a>mybatis概述</h3><p>mybatis是一个持久层框架，用java编写，封装了很多jdbc细节，开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程，它使用了ORM思想，实现了结果集的封装。</p>
<h3 id="ORM：Object-Relational-Mappging-对象关系映射"><a href="#ORM：Object-Relational-Mappging-对象关系映射" class="headerlink" title="ORM：Object Relational Mappging   对象关系映射"></a>ORM：Object Relational Mappging   对象关系映射</h3><p>简单的说：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类及实现操作数据库</p>
<h3 id="mybatis环境搭建"><a href="#mybatis环境搭建" class="headerlink" title="mybatis环境搭建"></a>mybatis环境搭建</h3><ul>
<li>1.创建maven工程并导入坐标<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;3.5.4&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;8.0.18&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>2.创建实体类和dao接口</li>
<li>3.创建mybatis的主配置文件SqlMapConfig.xml</li>
<li>4.创建映射配置文件<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></li>
<li>1.包在创建时 com.demomybatis.dao他是三级目录结构</li>
<li>2.mybatis的映射配置文件位置必须和dao接口的包结构相同</li>
<li>3.映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定而类名</li>
<li>4.映射配置文件的擦偶哦配置(select) id的取值必须是dao接口的方法名</li>
</ul>
<div class="note success"><p>当我们遵从2，3，4点之后，我们开发中就无需再写dao的实现类</p></div>

<h3 id="SqlMapConfig-xml代码"><a href="#SqlMapConfig-xml代码" class="headerlink" title="SqlMapConfig.xml代码"></a>SqlMapConfig.xml代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">            &lt;!--使用jdbc事务管理 --&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">            &lt;!-- 数据库连接池(数据源) --&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line">    &lt;!-- 引入映射配置文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;cn&#x2F;demomybatis&#x2F;dao&#x2F;StudentDao.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="StudentDao-xml代码"><a href="#StudentDao-xml代码" class="headerlink" title="StudentDao.xml代码"></a>StudentDao.xml代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- namespace：命名空间，用于隔离sql--&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;cn.demomybatis.dao.StudentDao&quot;&gt;</span><br><span class="line">    &lt;!--    配置查询所有 id为dao的方法名--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;cn.demomybatis.domain.Student&quot; parameterType&#x3D;&quot;cn.demomybatis.domain.Student&quot;&gt;</span><br><span class="line">		select * from student</span><br><span class="line">	&lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>
<h3 id="mybatis入门案例："><a href="#mybatis入门案例：" class="headerlink" title="mybatis入门案例："></a>mybatis入门案例：</h3><ul>
<li>1.读取配置文件</li>
<li>2.创建SqlSessionFactory工厂</li>
<li>3.创建SqlSession</li>
<li>4.创建Dao接口的代理</li>
<li>5.执行Dao中的方法</li>
<li>6.释放资源</li>
</ul>
<span class='p red'>注意：需要在映射配置中告知mybatis要封装到哪个实体类中，配置的方式：指定实体类的全类名</span>

<div class="note warning"><p>增删改需要提交事务</p></div>

<p><code>sqlSession.commit()</code></p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.demomybatis.test;</span><br><span class="line"></span><br><span class="line">import cn.demomybatis.dao.StudentDao;</span><br><span class="line">import cn.demomybatis.domain.Student;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * mybatis入门</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class mybatistest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;读取配置文件</span><br><span class="line">        InputStream in &#x3D; Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建工厂</span><br><span class="line">        SqlSessionFactoryBuilder builder &#x3D; new SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory &#x3D; builder.build(in);</span><br><span class="line">        &#x2F;&#x2F;使用工厂生产SqlSession对象</span><br><span class="line">        SqlSession sqlSession &#x3D; factory.openSession();</span><br><span class="line">        &#x2F;&#x2F;创建Dao接口的代理对象</span><br><span class="line">        StudentDao studentDao &#x3D; sqlSession.getMapper(StudentDao.class);</span><br><span class="line">        &#x2F;&#x2F;使用代理对象执行方法</span><br><span class="line">        List&lt;Student&gt; list &#x3D; studentDao.findAll();</span><br><span class="line">        for (Student student:list)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;释放资源</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2020/04/06/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="scrapy爬虫框架的安装"><a href="#scrapy爬虫框架的安装" class="headerlink" title="scrapy爬虫框架的安装"></a>scrapy爬虫框架的安装</h1><a id="more"></a>
<p>用<code>pip install scrapy</code>命令安装会提示失败，是因为缺少twisted程序<br>进入<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">官网</a> 按住ctrl+f 查找关键字<br><img src="/img/%E7%88%AC%E8%99%AB1.png" alt="图片"><br>下载好与python版本配对的文件<br><img src="/img/%E7%88%AC%E8%99%AB2.png" alt="命令"><br>用命令安装下载好的文件  注意路径最好不要太长 否则容易报错<br>安装好插件以后用命令<br><code>pip install scrapy</code>安装框架<br>安装好以后用命令’scrapy’查看版本<br><img src="/img/%E7%88%AC%E8%99%AB3.png" alt="成功"><br>出现以上代码说明安装成功</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ngork内网穿透</title>
    <url>/2020/05/22/ngork%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>将本地的项目运行在公网上</p>
<a id="more"></a>

<h3 id="1-进入ngrok官网（http-www-ngrok-cc-），注册ngrok账号"><a href="#1-进入ngrok官网（http-www-ngrok-cc-），注册ngrok账号" class="headerlink" title="1.进入ngrok官网（http://www.ngrok.cc/），注册ngrok账号"></a>1.进入ngrok官网（<a href="http://www.ngrok.cc/），注册ngrok账号" target="_blank" rel="noopener">http://www.ngrok.cc/），注册ngrok账号</a></h3><h3 id="2-登录–-gt-隧道管理–-gt-开通隧道"><a href="#2-登录–-gt-隧道管理–-gt-开通隧道" class="headerlink" title="2.登录–&gt;隧道管理–&gt;开通隧道"></a>2.登录–&gt;隧道管理–&gt;开通隧道</h3><p>找到免费的</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522091915.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092038.png" alt=""></p>
<p>隧道名称和前置域名随便填就行了  端口填自己tomcat的端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092309.png" alt=""></p>
<p>点击客户端下载</p>
<p>下载完成之后点击启动工具</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092538.png" alt=""></p>
<p>输入隧道id</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200522092753.png" alt=""></p>
<p>显示这个就已经成功了  可以通过上边哪个域名访问自己本地的项目了</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis框架(四)</title>
    <url>/2020/05/27/mybatis%E6%A1%86%E6%9E%B6-%E5%9B%9B/</url>
    <content><![CDATA[<p>mybatis笔记(四)</p>
<a id="more"></a>

<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p><strong>什么是动态SQL：根据不同的条件生成不同的SQL</strong></p>
<p><strong>所谓的动态SQl，本质还是SQL语句，只是我么可以在SQl层面，去执行一个逻辑代码</strong></p>
<p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p>
<ul>
<li><p>if</p>
</li>
<li><p>choose (when, otherwise)</p>
</li>
<li><p>trim (where, set)</p>
</li>
<li><p>foreach</p>
</li>
</ul>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><strong>BlogMapper.xml代码</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogIf"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">        select * from blog where 1 = 1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">            and title = #&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">            and author = #&#123;author&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h4><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogChoose"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">        select * from blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title!=null"</span>&gt;</span></span><br><span class="line">                    title = #&#123;title&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author!=null"</span>&gt;</span></span><br><span class="line">                    and author = #&#123;author&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    and views = #&#123;views&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>只会选择其中一个条件实现，前面的实现后面的就不看了</strong></p>
<h4 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h4><p><strong>where</strong></p>
<p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SELECT * FROM BLOG</span><br><span class="line">WHERE</span><br></pre></td></tr></table></figure>

<p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SELECT * FROM BLOG</span><br><span class="line">WHERE</span><br><span class="line">AND title like ‘someTitle’</span><br></pre></td></tr></table></figure>

<p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p>
<p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p>
<p><strong><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</strong></p>
<p><strong>set</strong></p>
<p>用于动态更新语句的类似解决方案叫做 <em>set<em>。</em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p>
<p><em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBlogSet"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        update blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"titlt != null"</span>&gt;</span></span><br><span class="line">                title = #&#123;title&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">                author = #&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h4><p>有的时候，我们可能将一些功能的部分抽取出来，方便复用</p>
<p>1.使用<code>sql</code>标签抽取公共部分</p>
<p>2.在需要使用的的地方使用<code>include</code>标签引用即可</p>
<p><strong>注意事项</strong>：</p>
<p>1.最好基于单表来定义SQL！</p>
<p>2.不要存在where</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p>
<p><strong>提示</strong> 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryForeach"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">        select * from blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"and ("</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">"or"</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>1.什么是缓存？</p>
<ul>
<li>存在内存的临时数据</li>
<li>将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li>
</ul>
<p>2.为什么使用缓存？</p>
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率</li>
</ul>
<p>3.什么样的数据能使用缓存</p>
<ul>
<li>经常查询并且不经常改变的数据</li>
</ul>
<h4 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h4><ul>
<li>MyBatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率</li>
<li>MyBatis系统中定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul>
<li>默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称本地缓存)</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。</li>
</ul>
</li>
</ul>
<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><ul>
<li>一级缓存也叫本地缓存：SqlSession<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中</li>
<li>以后如果需要获取相同的数据，直接从缓存中哪，没必要在去查询数据库</li>
</ul>
</li>
</ul>
<p><strong>缓存失效的情况：</strong></p>
<p>1.查询不同的东西</p>
<p>2.增删改操作，可能会改变原来的数据，所有必定会刷新缓存！</p>
<p>3.查询不同Mapper.xml</p>
<p>4.手动清理缓存</p>
<p><strong>小结</strong></p>
<p>一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个去加段！</p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><ul>
<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>
<li>基于namespace级别的缓存，一个名门空间对应一个二级缓存</li>
<li>工作机制：<ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据保存到二级缓存中</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容</li>
<li>不同的mapper查出的数据会放在自己对应的缓存中</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<p>1.开启全局缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        开启全局缓存--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在要使用二级缓存的Mapper中开启</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据库</title>
    <url>/2020/05/01/redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><a id="more"></a>
<h4 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h4><p><a href="https://pan.baidu.com/s/1FkHPTih-qGrGzFee0GW7QA" target="_blank" rel="noopener">百度云下载</a>       提取码：o1ui</p>
<p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">Github下载</a></p>
<h4 id="概念：一款高性能的NOSQL系列的非关系型数据库"><a href="#概念：一款高性能的NOSQL系列的非关系型数据库" class="headerlink" title="概念：一款高性能的NOSQL系列的非关系型数据库"></a>概念：一款高性能的NOSQL系列的非关系型数据库</h4><h4 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h4><pre><code>redis存储的是：key，value格式的数据，其中key都是字符串，value有5中不同的数据结构
value的数据结构
    1.字符串类型 string
    2.哈希类型  hash     ：相当于map集合
    3.列表集合  list        ：linkedlist格式
    4.集合类型  set        
    5.有序集合类型  sortedset</code></pre><h5 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h5><p>1.存储 <font color="#A52A2A">set key value</font></p>
<p>2.获取 <font color="#A52A2A">get key</font></p>
<p>3.删除 <font color="#A52A2A">del key</font>    </p>
<h5 id="哈希类型-hash"><a href="#哈希类型-hash" class="headerlink" title="哈希类型 hash"></a>哈希类型 hash</h5><p>1.存储  <font color="#A52A2A">hset key field value</font></p>
<p>2.获取 <font color="#A52A2A">hget key field                hgetall key  获取所有的键和值</font> </p>
<p>3.删除 <font color="#A52A2A">hdel key field</font> </p>
<h5 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型 list"></a>列表类型 list</h5><p>1.<font color="#A52A2A">lpush key value 将元素加入列表左边</font></p>
<p>2.<font color="#A52A2A">rpush key value 将元素加入列表右边</font></p>
<p>3.<font color="#A52A2A">lrange key start end  获取范围</font></p>
<p>4.<font color="#A52A2A">lpop key   删除列表最左边的元素，并将元素返回</font></p>
<p>5.<font color="#A52A2A">rpop key  删除列表最右边的元素</font></p>
<h5 id="集合类型-set"><a href="#集合类型-set" class="headerlink" title="集合类型 set"></a>集合类型 set</h5><p>1.<font color="#A52A2A">存储：sadd key value</font> </p>
<p>2.<font color="#A52A2A">获取：smembers key ：获取集合中所有元素</font></p>
<p>3.<font color="#A52A2A">删除：srem key value ：删除集合的某个元素</font></p>
<h5 id="有序集合类型-sortedset"><a href="#有序集合类型-sortedset" class="headerlink" title="有序集合类型 sortedset"></a>有序集合类型 sortedset</h5><p>1.存储：<font color="#A52A2A">zadd key score  value</font></p>
<p>2.获取：<font color="#A52A2A">zrange key start end</font></p>
<p>3.删除：<font color="#A52A2A">zrem key value</font></p>
<h5 id="通用命令："><a href="#通用命令：" class="headerlink" title="通用命令："></a>通用命令：</h5><p>1.<font color="#A52A2A">keys * ：查询所有的键</font></p>
<p>2.<font color="#A52A2A">type key：获取键对应的value的类型</font></p>
<p>3.<font color="#A52A2A">del key：删除指定的key value</font></p>
<h5 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h5><ul>
<li><p>1.redis是一个内存数据库，东redis服务器重启后，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘中</p>
</li>
<li><p>2.redis持久化机制</p>
<pre><code>1.RDB：默认方式。 在一定的间隔时间中，检测key的变化情况，然后去持久化数据            
2.AOF：日志记录的方式，可以检测每一条命令的操作。可以每一次命令操作后，持久化数据
        编辑redis.windows.conf文件    appendonly  no  给成yes</code></pre></li>
</ul>
<h3 id="Java客户端Jedis"><a href="#Java客户端Jedis" class="headerlink" title="Java客户端Jedis"></a>Java客户端Jedis</h3><pre><code>Jedis是一款java操作redis数据库的工具</code></pre><h3 id="Jedis连接池：JedisPool"><a href="#Jedis连接池：JedisPool" class="headerlink" title="Jedis连接池：JedisPool"></a>Jedis连接池：JedisPool</h3><pre><code>1.创建JedisPool连接池对象
2.调用getResource()方法获取Jedis的连接</code></pre><h4 id="工具类代码"><a href="#工具类代码" class="headerlink" title="工具类代码"></a>工具类代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.jedis.utlis;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">JedisPool工具类</span><br><span class="line">加载配置文件，配置连接池参数</span><br><span class="line">提供获取连接的方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JedisPoolUtils &#123;</span><br><span class="line">    private static JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F;读取配置文件</span><br><span class="line">        InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个Properties对象</span><br><span class="line">        Properties pro &#x3D; new Properties();</span><br><span class="line">        &#x2F;&#x2F;关联文件</span><br><span class="line">        try &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中</span><br><span class="line">        JedisPoolConfig config &#x3D; new JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化JedisPool</span><br><span class="line">        jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取连接</span><br><span class="line">    public static Jedis getJedis()&#123;</span><br><span class="line">        return jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客及其部署</title>
    <url>/2020/04/06/%E5%AE%89%E8%A3%85Hexo%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="特别鸣up主CodeSheep"><a href="#特别鸣up主CodeSheep" class="headerlink" title="特别鸣up主CodeSheep"></a>特别鸣up主<a href="https://www.bilibili.com/video/BV1Yb411a7ty?t=26" target="_blank" rel="noopener">CodeSheep</a></h1><a id="more"></a>
<h2 id="基于b站视频-windows-10系统，所有以下在windows10-64位下进行演示。"><a href="#基于b站视频-windows-10系统，所有以下在windows10-64位下进行演示。" class="headerlink" title="基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。"></a>基于b站视频 windows 10系统，所有以下在windows10 64位下进行演示。</h2><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网</a><br><img src="/img/1.png" alt="图片">建议下载第一个<br>安装步骤非常简单，一直next，下一步就可以了，默认安装就行。</p>
<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a><br>然后我们选择windows版本的下载<br>安装也是一直点下一步，安装官方默认的来就行，<br>安装完了，在开始菜单可以看到<br><img src="/img/2.png" alt="图片"></p>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>创建一个工作目录  比如在c盘建一个blog文件夹<br>用管理员属性打开cmd  cd到工作目录<br>使用npm 安装hexo<br><code>npm install -g hexo-cli</code><br>输入<br><code>hexo -v</code><br>判断hexo是否安装成功<br><img src="/img/3.png" alt="表示成功"><br>输入<br><code>hexo init</code>初始化一个博客<br>这里是hexo常用的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #用来清理缓存文件</span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d   #上传到服务器</span><br></pre></td></tr></table></figure>
<p>输入<code>hexo s</code>之后可以进入<code>http://localhost:4000/</code>这个地址查看我们的博客</p>
<h1 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h1><p>这里我们选用的部署到github上面<br>首先新建一个github的仓库<br><img src="/img/4.png" alt="新建仓库"><br><img src="/img/5.png" alt="仓库名"><br>这里的name一定要填自己的用户名.github.io 不然会出问题<br>去工作目录找到_config.yml这个文件  双击打开  我这里使用vscode打开的 用notepad++ 文本打开都可以<br><img src="/img/6.png" alt="要求"><br>红线换成自己的github用户名就行了 其他两行按照这个填写<br>安装 hexo-deployer-git。<br><code>npm install hexo-deployer-git --save</code><br>部署一下就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>这样你就可以通过自己的git仓库的域名访问你自己的博客了<br>同样还可以部署在码云和coding上这个可以加快访问的速度</p>
<h1 id="开启github-pages服务，绑定域名"><a href="#开启github-pages服务，绑定域名" class="headerlink" title="开启github pages服务，绑定域名"></a>开启github pages服务，绑定域名</h1><p>如果你觉域名比较难记，可以自己去申请一个域名</p>
<p>这里我们以腾讯云为例，前提是我已经申请好了<br><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%911.png" alt=""><br>点击解析域名<br><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%912.png" alt=""><br>最好添加一个主机记录为@记录类型为<code>CNAME</code>类型，记录值写自己github仓库的地址名。</p>
<p>接下来配置github的 pages服务<br><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/%E8%85%BE%E8%AE%AF%E4%BA%913.png" alt=""></p>
<ul>
<li>找到博客对应的仓库，点击setting</li>
<li>下滑找到Github Pages，填入自己的域名，点击save保存</li>
</ul>
<p>这样就可以通过自己的域名访问呢了</p>
]]></content>
      <tags>
        <tag>软件</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat及Servlet</title>
    <url>/2020/04/08/tomcat%E5%8F%8AServlet/</url>
    <content><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><a id="more"></a>
<h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><p>进入官网，个人推荐下载解压版，方便快捷</p>
<p>解压到工作目录后就可以使用了 进入bin目录 双击startup.bat linux打开.sh<br><img src="/img/tomcat1.png" alt="路径"></p>
<h4 id="可能遇到的两个问题"><a href="#可能遇到的两个问题" class="headerlink" title="可能遇到的两个问题"></a>可能遇到的两个问题</h4><ul>
<li>双击之后没有启动tomcat 黑窗口秒关闭—-JAVA_HOME的环境变量没有没配置好</li>
<li>运行日志乱码—-打开cd到tomcat/conf/目录下修改logging.properties找到</li>
</ul>
<p><code>java.util.logging.ConsoleHandler.encoding = utf-8</code></p>
<p>这行将utf-8改为GBK</p>
<h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><ul>
<li>1.直接将项目放到webapps目录下即可<ul>
<li>/hello :项目访问的路径—-&gt;虚拟目录<pre><code>将项目打包成一个war包，再将war包放到webapps目录下 war包会自动解压</code></pre></li>
</ul>
</li>
<li>2.配置conf/server.xml<ul>
<li>在<Host>标签体中配置</li>
<li>docBase：项目存放的路径</li>
<li>path:虚拟目录</li>
</ul>
</li>
<li>3.在conf\Catalina\localhost创建任意名称的xml文件，在文件中编写<pre><code>    `&lt;Context docBase=&quot;D:\hello&quot;&gt;`
虚拟目录就是文件的名称</code></pre></li>
</ul>
<h4 id="静态项目和动态项目："><a href="#静态项目和动态项目：" class="headerlink" title="静态项目和动态项目："></a>静态项目和动态项目：</h4><pre><code>目录结构：
        --项目的根目录
            --WEB-INF目录
                --web.xml:web项目的核心配置文件
                --classes目录：放置字节码文件的目录
                --lib目录：防止依赖的jar包</code></pre><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><ul>
<li>概念：server applet  运行在服务器端的小程序</li>
<li>servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>1.创建javaEE项目
2.定义一个类，实现Servlet接口
3.实现接口中的抽象方法
4.配置 Servlet---- 在web.xml中配置</code></pre></li>
<li>配置代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;cn.test.web.Servlet.ServletDemo1&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4></li>
<li>1.当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的Servlet的资源路径</li>
<li>2.查找web.xml文件，是否有对应的<url-pattern>标签体内容</li>
<li>3.如果有，则再找到对应的<servlet-class>全类名</li>
<li>4.tomcat会将字节码文件加载进内存，并创建其对象</li>
<li>5.调用方法<h4 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h4>  1.被创建：执行init方法，只执行一次<br>  2.提供服务：执行servlet方法，执行多次<br>  3.被销毁：执行destroy方法，执行一次</li>
</ul>
<h4 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h4><pre><code>支持注解文件配置，可以不需要web.xml
步骤：
    1.创建javaEE的项目，选择Servlet的版本 3.0以上，可以不勾选web.xml
    2.定义一个类，实现Servlet接口
    3.重写方法
    4.在类上使用一个注解
        @WebServlet(&quot;资源路径&quot;)</code></pre><h4 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h4><ul>
<li><p>Servlet 接口</p>
</li>
<li><p>GenericServlet 抽象类</p>
<p>  将Servlet接口的其他方法做了默认实现，只将service()方法作为抽象</p>
</li>
<li><p>HttpServlet  抽象类 对HTPP协议的一种封装，简化操作</p>
<p>  1.定义类继承HttpServlet</p>
<p>  2.复写doGet/doPost方法</p>
</li>
</ul>
<h3 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h3><ul>
<li><p>1.urlpartten：Servlet访问的路径</p>
<pre><code>1.一个Servlet可以定义多个访问路径:WebServlet({&quot;/d4&quot;,&quot;Demo4&quot;})

2.路径的定义规则：/XXX，/XXX，*.do</code></pre></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>抽取Servlet</title>
    <url>/2020/05/13/%E6%8A%BD%E5%8F%96Servlet/</url>
    <content><![CDATA[<h3 id="BaseServlet代码"><a href="#BaseServlet代码" class="headerlink" title="BaseServlet代码"></a>BaseServlet代码</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.travel.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class BaseServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;完成方法的分发</span><br><span class="line">        &#x2F;&#x2F;获取请求路径</span><br><span class="line">        String uri &#x3D; req.getRequestURI();</span><br><span class="line">        System.out.println(&quot;请求uri:&quot;+uri);</span><br><span class="line">        &#x2F;&#x2F;获取方法对象</span><br><span class="line">        String methodName &#x3D; uri.substring(uri.lastIndexOf(&quot;&#x2F;&quot;)+1);</span><br><span class="line">        System.out.println(&quot;方法名称：&quot;+methodName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取方法对象Method</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method &#x3D; this.getClass().getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">            &#x2F;&#x2F;暴力反射</span><br><span class="line">            &#x2F;&#x2F;method.setAccessible(true);</span><br><span class="line">            &#x2F;&#x2F;执行方法</span><br><span class="line">            method.invoke(this,req,resp);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UserServlet代码"><a href="#UserServlet代码" class="headerlink" title="UserServlet代码"></a>UserServlet代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.travel.web.servlet;</span><br><span class="line"></span><br><span class="line">import cn.travel.damain.ResultInfo;</span><br><span class="line">import cn.travel.damain.User;</span><br><span class="line">import cn.travel.service.UserService;</span><br><span class="line">import cn.travel.service.impl.UserServiceImpl;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;&#x2F;user&#x2F;*&quot;)</span><br><span class="line">public class UserServlet extends BaseServlet &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 注册功能</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void regist(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;验证码校验</span><br><span class="line">        String checkcode &#x3D; request.getParameter(&quot;checkcode&quot;);</span><br><span class="line">        String checkcode_session &#x3D; (String) request.getSession().getAttribute(&quot;checkcode_session&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;防止验证码复用 保证验证码只能使用一次</span><br><span class="line">        request.getSession().removeAttribute(&quot;checkcode_session&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;比较</span><br><span class="line">        if (checkcode_session &#x3D;&#x3D; null || !checkcode_session.equalsIgnoreCase(checkcode)) &#123;</span><br><span class="line">            ResultInfo info &#x3D; new ResultInfo();</span><br><span class="line">            info.setFlag(false);</span><br><span class="line">            info.setErrorMsg(&quot;验证码错误&quot;);</span><br><span class="line">            &#x2F;&#x2F;将info对象序列化为json</span><br><span class="line">            ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">            String json &#x3D; mapper.writeValueAsString(info);</span><br><span class="line">            response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取数据</span><br><span class="line">        String username &#x3D; request.getParameter(&quot;username&quot;);</span><br><span class="line">        String password &#x3D; request.getParameter(&quot;password&quot;);</span><br><span class="line">        String name &#x3D; request.getParameter(&quot;name&quot;);</span><br><span class="line">        String birthday &#x3D; request.getParameter(&quot;birthday&quot;);</span><br><span class="line">        String email &#x3D; request.getParameter(&quot;email&quot;);</span><br><span class="line">        &#x2F;&#x2F;封装对象</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setBirthday(birthday);</span><br><span class="line">        user.setEmail(email);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用service完成注册</span><br><span class="line">        UserService service &#x3D; new UserServiceImpl();</span><br><span class="line">        boolean flag &#x3D; service.regist(user);</span><br><span class="line">        &#x2F;&#x2F;响应结果</span><br><span class="line">        ResultInfo resultInfo &#x3D; new ResultInfo();</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            &#x2F;&#x2F;注册成功</span><br><span class="line">            resultInfo.setFlag(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;注册失败</span><br><span class="line">            resultInfo.setFlag(false);</span><br><span class="line">            resultInfo.setErrorMsg(&quot;注册失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将resultInfo对象序列化为JSON，并写回客户端</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        String json &#x3D; mapper.writeValueAsString(resultInfo);</span><br><span class="line">        &#x2F;&#x2F;将json数据写回客户端</span><br><span class="line">        &#x2F;&#x2F;设置content-type</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        response.getWriter().write(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 登录功能</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;获取用户名和密码数据</span><br><span class="line">        Map&lt;String, String[]&gt; map &#x3D; request.getParameterMap();</span><br><span class="line">        &#x2F;&#x2F;分装user对象</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        try &#123;</span><br><span class="line">            BeanUtils.populate(user, map);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用service查询</span><br><span class="line">        UserService service &#x3D; new UserServiceImpl();</span><br><span class="line">        User u &#x3D; service.login(user);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断</span><br><span class="line">        ResultInfo resultInfo &#x3D; new ResultInfo();</span><br><span class="line">        if (u &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;用户名密码错误</span><br><span class="line">            resultInfo.setFlag(false);</span><br><span class="line">            resultInfo.setErrorMsg(&quot;用户名或密码错误!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断用户是否激活</span><br><span class="line">        if (u !&#x3D; null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())) &#123;</span><br><span class="line">            &#x2F;&#x2F;用户尚未激活</span><br><span class="line">            resultInfo.setFlag(false);</span><br><span class="line">            resultInfo.setErrorMsg(&quot;您尚未激活，请前往邮箱激活!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;登录成功的判断</span><br><span class="line">        if (u !&#x3D; null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())) &#123;</span><br><span class="line">            &#x2F;&#x2F;登录成功</span><br><span class="line">            resultInfo.setFlag(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.getSession().setAttribute(&quot;user&quot;, u);</span><br><span class="line">        &#x2F;&#x2F;响应数据</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        String json &#x3D; mapper.writeValueAsString(resultInfo);</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        response.getWriter().write(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找单个对象</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        Object user &#x3D; request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">        &#x2F;&#x2F;将user写回客户端</span><br><span class="line">        ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        mapper.writeValue(response.getOutputStream(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退出</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void exit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;销毁session</span><br><span class="line">        request.getSession().invalidate();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;跳转页面  重定向</span><br><span class="line">        response.sendRedirect(request.getContextPath() + &quot;&#x2F;login.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 激活</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void active(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;获取激活码</span><br><span class="line">        String code &#x3D; request.getParameter(&quot;code&quot;);</span><br><span class="line">        if (code !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;调用service完成激活</span><br><span class="line">            UserService service &#x3D; new UserServiceImpl();</span><br><span class="line">            Boolean flag &#x3D; service.active(code);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;判断标记</span><br><span class="line">            String msg &#x3D; null;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                &#x2F;&#x2F;激活成功</span><br><span class="line">                msg &#x3D; &quot;激活成功，请&lt;a href&#x3D;&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;激活失败</span><br><span class="line">                msg &#x3D; &quot;激活失败，联系管理员&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line">            response.getWriter().write(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记(三)</title>
    <url>/2020/06/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<p>Spring学习笔记</p>
<a id="more"></a>

<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h4><p>AOP(Aspect Oriented Programming)意为：面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发的一个热点，也是Spring框架的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200606155106.png" alt=""></p>
<h4 id="AOP在Spring中的作用"><a href="#AOP在Spring中的作用" class="headerlink" title="AOP在Spring中的作用"></a>AOP在Spring中的作用</h4><p><strong>提供声明式事务；允许用户自定义切面</strong></p>
<ol>
<li>连接点(Joinpoint)： 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点，也可以理解连接点为：目标类上哪些有可能被增强的方法。   </li>
<li>切点（Pointcut）：可以理解为查询条件。一个target（目标类）的所有方法都是连接点，切点可以通过查询条件定位特定的连接点。</li>
<li>增强（Advice）：织入目标类连接点上的一段程序代码。既包含连接点上的执行逻辑（横切逻辑、增强逻辑）又包含定位连接点的方位信息，before、after、around等。增强默认织入目标类的所有方法中。</li>
<li>目标对象（Target）：增强逻辑织入的目标类。</li>
<li>代理（Proxy）：一个类被AOP植入增强后，被产生一个结果代理类。</li>
<li>织入(Weaving)：将通知（增强）应用到连接点上，生成代理的过程。 </li>
<li>切面（Aspect)：由切点和增强组成。</li>
<li>引介（Introduction)<strong>:</strong>引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200606175926.png" alt=""></p>
<p><strong>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：</strong></p>
<p><strong>前置增强</strong><br>    BeforeAdvice  代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。<br><strong>后置增强</strong><br>     AfterAdvice 代表后增强，表示目标方法在执行后实施增强<br><strong>环绕增强</strong><br>     MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强<br><strong>异常抛出增强</strong><br>     ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强<br><strong>引介增强</strong><br>     IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性</p>
<p>及AOP在不改变原来代码的情况下，去增加新的功能。</p>
<h4 id="使用Spring实现AOP"><a href="#使用Spring实现AOP" class="headerlink" title="使用Spring实现AOP"></a>使用Spring实现AOP</h4><p>使用AOP，需要导入一个依赖包！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>方式一：使用Spring的API接口</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.demo.service.UserServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.demo.log.Log"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"afterLog"</span> <span class="attr">class</span>=<span class="string">"com.demo.log.AfterLog"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    配置aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        切入点 expression:表达式，execution（要执行的位置）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.demo.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--        执行软绕增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"log"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"afterLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/6 16:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//method:要执行的目标对象的方法</span></span><br><span class="line">    <span class="comment">//args:参数</span></span><br><span class="line">    <span class="comment">//o:目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(o.getClass().getName()+<span class="string">"的"</span>+method.getName()+<span class="string">"被执行了"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/6 16:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">//动态代理的式接口</span></span><br><span class="line">        UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式二：自定义来实现AOP【主要是切面定义】</strong></p>
<p>DiyPointCut.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/6 17:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointCut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========方法执行前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========方法执行后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"diy"</span> <span class="attr">class</span>=<span class="string">"com.demo.diy.DiyPointCut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义切面 ref引用类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"diy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"point"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.demo.service.UserServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"point"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三：使用注解实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/6 18:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//标注这个类是一个切面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.demo.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----------方法执行前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.demo.service.UserServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------方法执行后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要开启注解支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Spring框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记(四)</title>
    <url>/2020/06/10/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    <content><![CDATA[<p>Spring学习笔记</p>
<a id="more"></a>

<h3 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h3><p>步骤：</p>
<ol>
<li>导入相关jar包<ul>
<li>junit</li>
<li>mybatis</li>
<li>mysql数据库</li>
<li>spring相关的</li>
<li>aop植入</li>
<li>mybatis-spring【new】</li>
</ul>
</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h4 id="回忆MyBatis"><a href="#回忆MyBatis" class="headerlink" title="回忆MyBatis"></a>回忆MyBatis</h4><ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写Mapper.xml</li>
<li>测试</li>
</ol>
<h4 id="Mybatis-Spring"><a href="#Mybatis-Spring" class="headerlink" title="Mybatis-Spring"></a>Mybatis-Spring</h4><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 <code>SqlSession</code> 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 <code>DataAccessException</code>。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p>
<p>要使用 MyBatis-Spring 模块，只需要在类路径下包含 <code>mybatis-spring-2.0.5.jar</code> 文件和相关依赖即可。如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>编写数据源</li>
<li>sqlSessionfactory</li>
<li>sqlSessionTemplate</li>
<li>需要接口加实现类</li>
<li>将自己写的实现类注入到spring中测试使用</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--DataSource:使用Spring的数据源替换Mybatis的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"datasource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定MyBatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/demo/mapper/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--sqlSessionTemplate就是我们使用的sqlSession--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只能使用构造器注入 没有set方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"teacherMapper"</span> <span class="attr">class</span>=<span class="string">"com.demo.mapper.TeacherMapperImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSession"</span> <span class="attr">ref</span>=<span class="string">"sqlSession"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>TeacherMapperImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/7 18:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherMapperImpl</span> <span class="keyword">implements</span> <span class="title">TeacherMapper</span></span>&#123;</span><br><span class="line">    <span class="comment">//我们的所有操作都需要SqlSession来执行，现在使用SqlSessionTemplate</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">selectTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> mapper.selectTeacher();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SqlSessionDaoSupport"><a href="#SqlSessionDaoSupport" class="headerlink" title="SqlSessionDaoSupport"></a>SqlSessionDaoSupport</h4><p><code>SqlSessionDaoSupport</code> 是一个抽象的支持类，用来为你提供 <code>SqlSession</code>。调用 <code>getSqlSession()</code> 方法你会得到一个 <code>SqlSessionTemplate</code>，之后可以用于执行 SQL 方法，就像下面这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().selectOne(<span class="string">"org.mybatis.spring.sample.mapper.UserMapper.getUser"</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类里面，通常更倾向于使用 <code>MapperFactoryBean</code>，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。</p>
<p><code>SqlSessionDaoSupport</code> 需要通过属性设置一个 <code>sqlSessionFactory</code> 或 <code>SqlSessionTemplate</code>。如果两个属性都被设置了，那么 <code>SqlSessionFactory</code> 将被忽略。</p>
<p>假设类 <code>UserMapperImpl</code> 是 <code>SqlSessionDaoSupport</code> 的子类，可以编写如下的 Spring 配置来执行设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>



<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><h4 id="回顾事务"><a href="#回顾事务" class="headerlink" title="回顾事务"></a>回顾事务</h4><ul>
<li>把一组业务当成一个业务来做，要么都成功，要么都失败</li>
<li>事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎</li>
<li>确保完整性和一致性</li>
</ul>
<p>事务的ACID原则：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h4 id="Spring中事务管理"><a href="#Spring中事务管理" class="headerlink" title="Spring中事务管理"></a>Spring中事务管理</h4><ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要在代码中，进行事务的管理</li>
</ul>
<p>一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。</p>
<p>一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 <code>SqlSession</code> 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。</p>
<p>事务配置好了以后，MyBatis-Spring 将会透明地管理事务。这样在你的 DAO 类中就不需要额外的代码了。</p>
<h4 id="标准配置"><a href="#标准配置" class="headerlink" title="标准配置"></a>标准配置</h4><p>要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 <code>DataSourceTransactionManager</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"transactionManager"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">  &lt;constructor-arg ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的 <code>DataSource</code> 可以是任何能够与 Spring 兼容的 JDBC <code>DataSource</code>。包括连接池和通过 JNDI 查找获得的 <code>DataSource</code>。</p>
<p>注意：为事务管理器指定的 <code>DataSource</code> <strong>必须</strong>和用来创建 <code>SqlSessionFactoryBean</code> 的是同一个数据源，否则事务管理器就无法工作了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置声明式事务--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"datasource"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--结合AOP实现事务的织入--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--配置事务切入--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"txPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.demospring.Mapper.*.*(..))"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPointcut"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>为什么需要事务？</p>
</blockquote>
<ul>
<li>如果不配置事务，可能存在数据提交不一致情况</li>
<li>如果我们不在Spring中去配置声明事务，我们就需要在代码中手动配置事务</li>
<li>事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不能马虎</li>
</ul>
]]></content>
      <tags>
        <tag>Spring框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>注解和反射</title>
    <url>/2020/06/12/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>注解和反射笔记</p>
<a id="more"></a>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>java.Annotation包</p>
<ul>
<li><p>Annotation是从JDK5.0开始引入的新技术</p>
</li>
<li><p>Annotation的作用：</p>
<ul>
<li>不是程序本事，可以对程序做出解释（这一点和注释comment没什么区别）</li>
<li>可以被其他程序（比如编译器）读取</li>
</ul>
</li>
<li><p>Annotation的格式</p>
<ul>
<li>注解是以”@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=”unchecked”)</li>
</ul>
</li>
<li><p>Annotation在哪里使用?</p>
<ul>
<li>可以附加在package，class，method，filed等上面， 相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</li>
</ul>
</li>
</ul>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p><strong>@Override</strong>：定义在java.lang.Override中，此注解只适合用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明<br><strong>@Deprecated</strong>：定义在java.lang.Deprecated中，此注解可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为他们很危险或者存在更好的选择</p>
<p><strong>@SuppressWarnings</strong>:定义在java.lang.SuppressWarning中，用来抑制编译时的警告信息。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>元注解的作用就是负责注解其他注解，java定义了4个标准的meta-annotation类型，他们被用来提供给对其他annotation类型做说明<ul>
<li><strong>@Target</strong>：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li>
<li><strong>@Retention</strong>：表示需要在什么级别保存该注释信息，用于描述注解的生命周期<ul>
<li>（SOURCE&lt;CLASS&lt;RUNTIME）</li>
</ul>
</li>
<li><strong>@Document</strong>：说明该注解将被包含在javadoc中</li>
<li><strong>Inherited</strong>：说明子类可以继承父类中的该注解</li>
</ul>
</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用<code>@interface</code>自定义注解时，自动继承了java.lang.anntation.Anntation接口</p>
<p><strong>分析：</strong></p>
<ol>
<li>@interface用来声明一个注解，格式：public @interface 注解名 {定义内容}</li>
<li>其中每一个方法实际上是声明了一个配置参数</li>
<li>方法的名称就是参数的名称</li>
<li>返回值的类型就是参数的类型（返回值只能是基本类型，Class，String，enum）</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value</li>
<li>注解元素必须有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/10 19:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>2(name = <span class="string">"张三"</span>,schools = &#123;<span class="string">"黑龙江八一农垦大学"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    <span class="comment">//注解的参数</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line"></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">"清华大学"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h3><ul>
<li>Reflection(反射)时Java被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法</li>
</ul>
<p><code>Class c = Class.forName(&quot;java.lang.String&quot;)</code></p>
<ul>
<li>加载完类之后，在堆内存的方法去中就产生了一个class类型的对象(一个类只有一个class对象)，这个对象就包含了完整的类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200611083859.png" alt=""></p>
<blockquote>
<p><strong>Java反射的优缺点</strong></p>
</blockquote>
<p>优点：可以实现动态创建对象和编译，体现出很大的灵活性</p>
<p>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么兵器它满足我们的需求。这类操作总是慢于直接执行相同的操作。</p>
<h3 id="获得反射对象"><a href="#获得反射对象" class="headerlink" title="获得反射对象"></a>获得反射对象</h3><p><strong>Class类</strong></p>
<p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定的某个结构(class/interface/enum/annotation/primitive type/void[])的有关信息。</p>
<ul>
<li>Class本身也是一个类</li>
<li>Class对象只能由系统建立对象</li>
<li>一个加载的类在JVM中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，支队任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
<p><strong>Class的常用方法</strong></p>
<hr>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static ClassforName(String name)</td>
<td>返回指定类名name的Class对象</td>
</tr>
<tr>
<td>Object newInstance()</td>
<td>调用缺省构造函数，返回一个Class对象的实例</td>
</tr>
<tr>
<td>getName()</td>
<td>返回此Class对象表示的实体(类、接口、数组类或void)的名称</td>
</tr>
<tr>
<td>Class getSuperClass</td>
<td>返回当前Class对象的父类Class对象</td>
</tr>
<tr>
<td>Class[] getinterfaces</td>
<td>返回当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getClassLoader</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Constructor[] getConstructors()</td>
<td>返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td>Method getMethod(String name,Class.. T)</td>
<td>返回一个Method对象，此对象的参数类型为paramType</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>返回Field对象的一个数组</td>
</tr>
</tbody></table>
<h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200611193710.png" alt=""></p>
<p><strong>类的加载过程</strong></p>
<p>当程序主动使用某个类时，如果该类未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200611194753.png" alt=""></p>
<ul>
<li><strong>加载</strong>：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时的数据结构，然后生成一个代表这个类的java.lang.Class对象</li>
<li><strong>链接</strong>：将java类的二进制文件合并到JVM的运行状态之中的过程<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池内的符号引用(常量名)替换为直接引用（地址）的过程</li>
</ul>
</li>
<li><strong>初始化</strong>：<ul>
<li>执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。类构造器<code>&lt;clinit&gt;()</code>方法由编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器时构造类信息的，不是构造该类对象的构造器）</li>
<li>当初始化一个类的时候，如果发现器父类没有进行初始化，则需要先触发器父类的初始化</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么时候会发生类的初始化？</strong></p>
</blockquote>
<ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动时，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就已经存入调用类的常量池了）</li>
</ul>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><strong>类加载器的作用</strong>：将class文件的字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口，</p>
<p><strong>类缓存</strong>：标准的javaSE类可以按照要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p>
<h3 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h3><p>通过反射获取运行时类的完整结构</p>
<p>Field、Method、Constructor、Superclass、Interface、Annotation</p>
<ul>
<li>实现类的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的方法</li>
<li>全部的Field</li>
<li>注解</li>
<li>。。。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/12 15:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">"reflect.User"</span>);</span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(c1.getName());</span><br><span class="line">        System.out.println(c1.getSimpleName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        Field[] fields = c1.getFields();<span class="comment">//只能获得public修饰的</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] fields1 = c1.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        Method[] methods = c1.getMethods();<span class="comment">//获得本类机器父类的全部public方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = c1.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得指定的构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = c1.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有了class对象，能做什么？"><a href="#有了class对象，能做什么？" class="headerlink" title="有了class对象，能做什么？"></a>有了class对象，能做什么？</h3><p>创建类的对象：调用Class对象的newInstance()方法</p>
<ul>
<li>类必须有一个无参数的构造器</li>
<li>类的构造器的访问权限需要足够</li>
</ul>
<p><strong>调用指定的方法</strong></p>
<p>通过反射，调用类中的方法，通过Method类完成。</p>
<ol>
<li>通过Class类的getMethod(String name,Class..parameterTypes)方法取得一个Method对象，并设置此方法操作是锁需要的参数类型</li>
<li>之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200612164612.png" alt=""></p>
<p><code>Object invoke(Object obj,Object...args)</code></p>
<ul>
<li>Object对应原方法的返回值，若方法无返回值，此时返回null</li>
<li>若原方法为静态方法，此时形参Object obj可为null</li>
<li>若原方法参数列表为空，则Object[] args为null</li>
<li>若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记(一)</title>
    <url>/2020/06/23/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<p>SpringMVC学习笔记</p>
<a id="more"></a>

<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>ssm:mybats+Spring+SpringMVC  <strong>MVC三层架构</strong></p>
<h2 id="回顾MVC"><a href="#回顾MVC" class="headerlink" title="回顾MVC"></a>回顾MVC</h2><h3 id="1-1什么是MVC"><a href="#1-1什么是MVC" class="headerlink" title="1.1什么是MVC?"></a>1.1什么是MVC?</h3><ul>
<li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li>
<li>是将业务逻辑、数据、显示分离的方法来组织代码。</li>
<li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li>
<li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</li>
</ul>
<p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。</p>
<p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200622172810.png" alt=""></p>
<h3 id="1-2Model1时代"><a href="#1-2Model1时代" class="headerlink" title="1.2Model1时代"></a>1.2Model1时代</h3><ul>
<li>在web早期的开发中，通常采用的都是Model1。</li>
<li>Model1中，主要分为两层，视图层和模型层。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200622203521.png" alt=""></p>
<p>Model1优点：架构简单，比较适合小型项目开发；</p>
<p>Model1缺点：JSP职责不单一，职责过重，不便于维护；</p>
<h3 id="1-3Model2时代"><a href="#1-3Model2时代" class="headerlink" title="1.3Model2时代"></a>1.3Model2时代</h3><p>Model2把一个项目分成三部分，包括<strong>视图、控制、模型</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200622203745.png" alt=""></p>
<ol>
<li>用户发请求</li>
<li>Servlet接收请求数据，并调用对应的业务逻辑方法</li>
<li>业务处理完毕，返回更新后的数据给servlet</li>
<li>servlet转向到JSP，由JSP来渲染页面</li>
<li>响应给前端更新后的页面</li>
</ol>
<p><strong>职责分析：</strong></p>
<p><strong>Controller：控制器</strong></p>
<ol>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定的页面</li>
</ol>
<p><strong>Model：模型</strong></p>
<ol>
<li>业务逻辑</li>
<li>保存数据的状态</li>
</ol>
<p><strong>View：视图</strong></p>
<ol>
<li>显示页面</li>
</ol>
<p>Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。</p>
<p><strong>MVC框架要做哪些事情</strong></p>
<ol>
<li>将url映射到java类或java类的方法 .</li>
<li>封装用户提交的数据 .</li>
<li>处理请求–调用相关的业务处理–封装响应数据 .</li>
<li>将响应的数据进行渲染 . jsp / html 等表示层数据 .</li>
</ol>
<p><strong>说明：</strong></p>
<p>​    常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….</p>
<h2 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200623190811.png" alt=""></p>
<p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p>
<p>查看官方文档：<a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web</a></p>
<p><strong>我们为什么要学习SpringMVC呢?</strong></p>
<p> Spring MVC的特点：</p>
<ol>
<li>轻量级，简单易学</li>
<li>高效 , 基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p>
<p>正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .</p>
<p><strong>最重要的一点还是用的人多 , 使用的公司多 .</strong> </p>
<h3 id="2-2、中心控制器"><a href="#2-2、中心控制器" class="headerlink" title="2.2、中心控制器"></a>2.2、中心控制器</h3><p>​    Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p>
<p>​    Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，<strong>DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/640" alt=""></p>
<p>SpringMVC的原理如下图所示：</p>
<p>​    当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200623191004.png" alt=""></p>
<h3 id="2-3、SpringMVC执行原理"><a href="#2-3、SpringMVC执行原理" class="headerlink" title="2.3、SpringMVC执行原理"></a>2.3、SpringMVC执行原理</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200623191101.png" alt=""></p>
<p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p>
<p><strong>简要分析执行流程</strong></p>
<ol>
<li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p>
<p>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello" target="_blank" rel="noopener">http://localhost:8080/SpringMVC/hello</a></p>
</li>
</ol>
<p>   <strong>如上url拆分成三部分：</strong></p>
<p>   <a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></p>
<p>   SpringMVC部署在服务器上的web站点</p>
<p>   hello表示控制器</p>
<p>   通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p>
<ol start="2">
<li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p>
</li>
<li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p>
</li>
<li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p>
</li>
<li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p>
</li>
<li><p>Handler让具体的Controller执行。</p>
</li>
<li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p>
</li>
<li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p>
</li>
<li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记(二)</title>
    <url>/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<p>SpringMVC学习笔记</p>
<a id="more"></a>

<h2 id="第一个SpringMVC程序"><a href="#第一个SpringMVC程序" class="headerlink" title="第一个SpringMVC程序"></a>第一个SpringMVC程序</h2><h3 id="配置版"><a href="#配置版" class="headerlink" title="配置版"></a>配置版</h3><p>1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！</p>
<p>2、确定导入了SpringMVC 的依赖！</p>
<p>3、配置web.xml  ， 注册DispatcherServlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1.注册DispatcherServlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--启动级别-1--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml  : [servletname]-servlet.xml</p>
<blockquote>
<p>说明，这里的名称要求是按照官方来的</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5、添加 处理映射器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>6、添加 处理器适配器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>7、添加 视图解析器    </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">id</span>=<span class="string">"InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/2 19:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        mv.addObject(<span class="string">"msg"</span>,<span class="string">"HelloSpringMVC!!!"</span>);</span><br><span class="line">        <span class="comment">//视图跳转</span></span><br><span class="line">        mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、将自己的类交给SpringIOC容器，注册bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Handler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/hello"</span> <span class="attr">class</span>=<span class="string">"com.kuang.controller.HelloController"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>11、配置Tomcat 启动测试！</p>
<blockquote>
<p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p>
</blockquote>
<ol>
<li>查看控制台输出，看一下是不是缺少了什么jar包。</li>
<li>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！</li>
<li>重启Tomcat 即可解决！</li>
</ol>
<h3 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h3><p><strong>1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！</strong></p>
<p>2、由于Maven可能存在资源过滤的问题，我们将配置完善</p>
<p> 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！</p>
<p><strong>4、配置web.xml</strong></p>
<ol>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p><strong>注意点：</strong></p>
</blockquote>
<p><strong>/ 和 /* 的区别：</strong>&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。</p>
<ol>
<li><ul>
<li>注意web.xml版本问题，要最新版！</li>
<li>注册DispatcherServlet</li>
<li>关联SpringMVC的配置文件</li>
<li>启动级别为1</li>
<li>映射路径为 / 【不要用/*，会404】</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>5、添加Spring MVC配置文件</strong></p>
</li>
<li><p>在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：</p>
</li>
<li><pre><code class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span>
<span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span>
<span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span>
<span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span>
<span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span>
<span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span>
<span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span>
<span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span>

   <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span>
   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kuang.controller"</span>/&gt;</span>
   <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span>
   <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span>
   <span class="comment">&lt;!--</span>
<span class="comment">   支持mvc注解驱动</span>
<span class="comment">       在spring中一般采用@RequestMapping注解来完成映射关系</span>
<span class="comment">       要想使@RequestMapping注解生效</span>
<span class="comment">       必须向上下文中注册DefaultAnnotationHandlerMapping</span>
<span class="comment">       和一个AnnotationMethodHandlerAdapter实例</span>
<span class="comment">       这两个实例分别在类级别和方法级别处理。</span>
<span class="comment">       而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span>
<span class="comment">    --&gt;</span>
   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span>

   <span class="comment">&lt;!-- 视图解析器 --&gt;</span>
   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span></span>
<span class="tag">         <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span>
       <span class="comment">&lt;!-- 前缀 --&gt;</span>
       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span>
       <span class="comment">&lt;!-- 后缀 --&gt;</span>
       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span>
   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>

<span class="tag">&lt;/<span class="name">beans</span>&gt;</span>
<span class="comment"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 1. 在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</span><br><span class="line"></span><br><span class="line">   2. - 让IOC的注解生效</span><br><span class="line">      - 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 .....</span><br><span class="line">      - MVC的注解驱动</span><br><span class="line">      - 配置视图解析器</span><br><span class="line"></span><br><span class="line">1. **6、创建Controller**</span><br><span class="line"></span><br><span class="line">2. 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范</span><br><span class="line"></span><br><span class="line">3. &#96;&#96;&#96;java</span><br><span class="line">   import org.springframework.stereotype.Controller;</span><br><span class="line">   import org.springframework.ui.Model;</span><br><span class="line">   import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">   </span><br><span class="line">   &#x2F;**</span><br><span class="line">    * @author zhang</span><br><span class="line">    * @date 2020&#x2F;7&#x2F;2 20:20</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @Controller</span><br><span class="line">   @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">   public class HelloController &#123;</span><br><span class="line">       @RequestMapping(&quot;&#x2F;h1&quot;)</span><br><span class="line">       public String hello(Model model)&#123;</span><br><span class="line">           &#x2F;&#x2F;封装数据</span><br><span class="line">           model.addAttribute(&quot;msg&quot;,&quot;Hello,SpringMVCAnnotation!&quot;);</span><br><span class="line">           return &quot;hello&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><ul>
<li>@Controller是为了让Spring IOC容器初始化时自动扫描到；</li>
<li>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；</li>
<li>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/<strong>hello</strong>.jsp。</li>
</ul>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实现步骤其实非常的简单：</p>
<ol>
<li>新建一个web项目</li>
<li>导入相关jar包</li>
<li>编写web.xml , 注册DispatcherServlet</li>
<li>编写springmvc配置文件</li>
<li>接下来就是去创建对应的控制类 , controller</li>
<li>最后完善前端视图和controller之间的对应</li>
<li>测试运行调试.</li>
</ol>
<p>使用springMVC必须配置的三大件：</p>
<p><strong>处理器映射器、处理器适配器、视图解析器</strong></p>
<p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记(四)</title>
    <url>/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    <content><![CDATA[<p>SpringMVC学习笔记</p>
<a id="more"></a>

<h2 id="结果跳转方式"><a href="#结果跳转方式" class="headerlink" title="结果跳转方式"></a>结果跳转方式</h2><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p>
<p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的controller类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">"msg"</span>,<span class="string">"ControllerTest1"</span>);</span><br><span class="line">       mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><p>通过设置ServletAPI , 不需要视图解析器 .</p>
<p>1、通过HttpServletResponse进行输出</p>
<p>2、通过HttpServletResponse实现重定向</p>
<p>3、通过HttpServletResponse实现转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultGo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/result/t1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       rsp.getWriter().println(<span class="string">"Hello,Spring BY servlet API"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/result/t2"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       rsp.sendRedirect(<span class="string">"/index.jsp"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/result/t3"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       req.setAttribute(<span class="string">"msg"</span>,<span class="string">"/result/t3"</span>);</span><br><span class="line">       req.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/test.jsp"</span>).forward(req,rsp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p>
<p>测试前，需要将视图解析器注释掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/rsm/t1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/rsm/t2"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发二</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"forward:/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/rsm/t3"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//重定向</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p>
<p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p>
<p>可以重定向到另外一个请求实现 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC2</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/rsm2/t1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/rsm2/t2"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//重定向</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">       <span class="comment">//return "redirect:hello.do"; //hello.do为另一个请求/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="处理提交数据"><a href="#处理提交数据" class="headerlink" title="处理提交数据"></a>处理提交数据</h3><p><strong>1、提交的域名称和处理方法的参数名一致</strong></p>
<p>提交数据 : <a href="http://localhost:8080/hello?name=zhangsan" target="_blank" rel="noopener">http://localhost:8080/hello?name=zhangsan</a></p>
<p>处理方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台输出 : zhangsan</p>
<p><strong>2、提交的域名称和处理方法的参数名不一致</strong></p>
<p>提交数据 : <a href="http://localhost:8080/hello?username=zhangsan" target="_blank" rel="noopener">http://localhost:8080/hello?username=zhangsan</a></p>
<p>处理方法 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@RequestParam("username") : username提交的域的名称 .</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String name)</span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台输出 : zhangsan</p>
<p><strong>3、提交的是一个对象</strong></p>
<p>要求提交的表单域和对象的属性名一致  , 参数使用对象即可</p>
<p>1、实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">//构造</span></span><br><span class="line">   <span class="comment">//get/set</span></span><br><span class="line">   <span class="comment">//tostring()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、提交数据 : <a href="http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15" target="_blank" rel="noopener">http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15</a></p>
<p>3、处理方法 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">public String user(User user)&#123;</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台输出 : User { id=1, name=’kuangshen’, age=15 }</p>
<p>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p>
<h3 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h3><p><strong>第一种 : 通过ModelAndView</strong></p>
<p>我们前面一直都是如此 . 就不过多解释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">"msg"</span>,<span class="string">"ControllerTest1"</span>);</span><br><span class="line">       mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>第二种 : 通过ModelMap</strong></p>
<p>ModelMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String name, ModelMap model)</span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute("name",name);</span></span><br><span class="line">   model.addAttribute(<span class="string">"name"</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>第三种 : 通过Model</strong></p>
<p>Model</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/ct2/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String name, Model model)</span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute("name",name);</span></span><br><span class="line">   model.addAttribute(<span class="string">"msg"</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>就对于新手而言简单来说使用区别就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；</span><br><span class="line"></span><br><span class="line">ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</span><br><span class="line"></span><br><span class="line">ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</span><br></pre></td></tr></table></figure>

<p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p>
<p><strong>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。</strong></p>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>测试步骤：</p>
<p>1、我们可以在首页编写一个提交的表单</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/e/t"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line"> &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line"> &lt;input type=<span class="string">"submit"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>2、后台编写对应的处理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Encoding</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/e/t"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model,String name)</span></span>&#123;</span><br><span class="line">       model.addAttribute(<span class="string">"msg"</span>,name); <span class="comment">//获取表单提交的值</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"test"</span>; <span class="comment">//跳转到test页面显示输入的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、输入中文测试，发现乱码</p>
<p>修改了xml文件需要重启服务器！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后在web.xml中配置这个过滤器即可！</strong></p>
<p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记(五)</title>
    <url>/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%BA%94/</url>
    <content><![CDATA[<p>SpringMVC学习笔记</p>
<a id="more"></a>

<p>重点@ResponseBody阻止视图解析器的效果，会直接返回一个字符串</p>
<h2 id="Json交互处理"><a href="#Json交互处理" class="headerlink" title="Json交互处理"></a>Json交互处理</h2><blockquote>
<p>什么是JSON？</p>
</blockquote>
<ul>
<li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li>对象表示为键值对，数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"QinJiang"</span>&#125;</span><br><span class="line">&#123;<span class="string">"age"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">&#123;<span class="string">"sex"</span>: <span class="string">"男"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p>
<p>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Hello'</span>, <span class="attr">b</span>: <span class="string">'World'</span>&#125;; <span class="comment">//这是一个对象，注意键名也是可以使用引号包裹的</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">'&#123;"a": "Hello", "b": "World"&#125;'</span>; <span class="comment">//这是一个 JSON 字符串，本质是一个字符串</span></span><br></pre></td></tr></table></figure>



<p><strong>JSON 和 JavaScript 对象互转</strong></p>
<p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": "Hello", "b": "World"&#125;'</span>);</span><br><span class="line"><span class="comment">//结果是 &#123;a: 'Hello', b: 'World'&#125;</span></span><br></pre></td></tr></table></figure>

<p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="string">'Hello'</span>, <span class="attr">b</span>: <span class="string">'World'</span>&#125;);</span><br><span class="line"><span class="comment">//结果是 '&#123;"a": "Hello", "b": "World"&#125;'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Controller返回JSON数据</p>
</blockquote>
<p>Jackson应该是目前比较好的json解析工具了</p>
<p>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</p>
<p>我们这里使用Jackson，使用它需要导入它的jar包；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/json1"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span><span class="comment">//阻止视图解析器的效果，会直接返回一个字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">       <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">       ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//创建一个对象</span></span><br><span class="line">       User user = <span class="keyword">new</span> User(<span class="string">"秦疆1号"</span>, <span class="number">3</span>, <span class="string">"男"</span>);</span><br><span class="line">       <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">       String str = mapper.writeValueAsString(user);</span><br><span class="line">       <span class="comment">//由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span></span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；</p>
<p>通过@RequestMaping的produces属性来实现，修改下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//produces:指定响应体返回类型和编码</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/json1"</span>,produces = <span class="string">"application/json;charset=utf-8"</span>)</span><br></pre></td></tr></table></figure>

<p>再次测试， <a href="http://localhost:8080/json1" target="_blank" rel="noopener">http://localhost:8080/json1</a> ， 乱码问题OK！</p>
<p>【注意：使用json记得处理乱码问题】</p>
<blockquote>
<p>代码优化</p>
</blockquote>
<p><strong>乱码统一解决</strong></p>
<p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！</p>
<p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"objectMapper"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"failOnEmptyBeans"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>返回json字符串统一解决</strong></p>
<p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//produces:指定响应体返回类型和编码</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/json1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">       <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">       ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//创建一个对象</span></span><br><span class="line">       User user = <span class="keyword">new</span> User(<span class="string">"秦疆1号"</span>, <span class="number">3</span>, <span class="string">"男"</span>);</span><br><span class="line">       <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">       String str = mapper.writeValueAsString(user);</span><br><span class="line">       <span class="comment">//由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span></span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动tomcat测试，结果都正常输出！</p>
<blockquote>
<p>测试集合输出</p>
</blockquote>
<p>增加一个新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/json2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json2</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">   ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">   <span class="comment">//创建一个对象</span></span><br><span class="line">   User user1 = <span class="keyword">new</span> User(<span class="string">"秦疆1号"</span>, <span class="number">3</span>, <span class="string">"男"</span>);</span><br><span class="line">   User user2 = <span class="keyword">new</span> User(<span class="string">"秦疆2号"</span>, <span class="number">3</span>, <span class="string">"男"</span>);</span><br><span class="line">   User user3 = <span class="keyword">new</span> User(<span class="string">"秦疆3号"</span>, <span class="number">3</span>, <span class="string">"男"</span>);</span><br><span class="line">   User user4 = <span class="keyword">new</span> User(<span class="string">"秦疆4号"</span>, <span class="number">3</span>, <span class="string">"男"</span>);</span><br><span class="line">   List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">   list.add(user1);</span><br><span class="line">   list.add(user2);</span><br><span class="line">   list.add(user3);</span><br><span class="line">   list.add(user4);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">   String str = mapper.writeValueAsString(list);</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果 : 十分完美，没有任何问题！</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC笔记(三)</title>
    <url>/2020/07/03/SpringMVC%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<p>SpringMVC学习笔记</p>
<a id="more"></a>

<h2 id="RestFul和控制器"><a href="#RestFul和控制器" class="headerlink" title="RestFul和控制器"></a>RestFul和控制器</h2><h3 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h3><ul>
<li>控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</li>
<li>控制器负责解析用户的请求并将其转换为一个模型。</li>
<li>在Spring MVC中一个控制器类可以包含多个方法</li>
<li>在Spring MVC中，对于Controller的配置方式有很多种</li>
</ul>
<h3 id="实现Controller接口"><a href="#实现Controller接口" class="headerlink" title="实现Controller接口"></a>实现Controller接口</h3><p>Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现该接口的类获得控制器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">   <span class="comment">//处理请求且返回一个模型与视图对象</span></span><br><span class="line">   <span class="function">ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<ol>
<li><p>新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！</p>
</li>
<li><ul>
<li>删掉HelloController</li>
<li>mvc的配置文件只留下 视图解析器！</li>
</ul>
</li>
<li><p>编写一个Controller类，ControllerTest1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义控制器</span></span><br><span class="line"><span class="comment">//注意点：不要导错包，实现Controller接口，重写方法；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">"msg"</span>,<span class="string">"Test1Controller"</span>);</span><br><span class="line">       mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/t1"</span> <span class="attr">class</span>=<span class="string">"com.kuang.controller.ControllerTest1"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<ul>
<li>实现接口Controller定义控制器是较老的办法</li>
<li>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</li>
</ul>
<h3 id="使用注解-Controller"><a href="#使用注解-Controller" class="headerlink" title="使用注解@Controller"></a>使用注解@Controller</h3><ul>
<li><p>@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；</p>
</li>
<li><p>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kuang.controller"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加一个ControllerTest2类，使用注解实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Controller注解的类会自动添加到Spring上下文中</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射访问路径</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/t2"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">       model.addAttribute(<span class="string">"msg"</span>, <span class="string">"ControllerTest2"</span>);</span><br><span class="line">       <span class="comment">//返回视图位置</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行tomcat测试</p>
</li>
</ul>
<p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。</strong></p>
<p><strong>注解方式是平时使用的最多的方式！</strong></p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><p><strong>@RequestMapping</strong></p>
<ul>
<li><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</li>
<li><p>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</p>
</li>
<li><p>只注解在方法上面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/h1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问路径：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> / 项目名 / h1</p>
</li>
<li><p>同时注解类与方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/h1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问路径：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> / 项目名/ admin /h1  , 需要先指定类的路径再指定方法的路径；</p>
</li>
</ul>
<h3 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h3><p><strong>概念</strong></p>
<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p><strong>功能</strong></p>
<p>资源：互联网所有的事物都可以被抽象为资源</p>
<p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p>
<p>分别对应 添加、 删除、修改、查询。</p>
<p><strong>传统方式操作资源</strong>  ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p>​    <a href="http://127.0.0.1/item/queryItem.action?id=1" target="_blank" rel="noopener">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p>​    <a href="http://127.0.0.1/item/saveItem.action" target="_blank" rel="noopener">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p>​    <a href="http://127.0.0.1/item/updateItem.action" target="_blank" rel="noopener">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p>​    <a href="http://127.0.0.1/item/deleteItem.action?id=1" target="_blank" rel="noopener">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p>
<p><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<p>​    <a href="http://127.0.0.1/item/1" target="_blank" rel="noopener">http://127.0.0.1/item/1</a> 查询,GET</p>
<p>​    <a href="http://127.0.0.1/item" target="_blank" rel="noopener">http://127.0.0.1/item</a> 新增,POST</p>
<p>​    <a href="http://127.0.0.1/item" target="_blank" rel="noopener">http://127.0.0.1/item</a> 更新,PUT</p>
<p>​    <a href="http://127.0.0.1/item/1" target="_blank" rel="noopener">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<p><strong>学习测试</strong></p>
<ol>
<li><p>在新建一个类 RestFulController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Spring MVC中可以使用  @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射访问路径</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/commit/&#123;p1&#125;/&#123;p2&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@PathVariable <span class="keyword">int</span> p1, @PathVariable <span class="keyword">int</span> p2, Model model)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> result = p1+p2;</span><br><span class="line">       <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">       model.addAttribute(<span class="string">"msg"</span>, <span class="string">"结果："</span>+result);</span><br><span class="line">       <span class="comment">//返回视图位置</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们来测试请求查看下</p>
</li>
<li><blockquote>
<p><strong>思考：使用路径变量的好处？</strong></p>
</blockquote>
</li>
<li><ul>
<li>使路径变得更加简洁；</li>
<li>获得参数更加方便，框架会自动进行类型转换。</li>
<li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。</li>
</ul>
</li>
</ol>
<p><strong>使用method属性指定请求类型</strong></p>
<p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p>
<p>我们来测试一下：</p>
<ul>
<li><p>增加一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映射访问路径,必须是POST请求</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = &#123;RequestMethod.POST&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">   model.addAttribute(<span class="string">"msg"</span>, <span class="string">"hello!"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：</p>
</li>
</ul>
<ul>
<li><p>如果将POST修改为GET则正常了；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映射访问路径,必须是Get请求</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">   model.addAttribute(<span class="string">"msg"</span>, <span class="string">"hello!"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>小结：</strong></p>
<p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p>
<p>方法级别的注解变体有如下几个：组合注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">@PostMapping</span><br><span class="line">@PutMapping</span><br><span class="line">@DeleteMapping</span><br><span class="line">@PatchMapping</span><br></pre></td></tr></table></figure>

<p>@GetMapping 是一个组合注解，平时使用的会比较多！</p>
<p>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算符</title>
    <url>/2020/07/16/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>位运算符</p>
<a id="more"></a>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><strong>关于位运算符无非也就 与(&amp;)、或(|)、异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;)</strong></p>
<p>位运算其实就是二进制的运算，加减乘除适用于十进制，而位运算就是二进制的运算,但是由于我们的运算都是基于十进制来说的，所以会有点绕，略微有点难懂，接下来言归正传</p>
<h2 id="与运算符-amp"><a href="#与运算符-amp" class="headerlink" title="与运算符(&amp;)"></a>与运算符(&amp;)</h2><p><strong>4&amp;7</strong></p>
<p>我们需要把两个二进制转换成十进制</p>
<p>4：0000 0100</p>
<p>7：0000 0111</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/1470032-20181023204022745-1107563193.png" alt=""></p>
<blockquote>
<p>这里提到一点：1表示true，0表示false</p>
</blockquote>
<p>而与运算的时候相同位之间其实就是两个Boolean的运算</p>
<p>​           全true(1),即为true(1)</p>
<p>​           全false(0),即为false(0)</p>
<p>​           一false(0)一true(1),还是false(0)</p>
<h2 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符(|)"></a>或运算符(|)</h2><p> 以  5|9  为例</p>
<p>  5 ： 0000 0101 </p>
<p>  9 ： 0000 1001</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200716184319.png" alt=""></p>
<p>在做与运算的时候</p>
<p>​         <strong>遇true(1)就是true(1),</strong></p>
<p>​         <strong>无true(1)就是false(0)</strong></p>
<h2 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符(^)"></a>异或运算符(^)</h2><p> <strong>以 7^15 为例</strong></p>
<p> <strong>7：  0000 0111</strong></p>
<p><strong>15： 0000 1111</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/1470032-20181023204024149-967390106.png" alt=""></p>
<p>在异或的时候</p>
<p>​        只要相同都是false(0)</p>
<p>​        只有不同才是true(1)</p>
<blockquote>
<p>一个数连续异或同一个数两次,结果是它本身</p>
</blockquote>
<h2 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符(~)"></a>取反运算符(~)</h2><p>例：  ~15</p>
<p>同样的先变成二进制：15：0000 1111</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/1470032-20181023204024870-227422826.png" alt=""></p>
<p>   这个其实挺简单的，就是把1变0，0变1</p>
<p>注意：二进制中，最高位是符号位  1表示负数，0表示正数</p>
<h2 id="左移运算-lt-lt"><a href="#左移运算-lt-lt" class="headerlink" title="左移运算(&lt;&lt;)"></a>左移运算(&lt;&lt;)</h2><p>   左移就是把所有位向左移动几位</p>
<p>  如：  12 &lt;&lt; 2  意思就是12向左移动两位</p>
<p>​     12的二进制是： 0000 1100</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/1470032-20181023204025326-1518482974.png" alt=""></p>
<p>通过这个图我们可以看出来，所有的位全都向左移动两位，然后把右边空的两个位用0补上，最左边多出的两个位去掉，最后得到的结果就是00110000 结果就是48</p>
<p><strong>我们用同样的办法算 12&lt;&lt;3 结果是 96</strong></p>
<p>​              <strong>8&lt;&lt;4 结果是 128</strong></p>
<blockquote>
<p> <strong>由此我们得出一个快速的算法  M &lt;&lt; n  其实可以这么算  M &lt;&lt; n = M * 2n</strong></p>
</blockquote>
<h2 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符(&gt;&gt;)"></a><strong>右移运算符(&gt;&gt;)</strong></h2><p><strong>这个跟左移运算大体是一样的</strong></p>
<p>   <strong>例： 12 &gt;&gt; 2</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/1470032-20181023204025862-1215072643.png" alt=""></p>
<p><strong>我们可以看出来右移和左移其实是一样的，但是还是有点不同的，不同点在于对于正数和负数补位的时候补的不一样，负数补1，正数补0</strong></p>
<p><strong>如我们再做一个 –8 的  -8&gt;&gt;2</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/1470032-20181023204026563-746326181.png" alt=""></p>
<p><strong>这里总结一下，关于负数或者正数来说，移位的时候是一样的，但是在补位的时候，如果最高位是0就补0，如果最高位是1就补1</strong></p>
<blockquote>
<p><strong>由此我们得出一个快速的算法  M &gt;&gt; n  其实可以这么算  M &gt;&gt; n = M / 2^n</strong></p>
</blockquote>
<h2 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移(&gt;&gt;&gt;)"></a>无符号右移(&gt;&gt;&gt;)</h2><p>无符号右移(&gt;&gt;&gt;)只对32位和64位有意义</p>
<p>在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/07/19/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java类加载机制</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200719152255.png" alt=""></p>
<h3 id="1、什么是类的加载"><a href="#1、什么是类的加载" class="headerlink" title="1、什么是类的加载"></a>1、什么是类的加载</h3><p>类的加载指的是将类的.class文件中的<strong>二进制数据读入到内存中</strong>，将其放在运行时数据区的方法区内，然后在java堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class 对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<h3 id="2、-类的加载过程"><a href="#2、-类的加载过程" class="headerlink" title="2、 类的加载过程"></a>2、 类的加载过程</h3><p>JVM 将类的加载过程分为三个大的步骤：<strong>加载(loading)，链接(link)，初始化(initialize)</strong>。其中链接又分为三个步骤：验证，准备，解析。</p>
<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/845772-20190601111501609-1158980314.png" alt=""></p>
</blockquote>
<h4 id="1-加载：查找并加载类的二进制数据"><a href="#1-加载：查找并加载类的二进制数据" class="headerlink" title="(1) 加载：查找并加载类的二进制数据"></a>(1) 加载：查找并加载类的二进制数据</h4><p>加载是类加载过程中的第一个阶段，加载过程虚拟机需要完成以下三件事情：</p>
<p>1) 通过一个类的全限定名来获取其定义的二进制字节流；</p>
<p>2) 将这个字节流所代表的静态存储结构转为方法区的运行时数据结构；</p>
<p>3) 在Java 堆中生成一个代表这个类的java.lang.Class 对象，作为方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据</p>
<h4 id="2-链接："><a href="#2-链接：" class="headerlink" title="(2) 链接："></a>(2) 链接：</h4><p>① 验证：确保被加载类的正确性；</p>
<p>主要是为了安全考虑，为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>② 准备：为类的静态变量分配内存，并将其初始化为默认值；</p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<p>1)、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
<p>2)、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：public static int value = 3；</p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<p>③ 解析：把类中的符号引用转换为直接引用；</p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h4 id="3-初始化：为类的静态变量赋予正确的初始值"><a href="#3-初始化：为类的静态变量赋予正确的初始值" class="headerlink" title="(3) 初始化：为类的静态变量赋予正确的初始值"></a>(3) 初始化：为类的静态变量赋予正确的初始值</h4><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<p>① 声明类变量是指定初始值；</p>
<p>② 使用静态代码块为类变量指定初始值；</p>
<p>③ JVM初始化步骤</p>
<p> 1)、假如这个类还没有被加载和连接，则程序先加载并连接该类</p>
<p> 2)、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p>
<p> 3)、假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>④ 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<p>– 创建类的实例，也就是new的方式</p>
<p>– 访问某个类或接口的静态变量，或者对该静态变量赋值</p>
<p>– 调用类的静态方法</p>
<p>– 反射（如Class.forName(“com.shengsiyuan.Test”)）</p>
<p>– 初始化某个类的子类，则其父类也会被初始化</p>
<p>– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p>
<h4 id="4-结束生命周期"><a href="#4-结束生命周期" class="headerlink" title="(4) 结束生命周期"></a>(4) 结束生命周期</h4><p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<p>– 执行了System.exit()方法</p>
<p>– 程序正常执行结束</p>
<p>– 程序在执行过程中遇到了异常或错误而异常终止</p>
<p>– 由于操作系统出现错误而导致Java虚拟机进程终止</p>
<h3 id="3、类加载器"><a href="#3、类加载器" class="headerlink" title="3、类加载器"></a>3、类加载器</h3><p>JVM 类加载器作用，将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p>
<p>类加载器是通过ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p>
<p><img src="http://hi.csdn.net/attachment/201009/25/0_1285421756PHyZ.gif" alt="img"></p>
<p>(1) Bootstrap ClassLoader 引导类加载器</p>
<p>负责加载Java核心库$JAVA_HOME中的jre/lib/rt.jar 里所有的class，由c++实现，不是ClassLoader子类。</p>
<p>(2) Extension ClassLoader 扩展类加载器</p>
<p>负责加载Java 平台中扩展功能的一些jar包，包括$JAVA_HOME中的jre/lib/ext/*.jar 或 -D java.ext.dirs指定目录下的jar包。</p>
<p>(3) App ClassLoader</p>
<p>负责加载classpath 中指定的jar包及目录中class</p>
<p>(4) Custom ClassLoader</p>
<p>应用程序根据自身需要自定义的ClassLoader，如tomcat，jboss 都会根据j2ee规范自行实现ClassLoader，加载过程中会先检查是否已被加载，检查顺序是自底向上，从Custom ClassLoader 到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类在所有ClassLoader 只加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
<h3 id="4、JVM-三种预定义加载器"><a href="#4、JVM-三种预定义加载器" class="headerlink" title="4、JVM 三种预定义加载器"></a>4、JVM 三种预定义加载器</h3><p>JVM预定义有三种类加载器，当一个 JVM启动的时候，Java 默认开始使用如下三种类加载器：</p>
<p>(1) 引导类加载器（Bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。它负责将<Java_Runtime_Home>/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p>
<p>(2) 扩展类加载器（Extensions class loader）：该类加载器在此目录里面查找并加载 Java 类。扩展类加载器是由Sun的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量-Djava.ext.dirs指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
<p>(3) 系统类加载器（System class loader）：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>
<h3 id="5、类加载器-“双亲委派”-机制"><a href="#5、类加载器-“双亲委派”-机制" class="headerlink" title="5、类加载器 “双亲委派” 机制"></a>5、类加载器 “双亲委派” 机制</h3><p>(1) 双亲委派机制介绍</p>
<p>在这里需要着重说明，JVM在加载类时默认采用的是双亲委派机制。所谓的双亲委派机制，就是某个特定的类加载器在接到类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和标准扩展类加载器为例作简单分析。</p>
<p><strong>双亲委派机制是为了保证Java核心库的类型安全。**</strong>这种机制能保证不会出现用户自己能定义java.lang.Object类的情况，因为即使定义了，也加载不了。**</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的堆区、栈区和方法区简单分析</title>
    <url>/2020/07/21/Java%E7%9A%84%E5%A0%86%E5%8C%BA%E3%80%81%E6%A0%88%E5%8C%BA%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Java的堆区、栈区和方法区简单分析</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200721212509.png" alt=""></p>
<p><strong>堆：**</strong>堆主要存放Java在运行过程中new出来的对象，凡是通过new生成的对象都存放在堆中，对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。类的非静态成员变量也放在堆区，其中基本数据类型是直接保存值，而复杂类型是保存指向对象的引用，非静态成员变量在类的实例化时开辟空间并且初始化。所以你要知道类的几个时机，加载-连接-初始化-实例化。**</p>
<p><strong>栈：**</strong>栈主要存放在运行期间用到的一些局部变量（基本数据类型的变量）或者是指向其他对象的一些引用，因为方法执行时，被分配的内存就在栈中，所以当然存储的局部变量就在栈中咯。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；**</p>
<p><strong>常量池：**</strong>常量池是方法区的一部分内存。常量池在编译期间就将一部分数据存放于该区域，包含基本数据类型如int、long等以final声明的常量值，和String字符串、特别注意的是对于方法运行期位于栈中的局部变量String常量的值可以通过 String.intern()方法将该值置入到常量池中。**</p>
<p><strong>静态域：**</strong>位于方法区的一块内存。存放类中以static声明的静态成员变量。**</p>
<p><strong>方法区：**</strong>是各个线程共享的内存区域，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。它有个名字叫做Non-Heap(非堆)，目的是与Java堆区分开。**</p>
<p><strong>需要特别注意的是：</strong></p>
<p><strong>方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待 ！</strong></p>
<p><strong>最后总结起来就是：</strong></p>
<p><strong>栈：**</strong>为即时调用的方法开辟空间，存储局部变量值(基本数据类型)，局部变量引用。注意：局部变量必须手动初始化。**<br><strong>堆：**</strong>存放引用类型的对象，即new出来的对象、数组值、类的非静态成员变量值(基本数据类型)、非静态成员变量引用。其中非静态成员变量在实例化时开辟空间初始化值。更具体点，个人感觉非静态成员变量是放在堆的对象中。**<br><strong>方法区：**</strong>存放class二进制文件。包含类信息、静态变量，常量池（String字符串和final修饰的常量值等），类的版本号等基本信息。因为是共享的区域，所以如果静态成员变量的值或者常量值(String类型的值能够非修改，具体请查看博客)被修改了直接就会反应到其它类的对象中。**</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单例模式</title>
    <url>/2020/07/23/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式</p>
<a id="more"></a>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>单例模式的<strong>定义</strong>就是<strong>确保某一个类只有一个实例，并且提供一个全局访问点。</strong>属于设计模式三大类中的<strong><code>创建型模式</code></strong>。<br>单例模式具有典型的三个<strong>特点</strong>：</p>
<ul>
<li>只有一个实例。</li>
<li>自我实例化。</li>
<li>提供全局访问点。</li>
</ul>
<p>其<strong>UML</strong>结构图非常简单，就只有一个类，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200723175531.png" alt=""></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>优点</strong>：由于单例模式只生成一个实例，所以能够节省系统资源，减少性能开销，提高系统效率，同时也能够严格的控制客户对他的访问。</li>
<li><strong>缺点</strong>：也正是因为系统只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责”的原则，同时也没有抽象类，这样扩展起来有一定的困难。</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li><strong>饿汉式：线程安全</strong>，调用效率高，但是不能延迟加载。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/23 18:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程安全，类初始化立即加载这个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo1 singletonDemo1 = <span class="keyword">new</span> SingletonDemo1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法--&gt;外界不能通过new来创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个公开的静态方法来创建当前类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200723181255.png" alt=""></p>
<p>由于该模式类加载的时候对象就已创建了，所以加载类的速度比较慢，但是获取对象的速度比较块，且是<strong>线程安全</strong></p>
<p>的。</p>
<ul>
<li><strong>懒汉式：线程不安全</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.PSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/23 18:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo2 singletonDemo2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singletonDemo2 = <span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于该模式是在运行时加载对象的，所以加载类比较快，但是对象的获取速度相对较慢，且<strong>线程不安全</strong>。<strong>如果想要线程安全的话可以加上<code>synchronized</code>关键字</strong>，但是这样会付出惨重的效率代价</p>
<ul>
<li><strong>懒汉式(双重同步锁)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/23 18:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用双重锁机制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo3 singletonDemo3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo3 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//线程同步加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo3<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonDemo3 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singletonDemo3 = <span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：线程安全，缺点：每次获取实例都要加锁，耗费资源，其实只要实例已经生成，以后获取就不需要再锁了</p>
<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><ol>
<li>网站计数器。</li>
<li>项目中用于读取配置文件的类。</li>
<li>数据库连接池。因为数据库连接池是一种数据库资源。</li>
<li>Spring中，每个<code>Bean</code>默认都是单例的，这样便于Spring容器进行管理。</li>
<li>Servlet中<code>Application</code></li>
<li>Windows中任务管理器，回收站。<br> 等等。</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java静态工厂模式</title>
    <url>/2020/07/24/Java%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<a id="more"></a>

<p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。    </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>创建一个Shape父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/23 14:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//形状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到周长</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得面积</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>创建圆形子类继承Shape类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/24 14:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Circle&#123;"</span> +</span><br><span class="line">                <span class="string">"radius="</span> + radius +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(radius,<span class="number">2</span>) * Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建矩形子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/24 14:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//矩形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> length;<span class="comment">//长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;<span class="comment">//宽</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rect</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Rect&#123;"</span> +</span><br><span class="line">                <span class="string">"length="</span> + length +</span><br><span class="line">                <span class="string">", width="</span> + width +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (width + length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建正方形子类，间接继承Shape类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/24 14:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rect</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bianchang;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> bianchang)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bianchang,bianchang);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.<span class="title">foactorydemo</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Circle</span></span>;</span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Rect</span></span>;</span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Shape</span></span>;</span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Square</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/24 14:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CIRCLE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQUARE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Shape shape = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == CIRCLE)&#123;</span><br><span class="line">            shape = <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i == RECT)&#123;</span><br><span class="line">            shape = <span class="keyword">new</span> Rect();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i == SQUARE)&#123;</span><br><span class="line">            shape = <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数有误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h4><p>使用该工厂，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.<span class="title">foactorydemo</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Circle</span></span>;</span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Shape</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/24 14:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape shape = ShapeFactory.getInstance(ShapeFactory.CIRCLE);</span><br><span class="line">        System.out.println(shape <span class="keyword">instanceof</span> Circle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回结果为true</p>
</blockquote>
<p>更优雅的实现，将该类的所以静态资源导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.<span class="title">foactorydemo</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Circle</span></span>;</span><br><span class="line"><span class="keyword">import</span> <span class="class"><span class="keyword">class</span>类.<span class="title">Shape</span></span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>类.<span class="title">foactorydemo</span>.<span class="title">ShapeFactory</span>.*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/24 14:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape shape = getInstance(CIRCLE);</span><br><span class="line">        System.out.println(shape <span class="keyword">instanceof</span> Circle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1 它是一个具体的类，非接口 抽象类。有一个重要的getInstance()方法，利用if或者 switch创建产品并返回。</p>
<p>2 getInstance()方法通常是静态的，所以也称之为静态工厂。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）</p>
<p>2 不同的产品需要不同额外参数的时候 不支持。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java抽象工厂模式</title>
    <url>/2020/07/27/Java%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<a id="more"></a>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory*。接着定义工厂类 *ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p>
<p><em>AbstractFactoryPatternDemo*，我们的演示类使用 *FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape<em>（</em>CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p>
<h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>为形状创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:14</span></span><br><span class="line"><span class="comment"> * 形状接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个矩形！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个正方形！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个圆形!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>为颜色创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"红色!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝色！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绿色!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h3><p>为Color和Shape创建抽象工厂来获取工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h3><p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        Shape shape1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">            shape1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"RECT"</span>))&#123;</span><br><span class="line">            shape1 = <span class="keyword">new</span> Rect();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shape.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">            shape1 = <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非法参数1!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        Color color1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"RED"</span>))&#123;</span><br><span class="line">            color1 = <span class="keyword">new</span> Red();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"GREEN"</span>))&#123;</span><br><span class="line">            color1 = <span class="keyword">new</span> Green();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"BLUE"</span>))&#123;</span><br><span class="line">            color1 = <span class="keyword">new</span> Blue();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非法参数!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> color1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h3><p>创建一个工厂创建器，通过传递形状或颜色信息来获取工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        AbstractFactory factory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"SHAPE"</span>))&#123;</span><br><span class="line">            factory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"COLOR"</span>))&#123;</span><br><span class="line">            factory = <span class="keyword">new</span> ColorFactory();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非法参数!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤8"><a href="#步骤8" class="headerlink" title="步骤8"></a>步骤8</h3><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.抽象工厂模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 18:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取形状工厂</span></span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"Shape"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为circle的对象</span></span><br><span class="line">        Shape circle = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"></span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"Color"</span>);</span><br><span class="line">        Color red = colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line">        red.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200727184036.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java模板模式</title>
    <url>/2020/07/27/Java%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在模板模式中，一个抽象类公开定义了执行它的方法的方式。它的子类可以按照重写方法实现，但调用将以抽象类中定义的方法进行。这种类型的设计模式属于行为型模式。</p>
<a id="more"></a>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法子类可以不改变算法的结构即可重定义该算法的某些步骤。</p>
<p><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现</p>
<p><strong>优点：</strong></p>
<ol>
<li>封装不变部分，扩展可变部分</li>
<li>提取公共代码便于维护</li>
<li>行为有父类控制子类实现</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ol>
<li>有多个子类共有方法，且逻辑相同</li>
<li>重要的、复杂的方法，可以考虑作为模板方法</li>
</ol>
<blockquote>
<p><strong>注意事项：</strong>为了防止恶意操作，一般模板方法上都加上final关键字</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个定义操作的 <em>Game</em> 抽象类，其中，模板方法设置为 final，这样它就不会被重写。<em>Cricket</em> 和 <em>Football</em> 是扩展了 <em>Game</em> 的实体类，它们重写了抽象类的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/template_pattern_uml_diagram.jpg" alt=""></p>
<h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>创建一个抽象类，它的模板方法被设置为 final。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.模板设计模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 10:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 春晚小品 </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> 开场();</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> 叙事();</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> 煽情();</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> 谢幕();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶级业务流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> 演小品()&#123;</span><br><span class="line">        开场();</span><br><span class="line">        叙事();</span><br><span class="line">        煽情();</span><br><span class="line">        谢幕();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>创建扩展了上述类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.模板设计模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 10:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 冯巩 <span class="keyword">extends</span> 春晚小品</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> 开场() &#123;</span><br><span class="line">        System.out.println(<span class="string">"朋友们想死你们了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> 叙事() &#123;</span><br><span class="line">        System.out.println(<span class="string">"冯巩叙事"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> 煽情() &#123;</span><br><span class="line">        System.out.println(<span class="string">"冯巩煽情"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> 谢幕() &#123;</span><br><span class="line">        System.out.println(<span class="string">"冯巩谢幕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">class</span>类.模板设计模式</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 10:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        春晚小品 冯巩 = <span class="keyword">new</span> 冯巩();</span><br><span class="line">        冯巩.演小品();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200727192026.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类Clone()方法</title>
    <url>/2020/07/28/Object%E7%B1%BBClone-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Object对象有个clone()方法，实现了对象中各个属性的复制.</p>
<a id="more"></a>

<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>实现Cloneable接口，这是一个标记接口，自身没有方法</li>
<li>覆盖clone()方法，可见性提升为public</li>
</ol>
<blockquote>
<p>这里说一下为什么要重写clone方法，并且提升为public类型</p>
</blockquote>
<p>如果不重写，由于Object的clone()方法时protected修饰的，在不同包下别的类即使使用目标类的对象也不能访问目标类继承的clone()方法，只能在目标类内部使用，局限性大。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/code-snapshotsds.png" alt=""></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/aaaaaaaaa.png" alt=""></p>
<p>遇到点麻烦，我们之修改了克隆对象的地址，发现原来对象的地址也被改变了，这就涉及到了clone的浅拷贝和深拷贝。</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>clone()方法默认浅拷贝，即<strong>基本数据类型+常用类型(日期，字符串)</strong>，拷贝一份，修改克隆对象，不影响原对象。</p>
<p>但是对象类型的属性，拷贝的是引用(地址),它是两个对象共用的，所以修改克隆对象影响原对象。</p>
<p>如果想实现深拷贝，我们可以让属性对应的实体类同样实现Cloneable接口，重写clone()方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/code-snapshot.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/bbsdfsdfs.png" alt=""></p>
<p>再次测试发现克隆对象的属性，原对象的属性不会发生变化，深克隆实现成功！</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式的基本使用</title>
    <url>/2020/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。</p>
<a id="more"></a>

<blockquote>
<p>规则字符在java.util.regex Pattern类中</p>
</blockquote>
<h3 id="常见规则"><a href="#常见规则" class="headerlink" title="常见规则"></a>常见规则</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配行的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配行的结尾</td>
</tr>
<tr>
<td>.</td>
<td>匹配换行符以外的任意字符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配在方括号中的任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面子表达式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面子表达式一次或多次</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面子表达式零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配前面子表达式n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配前面子表达式n次或n次以上</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配前面子表达式至少n次，至多m次</td>
</tr>
<tr>
<td>a|b</td>
<td>匹配a或者b</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配不在方括号的任意字符</td>
</tr>
</tbody></table>
<h3 id="Java中如何使用正则表达式"><a href="#Java中如何使用正则表达式" class="headerlink" title="Java中如何使用正则表达式"></a>Java中如何使用正则表达式</h3><p>在Java中调用正则表达式的类是Java.util.regex.Matcher和Java.util.regex.Pattern,java.util.regex是JDK1.4开始提供的，有多种写法来使用正则表达式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/zzzzzz.png" alt=""></p>
<p>当然String类也提供了matches()方法来匹配正则表达式</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/xxxx.png" alt=""></p>
<p>实现模糊查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/asdada.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合比较器规则</title>
    <url>/2020/08/01/Java%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83%E5%99%A8%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>Java集合框架自带一个排序的方法<code>sort()</code>，但是需要传入一个比较器对象</p>
<a id="more"></a>

<p>我们可以定义一个比较器的类，实现<code>Comparator</code>接口，重写compare方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照年龄比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparatorAge</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.getAge() &gt; u2.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (u1.getAge() &lt; u2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">users.sort(<span class="keyword">new</span> comparatorAge());</span><br></pre></td></tr></table></figure>

<p>sort传入比较方法就可以了，但这样写明显是不合理的。</p>
<p>我们可以改进成<strong>匿名内部类</strong>的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">users.sort(<span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.getAge() &gt; u2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (u1.getAge() &lt; u2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们还可以用Java8的新特性lambda表达式优化一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">users.sort((u1,u2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (u1.getAge() &gt; u2.getAge())&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (u1.getAge() &lt; u2.getAge())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果年龄相等我们可以根据名字来排序，字符串直接调用compareTo()方法就可以了。</span></span><br><span class="line">    <span class="comment">//return u1.getName().compareTo(u2.getName());</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果存在多个比较规则的话，这样代码写起来会比较困难，我们可以用之前的工厂模式进行简单封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> colltection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/31 11:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorFactort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AGE_MIN_TO_MAX = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AGE_MAX_TO_MIN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NAME_MAX_TO_MIN = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NAME_MIN_TO_MAX = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static Comparator&lt;User&gt; comparator = null;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator <span class="title">getComparator</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        Comparator&lt;User&gt; comparator = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == AGE_MAX_TO_MIN)&#123;</span><br><span class="line">            comparator = (p1,p2)-&gt;&#123;</span><br><span class="line">              <span class="keyword">if</span> (p1.getAge() &gt; p2.getAge())&#123;</span><br><span class="line">                  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p1.getAge() &lt; p2.getAge())&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">              &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == AGE_MIN_TO_MAX)&#123;</span><br><span class="line">            comparator = (p1,p2)-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span> (p1.getAge() &gt; p2.getAge())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p1.getAge() &lt; p2.getAge())&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == NAME_MAX_TO_MIN)&#123;</span><br><span class="line">            comparator = (p1,p2)-&gt; p1.getName().compareTo(p2.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == NAME_MIN_TO_MAX)&#123;</span><br><span class="line">            comparator = (p1,p2)-&gt; p2.getName().compareTo(p1.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> comparator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO</title>
    <url>/2020/08/09/NIO/</url>
    <content><![CDATA[<p>Java NIO</p>
<a id="more"></a>

<h3 id="NIO流"><a href="#NIO流" class="headerlink" title="NIO流"></a>NIO流</h3><p>在 JDK 1.4 中新加入了 NIO( New Input/ Output)类,引入了一种基于通道和缓冲区的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。 </p>
<p>NIO是一种非线程阻塞的IO模型。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO时，可以同时做其他任务。同步的核心就是Selector，Selector代表了线程本事轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是线程和缓冲区，当IO事件就绪时，可以通过写道缓冲区，保证IO的成功，而无需线程阻塞时的等待。</p>
<h3 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h3><table>
<thead>
<tr>
<th><strong>IO</strong></th>
<th><strong>NIO</strong></th>
</tr>
</thead>
<tbody><tr>
<td>面向流</td>
<td>面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>基于Selector的非阻塞IO</td>
</tr>
</tbody></table>
<h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h3><p>Java.nio.Buffer是特定的基本类型元素的线性有序序列。</p>
<p>缓冲区的类都有四个属性：</p>
<ul>
<li>容量(Capacity)</li>
<li>上界(Limit)</li>
<li>位置(Position)</li>
<li>标记(Mark)</li>
</ul>
<p>方法：</p>
<ul>
<li>flip()确定缓冲区数据的起始点和终止点</li>
<li>clear()缓冲区初始化，准备再次接收新数据到缓冲区</li>
<li>hasRemaining()判断postion到limit之间是否还有元素</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200809165345.png" alt=""></p>
<p>缓冲区的分类有ByteBuffer(字节缓冲区)、CharBuffer(字符缓冲区)、ShortBuffer(短整型缓冲区)、IntBuffer(整形缓冲区)、LongBuffer(长整型缓冲区)、FloatBuffer(单精度缓冲区)、DoubleBuffer(双精度缓冲区)，就是没有布尔缓冲区。</p>
<p>他们都是抽象类所以不能实例化，然后他们都继承Buffer类，所以都有get()和set()方法，也都可以通过各自的静态方法allocation()创建缓冲区。</p>
<blockquote>
<p>该方法是将现有的数组包装到缓冲区中来为缓冲区中的内容分配空间。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/lllll.png" alt=""></p>
<h3 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h3><p>java.nio.Channel通过buffer(缓冲区)进行读写操作,read表示读取通道数据到缓冲区，writer表示把缓冲区数据写入到通道。</p>
<p>Channel需要通过节点流作为创建基础，例如FileInputStream和FileOutputStream的<code>getChannel()</code>方法.RandomAccessFile()也能创建文件通道，支持读写模式。通过IO创建通道是单向的，使用RandomAccessFile创建的通道支持双向。</p>
<p>通道可以异步读写，异步读写表示通道执行读写操作时，也能做别的事情， 解决线程阻塞。如果使用文件管道（FileChannel），建议用 RandomAccessFile 来创建管道，因为该类支持读写模式以及有大量处理文件的方法。</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/nasdasd.png" alt=""></p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/kklklksadasd.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200809184500.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
